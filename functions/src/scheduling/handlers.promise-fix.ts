/**
 * 排班系統API處理函數 - Promise處理優化版
 */

import { Request, Response } from 'express';
import { Timestamp, Firestore, FieldValue } from 'firebase-admin/firestore';

// 假設db已經從其他地方初始化
const db: Firestore = (global as any).db || (global as any).admin?.firestore();

/**
 * 創建批量處理的輔助函數
 * 將大數組分割成小批次並並行處理
 * @param items 要處理的項目數組
 * @param batchSize 每批次的大小
 * @param processFunction 處理函數
 */
async function processBatchAsync<T, R>(
  items: T[],
  batchSize: number,
  processFunction: (batch: T[]) => Promise<R[]>
): Promise<R[]> {
  const results: R[] = [];
  
  // 切分為批次
  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize);
    const batchResults = await processFunction(batch);
    results.push(...batchResults);
  }
  
  return results;
}

/**
 * 自動排班函數 - 修復Promise處理問題
 */
export const generateSchedules = async (req: any, res: Response) => {
  try {
    const {
      tenantId,
      storeId,
      startDate,
      endDate,
      respectLeaves = true,
      respectPreferences = true,
      optimizeForCost = false,
      generateDraft = false
    } = req.body;
    
    // 基本驗證
    if (!tenantId || !storeId || !startDate || !endDate) {
      return res.status(400).json({
        error: "缺少必要參數",
        message: "必須提供 tenantId, storeId, startDate, endDate"
      });
    }
    
    // 計算日期範圍
    const startDateObj = new Date(startDate);
    const endDateObj = new Date(endDate);
    
    if (isNaN(startDateObj.getTime()) || isNaN(endDateObj.getTime())) {
      return res.status(400).json({
        error: "日期格式無效",
        message: "日期必須是有效的YYYY-MM-DD格式"
      });
    }
    
    if (startDateObj > endDateObj) {
      return res.status(400).json({
        error: "日期範圍無效",
        message: "開始日期必須早於或等於結束日期"
      });
    }
    
    // 數據容器結構定義
    interface Employee {
      employeeId: string;
      name?: string;
      position?: string;
      roles?: string[];
      [key: string]: any;
    }
    
    interface ShiftType {
      shiftTypeId: string;
      name: string;
      startTime: string;
      endTime: string;
      minimumStaff: number;
      roles: string[];
      color?: string;
      [key: string]: any;
    }
    
    interface LeaveRecord {
      leaveId: string;
      [key: string]: any;
    }
    
    interface RestrictedDate {
      restrictedDateId: string;
      date: string;
      reason: string;
      [key: string]: any;
    }
    
    interface ScheduleRecord {
      scheduleId: string;
      shiftDate: string;
      employeeId: string;
      startTime: string;
      endTime: string;
      [key: string]: any;
    }
    
    interface EmployeePreference {
      preferenceId: string;
      employeeId: string;
      [key: string]: any;
    }
    
    interface SchedulingSetting {
      maxHoursPerWeek: Record<string, number>;
      minHoursPerWeek: Record<string, number>;
      minStaffPerShift: Record<string, number>;
      avoidContinuousShifts: boolean;
      [key: string]: any;
    }
    
    type AvailabilityStatus = boolean | 'partial';
    
    interface AvailabilityInfo {
      available: AvailabilityStatus;
      reason: string | null;
      time?: string;
      scheduleId?: string;
      leaveId?: string;
      restrictedDateId?: string;
    }
    
    interface ScheduleAssignment {
      tenantId: string;
      storeId: string;
      employeeId: string;
      shiftDate: string;
      startTime: string;
      endTime: string;
      role: string;
      shiftTypeId?: string;
      isAutoGenerated: boolean;
      status: 'draft';
      notes?: string;
      createdBy: string;
    }
    
    // 創建數據容器
    const schedulingData: {
      parameters: Record<string, any>;
      dataSources: {
        employees: Employee[];
        shiftTypes: ShiftType[];
        leaves: LeaveRecord[];
        restrictedDates: RestrictedDate[];
        employeePreferences: EmployeePreference[];
        existingSchedules: ScheduleRecord[];
      };
      processingInfo: {
        dateRange: string[];
        employeeAvailability: Record<string, Record<string, AvailabilityInfo>>;
      };
      settings?: SchedulingSetting;
      results?: {
        scheduleAssignments: ScheduleAssignment[];
        unassignedShifts: Array<{date: string; shiftTypeId: string; role: string; reason: string}>;
        employeeWorkHours: Record<string, number>;
      }
    } = {
      parameters: {
        tenantId,
        storeId,
        startDate,
        endDate,
        respectLeaves,
        respectPreferences,
        optimizeForCost,
        requestedAt: new Date().toISOString(),
        requestedBy: req.user?.uid || 'system'
      },
      dataSources: {
        employees: [],
        shiftTypes: [],
        leaves: [],
        restrictedDates: [],
        employeePreferences: [],
        existingSchedules: []
      },
      processingInfo: {
        dateRange: [],
        employeeAvailability: {}
      }
    };
    
    // 數據收集 - 準備查詢
    // 修正: 使用Promise.all正確處理所有查詢
    try {
      console.log('開始執行資料庫查詢...');
      
      // 定義所有查詢
      const [
        employees,
        shiftTypes,
        leaves,
        restrictedDates,
        existingSchedules,
        employeePreferences,
        schedulingSettings
      ] = await Promise.all([
        // 1. 獲取員工列表
        db.collection('employees')
          .where('tenantId', '==', tenantId)
          .where('storeId', '==', storeId)
          .where('status', '==', 'active')
          .get()
          .then(snapshot => {
            if (snapshot.empty) {
              throw new Error(`沒有找到符合條件的活躍員工`);
            }
            return snapshot.docs.map(doc => ({
              ...doc.data(),
              employeeId: doc.id
            })) as Employee[];
          }),
          
        // 2. 獲取班次類型定義
        db.collection('shiftTypes')
          .where('tenantId', '==', tenantId)
          .where('storeId', '==', storeId)
          .where('isActive', '==', true)
          .get()
          .then(snapshot => {
            if (snapshot.empty) {
              throw new Error(`沒有找到符合條件的班次類型定義`);
            }
            return snapshot.docs.map(doc => ({
              ...doc.data(),
              shiftTypeId: doc.id
            })) as ShiftType[];
          }),
          
        // 3. 獲取已批准的請假記錄
        respectLeaves ? 
          db.collection('leaves')
            .where('tenantId', '==', tenantId)
            .where('storeId', '==', storeId)
            .where('status', '==', 'approved')
            .where('startDate', '<=', endDate)
            .where('endDate', '>=', startDate)
            .get()
            .then(snapshot => {
              return snapshot.docs.map(doc => ({
                ...doc.data(),
                leaveId: doc.id
              })) as LeaveRecord[];
            }) : 
          Promise.resolve([] as LeaveRecord[]),
          
        // 4. 獲取禁止排班日期
        db.collection('restrictedDates')
          .where('tenantId', '==', tenantId)
          .where('storeId', '==', storeId)
          .where('isActive', '==', true)
          .where('date', '>=', startDate)
          .where('date', '<=', endDate)
          .get()
          .then(snapshot => {
            return snapshot.docs.map(doc => ({
              ...doc.data(),
              restrictedDateId: doc.id
            })) as RestrictedDate[];
          }),
          
        // 5. 獲取已存在的排班記錄
        db.collection('schedules')
          .where('tenantId', '==', tenantId)
          .where('storeId', '==', storeId)
          .where('shiftDate', '>=', startDate)
          .where('shiftDate', '<=', endDate)
          .get()
          .then(snapshot => {
            return snapshot.docs.map(doc => ({
              ...doc.data(),
              scheduleId: doc.id
            })) as ScheduleRecord[];
          }),
          
        // 6. 獲取員工排班偏好設定
        respectPreferences ?
          db.collection('employeePreferences')
            .where('tenantId', '==', tenantId)
            .where('storeId', '==', storeId)
            .get()
            .then(snapshot => {
              return snapshot.docs.map(doc => ({
                ...doc.data(),
                preferenceId: doc.id
              })) as EmployeePreference[];
            }) :
          Promise.resolve([] as EmployeePreference[]),
          
        // 7. 獲取自動排班設定
        db.collection('autoScheduleSettings')
          .where('tenantId', '==', tenantId)
          .where('storeId', '==', storeId)
          .where('isActive', '==', true)
          .limit(1)
          .get()
          .then(snapshot => {
            if (snapshot.empty) {
              // 使用預設設定
              return {
                maxHoursPerWeek: { default: 40 },
                minHoursPerWeek: { default: 8 },
                minStaffPerShift: { default: 1 },
                avoidContinuousShifts: true
              } as SchedulingSetting;
            }
            return snapshot.docs[0].data() as SchedulingSetting;
          })
      ]);
      
      // 填充數據容器
      schedulingData.dataSources.employees = employees;
      schedulingData.dataSources.shiftTypes = shiftTypes;
      schedulingData.dataSources.leaves = leaves;
      schedulingData.dataSources.restrictedDates = restrictedDates;
      schedulingData.dataSources.existingSchedules = existingSchedules;
      schedulingData.dataSources.employeePreferences = employeePreferences;
      schedulingData.settings = schedulingSettings;
      
      console.log('數據查詢完成，進行後續處理');
    } catch (error: any) {
      console.error('數據查詢過程中發生錯誤:', error);
      return res.status(500).json({
        error: "數據查詢失敗",
        details: error.message || "服務器內部錯誤"
      });
    }
    
    // 預處理數據 - 生成日期範圍
    const dateRange: string[] = [];
    const currentDate = new Date(startDate);
    while (currentDate <= endDateObj) {
      dateRange.push(currentDate.toISOString().split('T')[0]);
      currentDate.setDate(currentDate.getDate() + 1);
    }
    schedulingData.processingInfo.dateRange = dateRange;
    
    // 預處理數據 - 建立每個員工的可用性地圖
    const employeeAvailability: Record<string, Record<string, AvailabilityInfo>> = {};
    schedulingData.dataSources.employees.forEach((employee: Employee) => {
      employeeAvailability[employee.employeeId] = dateRange.reduce((acc, date) => {
        acc[date] = {
          available: true,
          reason: null
        };
        return acc;
      }, {} as Record<string, AvailabilityInfo>);
    });
    
    // 預處理請假日期
    if (respectLeaves) {
      schedulingData.dataSources.leaves.forEach(leave => {
        const leaveStartDate = new Date(leave.startDate);
        const leaveEndDate = new Date(leave.endDate);
        
        dateRange.forEach(date => {
          const currentDate = new Date(date);
          if (currentDate >= leaveStartDate && currentDate <= leaveEndDate && 
              employeeAvailability[leave.employeeId] && 
              employeeAvailability[leave.employeeId][date]) {
            employeeAvailability[leave.employeeId][date] = {
              available: false,
              reason: `請假中 (${leave.leaveType})`,
              leaveId: leave.leaveId
            };
          }
        });
      });
    }
    
    // 預處理已有排班時段
    schedulingData.dataSources.existingSchedules.forEach(schedule => {
      if (employeeAvailability[schedule.employeeId] && 
          employeeAvailability[schedule.employeeId][schedule.shiftDate]) {
        
        if (employeeAvailability[schedule.employeeId][schedule.shiftDate].available) {
          employeeAvailability[schedule.employeeId][schedule.shiftDate] = {
            available: 'partial',
            reason: '已有排班',
            time: `${schedule.startTime}-${schedule.endTime}`,
            scheduleId: schedule.scheduleId
          };
        }
      }
    });
    
    // 預處理禁止排班日期
    schedulingData.dataSources.restrictedDates.forEach(restrictedDate => {
      schedulingData.dataSources.employees.forEach(employee => {
        if (employeeAvailability[employee.employeeId] && 
            employeeAvailability[employee.employeeId][restrictedDate.date]) {
          employeeAvailability[employee.employeeId][restrictedDate.date] = {
            available: false,
            reason: `禁止排班日 (${restrictedDate.reason})`,
            restrictedDateId: restrictedDate.restrictedDateId
          };
        }
      });
    });
    
    // 完成員工可用性計算
    schedulingData.processingInfo.employeeAvailability = employeeAvailability;
    
    // 統計數據收集結果
    const stats = {
      employees: schedulingData.dataSources.employees.length,
      shiftTypes: schedulingData.dataSources.shiftTypes.length,
      leaves: schedulingData.dataSources.leaves.length,
      restrictedDates: schedulingData.dataSources.restrictedDates.length,
      existingSchedules: schedulingData.dataSources.existingSchedules.length,
      employeePreferences: schedulingData.dataSources.employeePreferences.length,
      dateRange: dateRange.length
    };
    
    console.log(`數據準備完成，統計資訊: ${JSON.stringify(stats)}`);
    
    // 執行自動排班邏輯
    if (generateDraft) {
      console.log('開始執行排班分配邏輯...');
      
      // 初始化結果容器
      schedulingData.results = {
        scheduleAssignments: [],
        unassignedShifts: [],
        employeeWorkHours: {}
      };
      
      // 初始化員工工時追蹤
      const employeeWorkHours: Record<string, number> = {};
      schedulingData.dataSources.employees.forEach(employee => {
        employeeWorkHours[employee.employeeId] = 0;
      });
      
      // 遍歷每一天進行排班
      dateRange.forEach(date => {
        console.log(`處理日期: ${date}`);
        
        // 處理每個班次類型
        schedulingData.dataSources.shiftTypes.forEach(shiftType => {
          console.log(`  處理班次類型: ${shiftType.name} (${shiftType.startTime}-${shiftType.endTime})`);
          
          // 計算班次工時
          const shiftStartHour = parseInt(shiftType.startTime.split(':')[0]);
          const shiftStartMinute = parseInt(shiftType.startTime.split(':')[1]);
          const shiftEndHour = parseInt(shiftType.endTime.split(':')[0]);
          const shiftEndMinute = parseInt(shiftType.endTime.split(':')[1]);
          
          // 計算總分鐘數
          let shiftDurationMinutes = (shiftEndHour * 60 + shiftEndMinute) - (shiftStartHour * 60 + shiftStartMinute);
          // 處理跨午夜的情況
          if (shiftDurationMinutes < 0) {
            shiftDurationMinutes += 24 * 60;
          }
          
          // 轉換為小時
          const shiftDurationHours = shiftDurationMinutes / 60;
          
          // 處理每個班次角色需求
          shiftType.roles.forEach(role => {
            // 計算該角色需要多少人
            const requiredStaff = shiftType.minimumStaff || 1;
            console.log(`    需要 ${requiredStaff} 名 ${role} 角色的員工`);
            
            // 追蹤已分配的員工數
            let assignedCount = 0;
            
            // 尋找符合條件的可用員工
            const availableEmployees = schedulingData.dataSources.employees.filter(employee => {
              // 檢查員工該日期是否可用
              const availabilityInfo = employeeAvailability[employee.employeeId]?.[date];
              if (!availabilityInfo || availabilityInfo.available === false) {
                return false;
              }
              
              // 檢查員工角色是否匹配
              const employeeRoles = employee.roles || [];
              const position = employee.position || '';
              
              if (employeeRoles.length > 0) {
                return employeeRoles.includes(role);
              }
              
              return position.toLowerCase().includes(role.toLowerCase());
            });
            
            console.log(`    找到 ${availableEmployees.length} 名符合條件的可用員工`);
            
            if (availableEmployees.length === 0) {
              // 記錄無法分配的班次
              schedulingData.results!.unassignedShifts.push({
                date,
                shiftTypeId: shiftType.shiftTypeId,
                role,
                reason: '沒有符合條件的可用員工'
              });
              console.log(`    警告: 找不到符合條件的員工，該班次未分配`);
              return; // 繼續處理下一個角色
            }
            
            // 進行排班分配
            for (let i = 0; i < requiredStaff && i < availableEmployees.length; i++) {
              // 排序員工：優先選擇已分配工時最少的員工
              const sortedEmployees = [...availableEmployees].sort((a, b) => 
                (employeeWorkHours[a.employeeId] || 0) - (employeeWorkHours[b.employeeId] || 0)
              );
              
              // 分配班次給工時最少的員工
              const selectedEmployee = sortedEmployees[0];
              
              // 創建排班記錄
              const scheduleAssignment: ScheduleAssignment = {
                tenantId,
                storeId,
                employeeId: selectedEmployee.employeeId,
                shiftDate: date,
                startTime: shiftType.startTime,
                endTime: shiftType.endTime,
                role: role,
                shiftTypeId: shiftType.shiftTypeId,
                isAutoGenerated: true,
                status: 'draft',
                notes: `自動生成的排班：${shiftType.name}`,
                createdBy: req.user?.uid || 'system'
              };
              
              // 將排班記錄添加到結果中
              schedulingData.results!.scheduleAssignments.push(scheduleAssignment);
              
              // 更新員工工時記錄
              employeeWorkHours[selectedEmployee.employeeId] = 
                (employeeWorkHours[selectedEmployee.employeeId] || 0) + shiftDurationHours;
              
              // 更新可用性，將該員工從可用列表中移除（防止重複分配）
              const employeeIndex = availableEmployees.findIndex(e => e.employeeId === selectedEmployee.employeeId);
              if (employeeIndex !== -1) {
                availableEmployees.splice(employeeIndex, 1);
              }
              
              assignedCount++;
              console.log(`    已分配 ${selectedEmployee.name || selectedEmployee.employeeId} 到該班次`);
            }
            
            // 檢查是否完全滿足了需求
            if (assignedCount < requiredStaff) {
              // 記錄部分未分配的班次
              schedulingData.results!.unassignedShifts.push({
                date,
                shiftTypeId: shiftType.shiftTypeId,
                role,
                reason: `需要 ${requiredStaff} 名員工，但只找到 ${assignedCount} 名符合條件的可用員工`
              });
              console.log(`    警告: 班次分配不完全，需要 ${requiredStaff} 人，僅分配 ${assignedCount} 人`);
            }
          });
        });
      });
      
      // 保存工時統計
      schedulingData.results!.employeeWorkHours = employeeWorkHours;
      
      // 排班統計
      const totalAssigned = schedulingData.results!.scheduleAssignments.length;
      const totalUnassigned = schedulingData.results!.unassignedShifts.length;
      console.log(`排班完成: 成功分配 ${totalAssigned} 個班次，未能分配 ${totalUnassigned} 個班次`);
      
      // 如果選擇直接生成排班記錄到資料庫
      if (generateDraft && schedulingData.results!.scheduleAssignments.length > 0) {
        try {
          console.log('開始寫入排班記錄到資料庫...');
          
          // 修正：使用批量處理避免一次寫入太多文檔
          const batchSize = 500; // Firestore批次寫入限制為500
          const scheduleAssignments = schedulingData.results!.scheduleAssignments;
          
          // 使用之前定義的批量處理函數
          await processBatchAsync(scheduleAssignments, batchSize, async (batch) => {
            const batch_writes: any[] = [];
            
            // 創建Promise陣列以同時處理多個寫入
            const writePromises = batch.map(async (schedule) => {
              try {
                const docRef = await db.collection('schedules').add({
                  ...schedule,
                  createdAt: Timestamp.now(),
                  updatedAt: Timestamp.now()
                });
                return { id: docRef.id, ...schedule };
              } catch (err) {
                console.error('寫入排班記錄失敗:', err);
                throw err;
              }
            });
            
            // 等待所有寫入完成
            return await Promise.all(writePromises);
          });
          
          console.log(`成功寫入 ${scheduleAssignments.length} 筆排班記錄到資料庫`);
        } catch (writeError: any) {
          console.error('批量寫入排班記錄時發生錯誤:', writeError);
          return res.status(500).json({
            error: "寫入排班記錄失敗",
            details: writeError.message || "服務器內部錯誤",
            partialSuccess: true,
            data: schedulingData // 返回生成的數據，即使寫入失敗
          });
        }
      }
    }
    
    // 返回整理好的數據和排班結果
    return res.status(200).json({
      success: true,
      message: generateDraft ? '自動排班完成並寫入資料庫' : '自動排班數據準備完成',
      stats: {
        employees: schedulingData.dataSources.employees.length,
        shiftTypes: schedulingData.dataSources.shiftTypes.length,
        leaves: schedulingData.dataSources.leaves.length,
        restrictedDates: schedulingData.dataSources.restrictedDates.length,
        existingSchedules: schedulingData.dataSources.existingSchedules.length,
        employeePreferences: schedulingData.dataSources.employeePreferences.length,
        dateRange: dateRange.length,
        assignedShifts: schedulingData.results?.scheduleAssignments.length || 0,
        unassignedShifts: schedulingData.results?.unassignedShifts.length || 0
      },
      data: schedulingData
    });
  } catch (error: any) {
    console.error("自動排班錯誤:", error);
    return res.status(500).json({ 
      error: "自動排班失敗", 
      details: error.message || "服務器內部錯誤" 
    });
  }
}; 