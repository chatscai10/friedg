這份報告書將整合您提供的來源資料，包含對系統核心理念、技術架構、各功能模組的詳細描述、安全性考量、部署維運建議、已知的問題與風險，以及未來的擴展規劃。這份報告的目標是讓任何僅閱讀這份報告的新公司，都能清晰地理解整個專案的需求與功能全貌。

以下是根據您的要求和提供的資料，為您整理的完整專案技術開發報告書：

---

**「吃雞排找不早」POS 與後台管理系統 - 專案技術開發報告書**

**日期：** 2024 年 05 月 30 日

**文件版本：** V1.0

**來源文件依據：** 本報告書係根據多份專案規劃與技術文件整合編寫而成，包含：
*   全方位 POS 系統模組分析與設計
*   不早 脆皮雞排 線上訂餐 (部分內容)
*   已貼上文字 (技術規格書草稿、問題修復記錄、版本與技術棧建議等)
*   炸雞排POS後台系統簡報

---

**1. 專案概述 (Project Overview)**

**1.1. 專案核心理念與目標**

本專案的核心理念是打造一套不僅能處理訂單，更能驅動成長、增加營收、優化顧客關係、降低營運成本的「全方位、高度客製化智慧餐飲解決方案」。目標是成為店家的「經營大腦」與成長夥伴。系統設計採用 **多租戶 (Multi-Tenant) SaaS 架構**，為眾多獨立店家（租戶）提供服務。其核心策略是提供媲美高階付費系統的質感與深度功能，但以 **免費註冊使用** 作為核心，吸引廣大用戶基礎，再透過增值服務與平台營運獲利。系統需具備高度靈活性與擴展性，以適應各行各業的需求，並確保租戶擁有高度的自主設定權。即使在無專用硬體（如出單機）的環境下，也能流暢使用。

專案具體目標包括：
*   提升營運效率：自動化與數位化日常營運流程（打卡、排班、叫貨、薪資計算等）。
*   實現數據整合與透明：集中管理多來源數據（訂單、庫存、銷售、績效、評價等），提供決策支援。
*   強化內部管理：標準化員工、流程、庫存與溝通管理。
*   改善內部溝通：提供公告、知識庫、投票等工具。
*   支援行動操作：員工主要功能應可在手機上完成 (透過 PWA)。
*   建立激勵機制：明確獎金與晉升管道。
*   優化人力資源：支援手動及自動排班。

**1.2. 專案範圍**

本系統涵蓋的主要功能模組與範圍如下：
*   超級管理後台 (Super Admin)
*   租戶後台 (店家管理後台)
*   線上點餐 & 會員中心 & 租戶探索平台
*   線下點餐模組 (員工端 - PWA)
*   身份認證、職位與權限管理
*   GPS 定位打卡系統
*   庫存管理系統 (月度盤點與內部叫貨)
*   排班與請假系統
*   銷售回報系統
*   薪資與獎金系統
*   績效考核、提升與降級系統
*   顧客評價系統
*   內部溝通系統 (公告、知識庫、投票)
*   系統管理功能 (審核、參數設定、日誌、基本分析)
*   取餐編號管理模組
*   硬體周邊整合模組 (雲端出單模式)
*   推薦註冊與自動獎勵機制
*   廣告投放與管理系統
*   租戶探索平台
*   系統安全框架

**本系統目前範圍外 (Out of Scope) 的項目包括**：
*   完整的即時進銷存管理 (目前僅含內部叫貨與月度盤點，不含成本計算)。
*   完整的顧客關係管理系統 (CRM)。
*   完整的線下 POS 硬體整合 (專注於 PWA 和雲端出單模式)。
*   全面的財務會計系統整合。
*   原生行動 App 開發 (目前主要為 Web App / PWA)。
*   詳細的高階數據分析儀表板 (目前提供基本數據查看及與薪資/績效相關的指標)。

**1.3. 目標使用者**

系統服務於以下幾類使用者：
*   **服務商/超級管理員 (Super Admin):** 擁有最高權限，管理所有租戶、全局設定、平台廣告與推薦系統等.
*   **租戶管理員 (店家管理員)/分店經理:** 管理其所屬店家的員工、菜單、訂單、查看報表等.
*   **分店員工/夥伴:** 處理日常點餐、接單、出單、打卡、排班、查看薪資等.
*   **顧客:** 線上點餐、查看訂單、管理會員資料、提交評價、在探索平台尋找店家.

**1.4. 文件目的**

本報告書旨在明確定義系統的架構、技術選型、開發標準、API 規範、安全要求、部署維運策略及已知風險與未來規劃。作為開發團隊的共同依循準則，確保專案品質、一致性與可維護性。這份報告特別著重於提供足夠的細節與注意事項，使新的開發團隊能夠順利接手專案。

---

**2. 架構設計 (Architectural Design)**

**2.1. 宏觀架構**

系統採用基於 Firebase 的 **無伺服器 (Serverless)** 和 **多租戶 (Multi-Tenant) SaaS 架構**。
*   **前端 (PWA):** 部署於 Firebase Hosting，處理使用者介面與互動邏輯。透過 Firebase Client SDK 與後端服務溝通。
*   **後端 (Firebase Functions):** 提供業務邏輯 API，處理第三方服務整合（金流、外送、通知）、執行身份驗證輔助（LINE Login Token 交換）、執行排程任務與背景任務。本專案將全面採用 Cloud Functions **第二代 (2nd gen)** 進行開發與部署，利用其並行處理能力降低冷啟動和延遲。
*   **資料庫 (Firestore):** 儲存所有結構化數據，如訂單、用戶、菜單、分店資訊等。強調 **共享資料庫、共享 Schema，並透過強制 TenantID 或 StoreID 過濾** 來實現多租戶資料隔離。
*   **身份驗證 (Authentication):** 主要整合 LINE Login，透過 Cloud Function 產生 Firebase 自定義 Token 進行驗證。員工可能使用 Email/Password 或其他方式（待定義）。Firebase Authentication 儲存用戶基本身份資訊並與 LINE 帳號綁定。
*   **訊息推送 (Cloud Messaging):** 用於向前端 PWA 或透過 Cloud Functions 觸發向 LINE/Telegram 發送即時通知。

**宏觀架構圖** (概念示意，詳細請參考來源文件)：
[顧客/員工 PWA @ Firebase Hosting] <--> [Firebase Client SDK] <--> [Firebase Services]
                                                    |/|\
                                                    | | (Auth, Firestore, FCM)
                                                    +---------------------> [Firebase Cloud Functions v2] <-------+
                                                    (API Logic, Node.js 20) |
                                                                            |
                                                    +-------------------------+-------------------------+
                                                    |                         |                         |
                                                [LINE Pay API] [Delivery Platform API] [Notification API]
                                                (Uber Eats, Foodpanda) (LINE Notify, Telegram)


**2.2. 前端架構 (PWA)**

*   **技術：** 標準 HTML/CSS/JavaScript。目前未指定特定前端框架 (如 Vue, React)。
*   **核心功能：** Service Worker 實現離線快取與 PWA 安裝，Manifest file 定義應用程式特性。
*   **Firebase 整合：** 必須使用 Firebase Client SDK v9.x.x (Compat) 版本，且所有引入的 SDK 組件必須使用完全相同的版本號 (目前建議 v9.22.2)。長期規劃遷移至 v9+ 模組化 SDK (建議 v11.6.1+) 以減小打包體積。
*   **UI/UX：** 介面與操作流程需高度直觀且可配置 (尤其線下點餐模組)。注重響應式設計 (RWD) 與視覺回饋。**一個關鍵風險是缺乏 UI/UX 設計稿**，可能導致後期大量調整。

**2.3. 後端架構 (Firebase Functions)**

*   **技術：** Node.js 20 LTS。使用 Cloud Functions for Firebase (第二代 - 2nd gen)。
*   **觸發器類型：** HTTPS 觸發器用於 API 請求；Authentication 觸發器用於用戶創建初始化；Pub/Sub 觸發器和 Cloud Scheduler 觸發器用於處理定時任務或異步批次任務。
*   **部署策略：** 建議將功能相關的函數組織在不同的檔案中。考慮將高度獨立或資源需求不同的功能部署為獨立的 Function Group。必須在 asia-east1 (彰化) 或 asia-northeast1 (東京) 地區部署函數，以降低延遲。
*   **冷啟動優化：** 設定合理的記憶體 (至少 256MB)。若預算允許，可設定最小實例數 (Minimum Instances) 保持函數實例活躍。避免在全局範圍內執行耗時操作。利用打包工具進行 Tree Shaking。

**2.4. 資料庫設計 (Firestore)**

*   **類型：** Firestore (NoSQL)。
*   **設計原則：** 採用共享資料庫、共享 Schema。所有敏感或租戶特定的數據必須包含 TenantID 或 StoreID 欄位，並在所有讀寫操作中強制進行過濾，確保數據隔離。需根據預期查詢模式定義必要的複合索引 (firestore.indexes.json)。
*   **限制與注意事項：** Firestore 不支援複雜的 Join 或大量聚合運算。一次查詢的返回筆數與大小有限制 (1MB)。單文件寫入頻率有限制。這些限制需要在設計時透過資料結構優化 (如適當重複儲存、建立複合索引) 或將複雜計算轉移到後端批次處理來克服。

**2.5. 外部整合 (Integrations)**

系統需要整合多個外部服務：
*   外送平台：Uber Eats API, Foodpanda API (或 Webhook 模擬)。
*   金流：LINE Pay API。
*   通知：LINE Notify, Telegram Bot API, Firebase Cloud Messaging (FCM)。
*   LINE Login (LIFF SDK)。
*   LINE Messaging API (Webhook) - 可能用於接收顧客評價.

**注意事項：** 第三方服務依賴可能受其 API 配額限制或延遲影響。需考慮請求緩存、錯誤重試與過載保護機制。

---

**3. 技術標準與規範 (Technical Standards & Specifications)**

為確保專案一致性、可維護性與穩定性，需嚴格遵循以下標準：

**3.1. 版本控制與依賴管理**
*   **版本統一：** 所有頁面必須使用相同版本的 Firebase Client SDK (建議 v9.22.2 Compat 短期統一，長期規劃 v9+ Modular SDK v11.6.1+)。所有頁面必須使用相同版本的 LIFF SDK (建議 2.21.4 或當時最新穩定版)。SDK 版本更新必須經過完整測試並同步更新所有頁面。
*   **後端 SDK 版本：** Firebase Admin SDK 建議使用最新的穩定主版本 (v13.x+)。Cloud Functions V2 SDK。
*   **Node.js Runtime：** 統一使用 Node.js 20 LTS。
*   **NPM 套件管理：** 強制使用並提交 package-lock.json 到版本控制系統 (Git)。這對於確保不同環境下依賴版本一致性**極其重要**。
*   **Firebase CLI：** 使用最新的穩定版 (v12+)。
*   **Container Base Image (如用於 Cloud Run):** 若未來導入 Cloud Run，建議使用 node:20-slim 或 node:22-slim 與 Node.js Runtime 一致.

**3.2. 編碼風格與文件**
*   **編碼風格：** 遵循一致的 JavaScript 函數命名和宣告風格指南 (docs/coding-style-guide.md)。建議使用 ESLint 搭配 Prettier 進行自動檢查與格式化。
*   **文件與註解：** 為複雜邏輯、函數用途、參數、返回值添加適當的 JSDoc 註解。技術規格書、API 規格、安全規則說明、索引定義等文件需隨開發進度及時創建和更新。

**3.3. 開發實踐**
*   **集中初始化：** 將 Firebase 和 LIFF 的核心初始化邏輯分別集中到專用文件。使用 Promise 或 async/await 確保服務在使用前已完成初始化，**嚴禁使用 setTimeout 輪詢**。
*   **後端優先：** 涉及權限、計算、狀態變更、數據驗證的核心業務邏輯必須放在 Cloud Functions 中處理。不能僅依賴前端或 Firestore Rules 進行權限控制。
*   **數據隔離：** 所有後端數據訪問必須包含並正確使用 TenantID/StoreID 過濾。
*   **原子操作：** 對於需要多步驟更新的操作，應考慮使用 Firestore Transaction 確保原子性。
*   **錯誤處理：** Cloud Functions 內部需妥善處理各種預期和非預期錯誤，並返回有意義的回應或日誌。

---

**4. 功能模組詳述 (Detailed Functional Modules)**

本節將詳細說明專案的各個功能模組，包括其目標、主要功能、邏輯要點，並標示已知的重要待辦事項或缺失的核心邏輯。

**4.1. 超級管理後台 (Super Admin)**
*   **目標：** 提供 POS 服務商中央平台，管理多租戶系統、監控營運、設定全局規則、管理租戶，並全面控制廣告系統、推薦系統與基礎通知設定。
*   **權限：** 最高系統權限，僅限服務商。
*   **主要功能：** 租戶管理（列表、狀態、資源用量、啟用/停用、模擬登入-需嚴格控管）、方案與計費管理（定義方案/層級、功能模組啟用狀態、預設資源限制）、全局設定與公告、功能開關 (Feature Flags)、廣告系統管理（全局開關、租戶狀態、版位、排行榜位置售賣管理）、推薦系統管理（激活條件規則設定-含用戶下單數、獎勵規則設定）、租戶探索平台管理（設定付費排行榜規則、管理精選店家、審核店家公開資訊）、系統監控與分析（含廣告、通知、背景任務、跨租戶匿名化趨勢分析）、安全與日誌（含超級管理員操作稽核）。
*   **技術選型：** 安全的 Web 應用程式框架。

**4.2. 推薦註冊與自動獎勵機制**
*   **目標：** 激勵推廣，降低獲客成本，提高新用戶（租戶）活躍度，自動化獎勵發放。
*   **運作流程：** 推薦碼生成 -> 新用戶註冊輸入推薦碼 -> 驗證與綁定關係 -> **激活條件追蹤 (可配置)：** 例如完成註冊+上架 N 個商品，或完成註冊+獲得至少 M 位獨立顧客透過系統成功下單 (條件 B 新增)。Super Admin 可設定當前有效的激活條件。-> **獎勵觸發與執行** (達到推薦數 -> 自動提升資源限額 / 解鎖功能 / 延長服務期)。
*   **數據模型概念：** Tenants, Plans, TenantLimits, ReferralCodes, ReferralUsages (含 activated_at 欄位), ReferralRules (activation_type, activation_threshold)。

**4.3. 廣告投放與管理系統**
*   **目標：** 為平台創造額外營收，提供靈活配置，允許租戶付費去廣告。
*   **運作流程：** 版位定義 -> 廣告設定 (Super Admin) -> 廣告請求 (Frontend) -> 廣告決策 (Backend) -> 廣告渲染 (Frontend) -> 成效追蹤。
*   **廣告類型與位置 (範例)：** 顧客端 (橫幅、插入式、待機畫面)、員工端 (登入頁、儀表板底部 - **極謹慎**)、租戶後台。廣告載入需非同步，確保不影響核心效能。
*   **獲利模式：** 去廣告訂閱、廣告版位銷售。
*   **重要注意事項：** 使用者體驗 (UX) 與初期關閉策略、效能考量。

**4.4. 線下點餐模組 (員工端 - PWA)**
*   **目標：** 提升效率，減少錯誤，利用 PWA 實現離線操作，介面與操作流程需高度直觀且可配置。
*   **外觀設計：** 大按鈕、觸控優化。**允許租戶自訂常用功能快捷鍵與佈局**。離線/線上狀態指示。預留非干擾性廣告版位 (謹慎)。
*   **功能與邏輯：** **租戶感知與配置加載** (登入驗證 TenantID，加載該租戶的快捷鍵設定、功能開關)。開單與選桌。點餐操作 (含備註、套餐替換)。訂單管理 (暫存、送單、劃單、修改/取消-需權限+Log)。結帳操作 (含混合支付、折扣/招待-需權限+Log、發票、觸發評分機制)。**強化離線模式**。**詳細權限角色定義與管理**。**現金抽屜管理與班別結算**。提供訓練模式。**資源限制檢查** (調用後端 API 檢查 TenantLimits)。**出單** (發送至租戶指定的雲端印表機伺服器 API)。
*   **市場定位：** 核心基礎模組，穩定可靠、離線能力、高自訂性是賣點。

**4.5. 取餐編號管理模組**
*   **目標：** 清晰展示訂單狀態，提升取餐效率，**支援無實體螢幕的運作模式** (透過 LINE 通知顧客)。
*   **功能：** 系統顯示訂單狀態 (如製作中/已完成)。顧客可憑號碼或通知取餐。

**4.6. 會員系統模組 (Web + LINE Login)**
*   **目標：** 建立忠誠度，收集數據，精準行銷，整合評價，**提供豐富且可由租戶自訂的活動機制**。
*   **外觀設計：** 會員中心 (租戶可自訂部分外觀、顯示資料、優惠券列表)。預留廣告版位。
*   **功能與邏輯：** 會員綁定與登入 (LINE - **租戶獨立 Channel**)。點數計算與兌換 (租戶可設定規則)。訂單追蹤與歷史查詢。顧客評價系統整合 (Pull 模式)。會員分眾標籤管理。優惠券/兌換券系統 (租戶可定義券的類型與規則)。**自動化活動設定 (Campaign Management)**: 指定日期發放活動券、生日禮自動發送 (**租戶可設定**)。這些由後端任務定時觸發。
*   **重要注意事項：** 數據隱私與法規遵循 (PDPA)。非同步載入廣告元件。
*   **市場定位：** 核心價值模組，高度客製化是重要賣點。

**4.7. 硬體周邊整合模組 (雲端出單模式)**
*   **目標：** 確保 POS 能將列印任務發送至**租戶指定的雲端印表機伺服器**，**即使無印表機也能運作**。
*   **功能與邏輯：** 雲端印表機整合 (租戶後台配置 API URL, Key, 模板；POS 後端格式化數據並調用租戶指定 API)。響應處理與錯誤重試。**無印表機方案：** 若租戶未配置，系統應能正常運作，訂單透過 KDS/PWA 介面顯示，顧客憑證可為電子郵件、簡訊、或 PWA/會員中心查看 QRCode。
*   **市場評估報告：** 優勢在於簡化客戶端硬體、支援無印表機店家。劣勢是依賴雲端服務穩定性、網路。

**4.8. 庫存管理 (Inventory Management)**
*   **目標：** 協助店家進行基本的庫存追蹤與管理，特別是月度盤點與內部叫貨流程。
*   **功能與邏輯：** 按 TenantID 隔離數據。**月度盤點：** 提供每月盤點流程管理，產生待盤點清單，夥伴線上填報數量，系統計算差異並生成報告。**內部叫貨：** 門市向中央廚房/倉庫訂購流程管理，夥伴填寫叫貨單，系統傳送申請給物流審核，記錄歷史並允許錯誤回報。**租戶可選擇是否啟用原料級管理或僅管理成品庫存**。
*   **範圍外：** 不包含完整的即時進銷存管理或成本計算。
*   **市場定位：** 核心價值模組，提供彈性滿足不同管理深度需求。

**4.9. 進階報表與數據分析 (Reporting & Analytics)**
*   **目標：** 提供經營數據洞察，協助店家優化營運。
*   **功能與邏輯：** 按 TenantID 隔離數據。**租戶可自訂儀表板關注指標**。提供基本的銷售、庫存差異、薪資報表等。**待完善：** 目前僅提供基本數據查看，詳細的數據分析儀表板為範圍外或未來擴展項。需要實現後端獲取分析數據的邏輯。
*   **市場定位：** 核心價值所在，客製化儀表板提升體驗。

**4.10. 排隊叫號系統**
*   **目標：** 管理顧客排隊順序與叫號，提升服務效率。
*   **功能：** 支援按 TenantID 隔離。(詳細功能未在來源中展開，僅列為擴充模組)。

**4.11. 外送平台串接**
*   **目標：** 整合外送平台訂單與流程，減少人工操作，方便對帳。
*   **功能與邏輯：** 按 TenantID 隔離數據。租戶可在後台設定 API Key 等憑證。系統從外送平台匯入訂單。夥伴在系統中處理外送訂單（製作、出單、更新狀態）。支援取消/拒單並同步通知平台。記錄訂單金額、平台佣金等，供結算與對帳。
*   **整合方式：** 透過 API 或 Webhook 模擬。
*   **注意事項：** 依賴第三方服務的穩定性與 API 限制。

**4.12. 租戶探索平台 (Tenant Discovery Platform)**
*   **目標：** 面向終端消費者，展示平台上的店家，為租戶導流，創造額外營收。
*   **功能與邏輯：** **店家專頁：** 顯示店家詳細公開資訊（由租戶在後台維護）、菜單預覽、進行中的活動、營業時間、聯繫方式、線上點餐連結。**店家資料發布：** 租戶可在後台選擇是否發布資訊並維護公開資料。**搜尋功能：** 地理位置、關鍵字/分類、活動篩選。**排行榜機制：** 預設排序（距離、評價），提供「推薦排序」。租戶可透過後台購買排行榜曝光位置（付費曝光）。後端 API 需能安全查詢所有選擇公開的租戶資訊。
*   **獲利模式：** 透過廣告/排名費創造額外營收。
*   **市場定位：** 平台的增值服務，後期發展重點。需要足夠多租戶才有價值。

**4.13. 夥伴管理模組 (員工管理)**
*   **目標：** 統一管理人力資源相關功能，確保人員資料安全、權限分明。
*   **功能與邏輯：** **身份認證與登入：** 整合 LINE 登入作為夥伴身份驗證，初次登入需管理員審核。Firebase Authentication 儲存基本資訊並與 LINE 綁定。**基本資料管理：** 記錄個人與任職資訊，支援匯入/匯出。**職位與權限：** 建立清晰的 6 級職等體系。各職等對應不同系統權限範圍。管理員在後台管理權限角色。權限控制在前端與後端安全規則雙重實施。**夥伴招募與審核：** 新夥伴透過註冊提交申請，管理員後台審核，通過自動建帳號、指派職位/分店。**跨店分派：** 支援夥伴跨分店任職，允許選擇工作分店進行操作，資料按分店區隔。

* *針對 `checkResourceScope` 函數的更新：* 強化了資源範圍檢查邏輯，確保店鋪隔離的準確性，並透過可選鏈符號 (`?.`) 提升了代碼在處理潛在 `undefined` 或 `null` 值時的健壯性。
* *租戶隔離邏輯強化：* 修正了租戶管理員權限判斷，確保其操作嚴格限制在自身租戶範圍內，並改進了對 `tenantId` 存在性的檢查。
* *中間件 (`withPermissionCheck`) 改進：* 優化了 `getUserInfoFromClaims` 函數對用戶身份令牌（token）中自定義聲明（claims）的解析和使用方式，使其能更可靠地提取權限相關信息。為測試環境添加了專門的模擬（mock）以隔離測試依賴，並增強了錯誤日誌記錄。
* *測試覆蓋率提升：* 透過修復測試問題和增加測試用例，整體測試覆蓋率提升至 18.53%，核心 RBAC 模組覆蓋率達到 84.09%，顯著增強了代碼質量和可靠性。

**4.14. 排班管理模組**
*   **目標：** 提供每家分店的值班表安排與請假管理，確保門市人力配置合理。
*   **功能與邏輯：** **班表排定：** 支援手動與自動排班。管理者可手動排定或使用自動排班演算法。自動生成的班表可在調整確認後發布。**自動排班演算法為關鍵待辦事項**。**手動排班建議優化：** 考慮拖拽、實時反饋、批量操作、載入模擬草稿。**班表發布與通知：** 確認後發布至夥伴前端頁面，可透過 LINE Notify 通知。**請假申請與審批：** 夥伴提交申請，系統檢查禁休日期，管理員後台審批。批准/駁回後通知。**禁休日期管理：** 管理員設定禁休日期。前端需檢查並提示額外扣除，後端需再次驗證並計算額外扣除天數。**需明確假期餘額扣減的完整邏輯**。**調班與代班：** 支援調班申請 (需管理員核可)、臨時指派代班。**出勤預警：** 對於連續高工時或即將超時情況發出預警。

**4.15. 打卡考勤模組**
*   **目標：** 提供以 GPS 定位為基礎的上下班打卡功能，精確記錄出勤。
*   **功能與邏輯：** **GPS 定位打卡：** 夥伴須在分店附近一定範圍內 (地理圍欄) 才能打卡。記錄時間戳與位置。**自動狀態判定：** 根據班表與打卡時間判定準時、遲到、早退、加班。遲到/早退通知管理員。未打卡標記缺勤。提供打卡提醒。**跨店打卡：** 支援跨店支援夥伴選擇當前工作分店後打卡。**漏打卡補登：** 夥伴提交補登申請，經管理員審核通過後補入記錄並標註「補登」。**出勤報表與整合：** 提供打卡資料報表，用於薪資計算和考勤分析。

**4.16. 銷售回報系統**
*   **目標：** 為尚未完全導入 POS 或需要人工校正情境提供銷售數據回報機制。
*   **功能與邏輯：** 分店每日營業結束可提交標準化銷售數據表單。支援自定義欄位。數據集中供財務與營運分析使用。夥伴可在員工頁面提交銷售資料。管理員可在管理頁面檢視銷售數據。

**4.17. 薪資與獎金系統模組**
*   **目標：** 評估夥伴表現並計算薪資獎金，激勵團隊。
*   **功能與邏輯：** **績效指標紀錄：** 自訂多維度指標 (銷售額、評價、出勤率等)，自動累積。管理者後台查看指標達成情況。**獎金任務：** 配置不同類型獎勵方案（條件、對象、獎金），達成條件自動計入獎金帳戶。支援可配置化獎金任務。獎金評估可由自動定時任務觸發。**薪資計算整合：** 每月根據底薪、出勤、績效、獎金等自動計算薪資。生成薪資報表。夥伴可查看個人薪資明細及獎金累計。**核心修正重點：** 需實現核心計算邏輯。**獎金評估** (evaluateBonusTasksScheduled, checkSingleCondition) 需讀取相關數據並判斷條件。**薪資計算** (calculatePayroll) 需讀取所有相關數據計算並寫入。

**4.18. 績效考核、提升與降級系統模組**
*   **目標：** 提供公平的績效評估與職位調整機制。
*   **功能與邏輯：** **績效評估體系：** 建立多維度評估體系。**晉升與降級：** 提供流程管理。支援自動觸發投票 (如實習生轉正服務滿一定時間)。支援全員投票表決。支援老闆直接指派/投票降級流程。結果記錄並更新夥伴職位。夥伴可參與績效評審與投票。**核心後端邏輯待實現**。

**4.19. 顧客評價機制模組**
*   **目標：** 收集顧客對服務與產品的反饋，作為內部改進和夥伴績效參考。
*   **功能與邏輯：** **LINE Bot 問卷：** 消費後透過 LINE Notify 發送問卷收集評分與意見 (需顧客同意)。評價匿名儲存，關聯訂單和服務夥伴。**外部評價匯入：** 支援手動輸入或連結匯入 Google評論、Uber Eats 評分等。**評價展示與告知：** 在員工端展示去識別化評價。管理員可表揚或關注差評。**績效掛鉤：** 評價影響夥伴績效指標一部分。評價採匿名且短期不對個人公開，僅管理層可查詳情。建立申訴機制。**核心修正重點：** 需設計 LINE Bot 的具體互動流程及 lineWebhook 的詳細邏輯。

**4.20. 內部溝通模組**
*   **目標：** 促進內部資訊傳播、知識分享與意見收集。
*   **功能：** 提供公告發布與管理、知識庫 (含測驗/補習班功能) 維護、投票系統 (用於晉升/降級/一般決策)。夥伴可在員工頁面查看公告、知識庫，參與投票。管理員可在管理頁面發布與管理內容。

**4.21. 系統管理功能**
*   **目標：** 提供管理員配置、監控、審核的集中入口。
*   **主要功能：** **審核中心：** 集中處理各模組待審核項目 (請假、補卡、獎金、晉升/降級等)。**參數設定：** 集中管理各模組設定參數 (存於 settings, system_config)。例如分店 GPS 範圍、薪資計算參數、獎金規則、禁休日期等。**核心修正：** **必須解決配置來源衝突** (確保單一入口)，**需明確並改進參數保存邏輯**，**必須補全未實現的參數加載函數**。落實 Firestore Rules (僅高 Level 管理員可寫)。**系統監控：** 查看操作日誌、接收即時通知 (如透過 Telegram)。基本分析數據檢視。手動輸入外部平台評價分數。**操作日誌記錄為待實現的核心後端邏輯**。

---

**5. 系統安全框架 (System Security Framework)**

安全性是 SaaS 服務的基石，尤其涉及交易和客戶數據，必須達到企業級安全標準。這是一個跨模組的框架，其原則和措施需應用到所有其他模組的開發和部署中。

**5.1. 核心原則**
*   深度防禦、最小權限、安全左移 (開發早期介入)。

**5.2. 主要安全措施**
*   **身份驗證 (Authentication):** 強密碼策略、(可選) MFA for 管理員。安全的 Session / JWT Token 管理。LINE Login 整合安全 (驗證 State, 安全處理 Callback)。依賴 Firebase Auth 監聽狀態，禁止使用 sessionStorage 或 localStorage 儲存敏感數據。定期驗證 LIFF 配置有效性。
*   **授權 (Authorization):** 實施基於角色的權限控制。**Firestore 安全規則 (Firestore Rules) 為極高優先度**。為所有 Collection 設計嚴謹讀寫規則，使用 request.auth.uid 和權限等級驗證，遵循最小權限原則。**所有 Cloud Functions 內部必須對調用者的權限進行再次驗證**。關鍵數據操作應同時通過 Firestore Rules 和 Cloud Function 內部邏輯的權限檢查。數據隔離需確保規則和函數邏輯能正確限制跨租戶數據訪問。**需提供 Firestore 安全規則的具體範例和測試計劃**。防止敏感資訊透過 API 洩漏。
*   **數據安全：** 敏感資訊加密存儲 (如：部分金鑰、密碼 Hash)。傳輸加密 (TLS/SSL)，所有前後端通訊強制使用 HTTPS。定期數據備份與加密。對第三方 API 呼叫使用安全憑證並存放於 Cloud Functions 環境變數或 Google Secret Manager。
*   **基礎設施安全：** 伺服器安全加固、防火牆設定 (WAF)。定期進行弱點掃描與修補。啟用 Firebase App Check 等機制避免非法請求。對於公開的 HTTPS 函數入口加入基本的頻率限制和 DDoS 防護。
*   **依賴管理：** 定期掃描第三方函式庫/框架的安全漏洞並及時更新。嚴格統一 SDK 版本。
*   **日誌與監控：** **詳細的操作日誌 (Audit Log)** 記錄所有重要操作 (登入、權限變更、數據修改、配置更改、廣告設定等)，包含時間、操作者 IP、操作內容。系統錯誤日誌。安全事件監控與告警，監控異常登入、權限錯誤、潛在攻擊，設定告警 (如透過 Telegram)。**操作日誌記錄為待實現的核心後端邏輯**。
*   **開發安全 (Security by Design):** 在需求分析和設計階段就考慮安全需求。開發人員安全意識培訓。程式碼安全審查 (Code Review)。**禁止硬編碼敏感資訊 (如密碼、金鑰)**。對來自客戶端或第三方服務的輸入進行嚴格驗證和清理，防止注入攻擊 (XSS, NoSQL Injection 等)。輸出到前端的數據需適當編碼防止 XSS。

**5.3. 整合方式**
這是一個跨模組的框架，其原則和措施需要應用到所有其他模組的開發和部署中。API 設計、資料庫操作、前端渲染、後台邏輯都需要遵守此框架。

**5.4. 風險與對策**
安全漏洞與攻擊是潛在風險。對策包括：定期安全掃描與滲透測試，驗證 Firestore 規則正確性 (使用模擬測試)，啟用 App Check，對公開 HTTP 函數入口加入頻率限制和 DDoS 防護。若發生資安事件，立即啟動應變流程。

---

**6. 部署與維運建議 (Deployment & Operations Recommendations)**

為確保系統順利上線並長期穩定運行，需規劃明確的部署與維運策略。

**6.1. 部署平台**
*   **前端：** Firebase Hosting。
*   **後端：** Firebase Cloud Functions V2。建議部署至 asia-east1 或 asia-northeast1 區域。

**6.2. 環境管理**
*   **必須** 區分開發 (Development) 和生產 (Production) 環境。建議使用獨立的 Firebase 專案。可考慮增加預備 (Staging) 環境用於最終驗收測試。

**6.3. 部署流程**
*   使用 Firebase CLI 手動部署。**建議建立 CI/CD Pipeline** 實現自動化部署，包含單元測試、整合測試、安全性檢查等步驟。前端部分可透過 CI/CD 自動部署至 Firebase Hosting。不同版本的前端可以使用不同子域名進行驗收測試。

**6.4. 版本升級策略**
*   系統採用模組化架構。建議使用語意化版本 (Semantic Versioning) 管理每個模組版本。未來功能更新應先在測試環境驗證再部署至正式環境。資料庫結構升級應撰寫遷移腳本或實現向下兼容讀取邏輯。緊急修復以小版本發佈。

**6.5. 監控與日誌**
*   利用 Firebase 控制台和 Cloud Logging 監控系統狀態、錯誤率、性能等。
*   定期檢視詳細操作日誌和系統錯誤日誌。
*   設定安全事件與異常情況的告警 (如透過 Telegram)。
*   維運時需區分租戶監控、廣告/通知/推薦/背景任務監控。

**6.6. 效能優化**
*   充分利用 Firestore 索引提升查詢速度。
*   運用快取機制減少不必要的重複請求 (前端本地快取菜單/設定檔，後端預計算報表結果)。
*   善用 Cloud Functions 的並行執行能力處理批次任務。
*   開啟 Cloud Functions 常駐實例 (最低暖機實例數) 減少冷啟動。
*   必要時提升 Cloud Function 記憶體配置或將模組拆分至獨立的 Cloud Run 服務進行水平擴充。

**6.7. 測試策略**
*   包含單元測試 (使用模擬器)。
*   整合測試 (測試前端與後端交互，跨模組流程，與外部服務整合)。需細化關鍵跨模組整合場景。
*   端對端測試 (模擬真實用戶場景)。需細化最關鍵的端到端流程。
*   **安全性測試：** **高優先度**。測試 Firestore Rules 和 Cloud Function 權限檢查的有效性。定期進行安全掃描與滲透測試。
*   使用者驗收測試 (UAT)：邀請不同職位/權限的真實用戶在生產前進行測試。
*   提供訓練模式。

**6.8. 資料庫備份與恢復**
*   需規劃 Firestore 定期備份機制 (如使用 Cloud Storage 或導出至備援資料庫)。
*   制定資料保留策略。
*   進行恢復測試計劃。

**6.9. 容錯與備援**
*   針對單點故障設計容錯方案 (如短期切換到本地緩存模式)。
*   維持一套傳統紙本流程或預載獨立 App 作為緊急備用方案。
*   在金流等關鍵節點加入人工介入警示。

---

**7. 已知問題與風險分析 (Known Issues & Risk Analysis)**

本專案在開發過程中已識別出多項潛在問題與風險，新的開發團隊需特別關注。

**7.1. 技術與架構層面風險**
*   **Cloud Functions 冷啟動延遲：** 在流量不連續時可能發生，影響即時響應。
    *   *對策：* 定時喚醒關鍵函式，啟用最低執行個體設定，將函式拆分為輕量觸發器/背景任務。
*   **第三方服務故障或響應延遲：** 外送、支付、通知服務問題可能導致業務中斷。
    *   *對策：* 設計重試機制和後備方案，關鍵節點加入人工介入警示，考慮使用中介服務統一處理外部整合。
*   **資料一致性與競態條件：** 分散式架構和離線功能可能導致資料同步不一致或衝突。
    *   *對策：* 善用 Firestore 事務機制與樂觀鎖，上線同步時檢查衝突並處理，重要數據使用後端批次校正。
*   **Firestore 用量及成本風險：** 高頻寫入/大量存儲可能超額產生費用。Firestore 配額限制 (如寫入次數)。
    *   *對策：* 合併寫入減少次數，定期監控用量並設置預警，優化資料保留策略 (歷史資料轉存)，根據使用情況調整索引/資料結構。
*   **Firestore 複雜查詢效能限制：** 大規模擴展時，複雜查詢受限可能成為挑戰。
    *   *對策：* 資料結構優化，建立複合索引，複雜計算轉移到後端批次處理。
*   **Node.js 單執行緒特性：** Cloud Functions 基於 Node.js，CPU 密集任務可能阻塞。
    *   *對策：* 拆分批次任務或使用雲端排程/背景任務函式。未來考慮 Serverless Containers (Cloud Run) 處理複雜/長時間任務。

**7.2. 開發與管理層面風險**
*   **缺乏 UI/UX 設計稿：** 是關鍵風險，可能導致後期大量介面調整成本高昂。強烈建議盡快取得關鍵介面設計稿。
*   **核心後端邏輯大量缺失或待完善：** 如自動排班演算法、請假扣減、獎金計算、操作日誌、分析數據獲取、審批流程實現等。這是開發的最高優先級。
*   **缺失 API 詳細規格文件：** 是關鍵待辦事項，不利於新團隊理解後端接口用途、參數、返回值和錯誤處理。需另外建立此文件。
*   **缺失 Firestore 安全規則的具體範例和測試計劃：** 是關鍵待辦事項，影響對數據訪問權限控制邏輯的理解和驗證。需提供具體範例。
*   **Firestore 複合索引未定義：** 關鍵待辦，影響查詢效能。需定義具體索引。
*   **系統參數設定的配置來源衝突與保存邏輯未解決：** 需要優先解決，確保配置管理的唯一入口和正確性。
*   **應用錯誤與當機：** Bug 可能導致前端當機，影響營運。
    *   *對策：* 強化測試 (單元、整合、E2E)，導入前端錯誤監控工具，提供緊急備用方案。

**7.3. 安全層面風險**
*   **安全漏洞與攻擊：** JWT 劫持、Firestore 規則配置錯誤、DDoS 等。
    *   *對策：* 定期安全掃描/滲透測試，驗證 Firestore 規則，啟用 App Check，對公開函數入口加入頻率限制和 DDoS 防護，建立資安事件應變流程。
*   **XSS 防護不足：** 用戶輸入內容未經處理直接渲染導致漏洞。
    *   *對策：* 前後端對所有輸入進行嚴格驗證和清理，輸出到前端的數據進行適當編碼。這需要全面覆蓋。

---

**8. 優化與擴展規劃 (Optimization & Expansion Plan)**

本系統已建立穩固基礎，未來可根據業務發展和技術演進進行功能優化與擴展。

**8.1. 短期優化 (Priority)**
*   **解決關鍵待辦事項與風險：** 優先完成缺失的核心後端邏輯、定義並測試 Firestore 安全規則與索引、解決參數配置衝突、建立詳細 API 規格文件。
*   **優化現有功能：** 根據市場評估報告和使用者反饋，提升核心模組的易用性與效能。例如線下點餐模組的高自訂性介面優化。
*   **強化安全防護：** 全面落實 XSS 防護、敏感資訊管理、後端權限檢查等措施。

**8.2. 未來擴展方向 (Future Expansion)**
*   **Kiosk 自助點餐：** 開發門市自助點餐觸控介面，重用現有 POS 邏輯，增加現場出單/螢幕叫號功能。可降低人力負擔，提升效率。
*   **進階數據分析與商業智慧：** 導入 BI 工具 (如 Google Data Studio, Tableau)，將數據匯入數據倉庫 (如 Google BigQuery) 進行大規模分析。應用機器學習模型進行銷量預測、顧客流失預測、排班優化。將決策從經驗轉向數據驅動。
*   **會員儲值與電子錢包：** 在會員系統基礎上增加儲值功能，提高顧客黏著度。需嚴謹金流管理並符合法規。
*   **更多外部平台串接：** 擴展串接更多外送平台、行動支付選項 (如街口支付、Apple Pay)、政府電子發票/報稅系統、社群媒體/評論平台 API。
*   **多語言與海外展店支持：** 加入國際化 (i18n) 支援，適配不同時區、貨幣、當地會計制度和隱私法規。
*   **SaaS 平台化：** 長遠目標，將現有架構升級為成熟的多租戶 SaaS 產品對外提供。需加強超級管理後台、租戶自助開通/配置流程、嚴格租戶數據隔離、計費計量模組等。

**8.3. 技術演進考量**
*   持續評估並採用 Firebase Cloud Functions V2 的新功能與優化。
*   考慮導入 Serverless Containers (如 Google Cloud Run) 處理需要更靈活性或特定環境依賴的模組。
*   持續監控並更新所有使用的 SDK 和第三方依賴，獲取安全更新和性能改進。

---

**9. 總結與後續步驟 (Conclusion & Next Steps)**

本報告書基於現有資料，詳細闡述了「吃雞排找不早」POS 與後台管理系統專案的核心概念、技術架構、功能模組、安全性要求、部署維運建議、已知風險與未來擴展規劃。這份文件旨在提供足夠的廣度和深度，使任何新的開發團隊能夠快速全面地了解專案，並具備接手的能力。

為了讓新團隊能夠更順暢地接手並完成剩餘部分，以下文件和工作是最高優先級的待辦事項：
1.  **完成 API 詳細規格文件：** 針對所有後端 Cloud Functions API，詳細記錄其用途、HTTP 方法、請求 URL、輸入參數格式與範例、成功響應結構與範例、錯誤碼與錯誤訊息規範。
2.  **定義並測試 Firestore 安全規則：** 編寫完整的 firestore.rules 文件，並提供詳細說明和測試範例，確保所有 Collection 的讀寫權限都得到嚴格控制和驗證。強烈建議使用 Emulator Suite 進行徹底測試。
3.  **定義 Firestore 複合索引：** 根據預期查詢模式，在 firestore.indexes.json 中定義所有必要的複合索引。
4.  **補齊缺失的核心後端邏輯：** 優先實現標記為「關鍵」或「核心修正重點」的 Cloud Functions，特別是薪資計算、獎金評估、請假扣減、操作日誌記錄、審批流程後端實現、分析數據獲取、LINE Bot 評價處理等。
5.  **解決系統參數配置的衝突與保存邏輯問題：** 確保參數設定有唯一可靠的入口和保存機制。
6.  **落實全面的安全性措施：** 特別是輸入驗證、輸出編碼 (XSS 防護)、敏感資訊管理 (使用 Secret Manager 或環境變數)、後端權限檢查等，並進行安全性測試。
7.  **產出關鍵介面的 UI/UX 設計稿：** 即使是線框圖，也能極大幫助前端開發，減少返工。
8.  **建立 CI/CD Pipeline：** 自動化測試與部署流程。
9.  **規劃詳細的部署與維運策略：** 包含環境管理、監控告警、資料備份與恢復計劃。

完成上述事項後，專案將具備更清晰的開發方向、更穩定的架構和更可靠的基礎，為後續的功能完善與擴展奠定堅實的基礎。







---

# ?? 專案目標與範疇補齊版（可直接進入開發）

---

## 1. 專案核心目標（SMART 版）

| 項目 | 說明 |
|:---|:---|
| 目標 (Specific) | 建立一套可同時服務內用、外帶、外送線上點餐的「POS點餐+後台管理系統」，並整合員工、薪資、排班、考勤、評價、會員、獎金、庫存管理於一體，且支援無印表機環境的出單。 |
| 可衡量 (Measurable) | 完成系統開發後，90%分店能以本系統成功運營三個月以上、顧客訂單錯誤率降低20%、員工管理效率提升30%、營收資料整合達100%。 |
| 可達成 (Achievable) | 運用 Firebase 全雲端部署+PWA方式，後端 Functions 模組化設計，前端無需安裝 App 也能使用，實際可於三個月內開發初版 MVP。 |
| 相關性 (Relevant) | 完全支援品牌「不早脆皮雞排」現有與擴展中的多分店營運模式，並預留多租戶 SaaS 擴充機制。 |
| 時限 (Time-bound) | 2025 年 8 月完成內部 Beta 版上線，2025 年 10 月正式推向全部分店使用。 |

---

## 2. 交付成果物（Deliverables）

- **前端 PWA 系統（POS點餐端+員工操作端+管理後台端）**
- **後端 API 系統（Firebase Cloud Functions V2）**
- **Firestore 資料庫結構（含索引）**
- **LINE/LINE Pay 整合模組**
- **外送平台 API 整合模組（Uber Eats, Foodpanda）**
- **操作日誌系統與安全性設計文件**
- **完整部署腳本與環境設定檔**
- **使用者操作手冊（簡易版）**
- **技術開發手冊（API, Rules, Data Model）**
- **訓練資料：管理端操作教學、員工端點餐教學**

---

## 3. 專案範疇（In Scope）

? POS 點餐模組（PWA）  
? 員工登入、打卡、排班、請假管理  
? 銷售資料登錄、出單、結帳（支援現金+LINE Pay）  
? 出單機雲端列印（若有印表機）、若無印表機則顯示在螢幕  
? 會員系統（LINE Login快速綁定）  
? 顧客評價機制（LINE通知問卷）  
? 庫存基本管理（內部叫貨、月度盤點）  
? 夥伴（員工）獎金、薪資計算模組  
? 顧客線上訂餐（前台）  
? 後台管理系統（店長/分店經理操作）  
? 系統管理後台（超級管理員操作）  
? 廣告版位管理（內部廣告）  
? 推薦碼/推廣註冊獎勵機制  
? 簡易報表與儀表板（銷售、出勤、庫存異常）  
? 離線運作支援（PWA緩存菜單/訂單草稿）

---

## 4. 非範疇（Out of Scope）— 特別標明！

? 不開發原生 App（Android/iOS 版 App）  
? 不實作完整 ERP / 進銷存管理（只做月度叫貨+盤點）  
? 不整合財會會計系統（例：出總帳、稅務申報）  
? 不內建客服系統（LINE群組溝通另案處理）  
? 不直接串接政府稅務電子發票（台灣統一發票平台）  
? 不支援除 LINE 以外的社群整合（如 FB Messenger、IG等另案）  
? 不做客製化每個租戶的樣式主題（僅支援標準版主題）  
? 不支援跨國貨幣多幣結帳（初版台灣新台幣）  
? 不支援異常高度客製化 API 整合（Uber/Foodpanda以標準API模組整合）

---

## 5. 關鍵績效指標（KPI）

- 90%以上分店導入三個月後無需回退舊系統
- POS訂單完成錯誤率下降 20%（以日訂單比錯單統計）
- 排班、打卡、薪資資料集中度達 95% 以上
- 顧客完成訂餐後回填評價率達 30%
- 整體營收報表自動化準確率達 99%

---






---

# ?? 使用者角色定義（User Roles）

| 角色名稱 | 說明 | 核心權限範圍 |
|:---|:---|:---|
| 超級管理員 (Super Admin) | 系統平台管理者，負責租戶（店家）管理、系統參數設定、廣告與推薦規則管理。 | 可進行所有租戶的模擬登入、參數設定、審核管理、廣告設定、推薦系統設定、營運監控。 |
| 租戶管理員 (Tenant Admin / 店長) | 各分店管理者，負責本店營運與員工管理。 | 員工管理、菜單管理、訂單管理、打卡管理、排班、公告、薪資獎金設定、資料分析查看。 |
| 分店員工 (Store Staff / 員工) | 主要負責現場接單、打卡、點餐、庫存操作。 | 打卡上下班、點餐接單、單據列印、排班查看、銷售資料提交、請假申請。 |
| 顧客 (Customer) | 使用線上點餐系統點餐與付款的終端消費者。 | 線上點餐、訂單查詢、付款、評價回饋、會員中心查看。 |

---

# ?? 使用案例定義（User Cases）

### 2.1 超級管理員的使用案例
- 登入超級後台管理系統
- 新增/編輯/停用租戶（店家）
- 查看租戶列表與使用狀況
- 設定全局功能參數（例如，打卡範圍、公休日）
- 管理推薦註冊獎勵規則
- 上架與排序廣告版位
- 查看營運總覽報表（跨租戶匯總）
- 查看與匯出各種操作日誌
- 設定系統公告（全平台性）
- 收到安全告警通知（如異常登入、過高流量）

---

### 2.2 租戶管理員（店長）的使用案例
- 登入租戶後台
- 查看每日/每月營收報表
- 管理分店菜單（新增、停售、設定價格）
- 指派員工與設定員工職位與權限
- 排班與調班管理
- 薪資獎金審核與修正
- 啟用/停用促銷活動（如生日優惠券）
- 發布門市內公告給員工
- 處理銷售異常或取消單
- 審核員工請假申請
- 審核補打卡申請
- 查看顧客評價記錄
- 自訂取餐叫號規則與螢幕顯示設定

---

### 2.3 分店員工（夥伴）的使用案例
- 使用LINE登入或員工帳號登入系統
- 打卡上下班（GPS定位）
- 查看排班表
- 接單、點餐、劃單、出單、取消訂單（需授權）
- 處理訂單付款（現金、LINE Pay）
- 填寫月度盤點表（庫存數量）
- 提交叫貨單（內部叫貨申請）
- 提交請假申請
- 申請補打卡
- 查看個人獎金累計、出勤紀錄
- 完成訓練課程與小考（知識庫功能）

---

### 2.4 顧客的使用案例
- 進入線上訂餐頁面
- 瀏覽菜單，選擇商品加入購物車
- 自訂商品選項（加料、去冰、加辣等）
- 選擇取餐時間與方式（外帶/內用）
- 完成付款（現金現場付款、或LINE Pay線上付款）
- 查看訂單進度（製作中、完成）
- 取餐通知（顯示取餐號碼或LINE提醒）
- 接收訂單完成後的評價問卷邀請
- 填寫評價（星等+文字）

---

# ?? 使用者角色 × 功能權限矩陣（Summary）

| 功能/角色 | 超級管理員 | 租戶管理員 | 分店員工 | 顧客 |
|:---|:---:|:---:|:---:|:---:|
| 登入系統 | ? | ? | ? | ?（顧客端線上點餐） |
| 打卡上下班 | ? | ? | ? | ? |
| 點餐接單 | ? | ? | ? | ? |
| 排班管理 | ? | ? | 查看 | ? |
| 菜單管理 | ? | ? | ? | 查看 |
| 訂單管理 | ? | ? | ? | 查看 |
| 銷售/薪資報表 | ?（匯總） | ?（本店） | 查看個人 | ? |
| 顧客評價管理 | ? | ? | 查看個人 | 填寫 |
| 庫存管理 | ? | ? | 盤點/叫貨 | ? |
| 公告發布 | ?（全平台） | ?（分店內） | 查看 | ? |
| 推薦/廣告管理 | ? | ? | ? | ? |

---



# ?? 核心功能性需求補齊（以功能模組為單位）

---

## 3.1 員工打卡功能（GPS 定位打卡）

**功能描述**：
- 員工必須於排班時段開始前打「上班卡」，結束後打「下班卡」。
- 打卡時必須在分店設定的地理圍欄（Geo-fence）內，否則無法打卡。

**功能流程**：
1. 員工開啟員工端PWA → 按下【打卡】。
2. 系統取得使用者即時定位座標。
3. 驗證座標是否在允許範圍內（半徑設定值，如 50 公尺）。
    - **若在範圍內 → 顯示打卡成功畫面，紀錄時間與位置。**
    - **若不在範圍內 → 顯示錯誤：「未在可打卡範圍內」。**

**錯誤處理**：
- 定位失敗 → 提示「請開啟定位功能並重試」。
- 定位資料不完整 → 拒絕打卡並紀錄錯誤日誌。

**資料記錄**：
- 打卡類型（上班/下班）
- 打卡時間（timestamp）
- GPS座標（經緯度）
- 分店ID（StoreID）
- 員工ID（StaffID）
- 打卡結果狀態（成功/失敗）

---

## 3.2 線上點餐功能（顧客端）

**功能描述**：
- 顧客透過手機掃QR Code或直接連到線上訂餐網頁。
- 可以瀏覽菜單、下單、付款、追蹤訂單進度。

**功能流程**：
1. 顧客進入訂餐頁 → 瀏覽菜單。
2. 選擇餐點、選擇加料選項（如加起司/去冰/加辣）。
3. 加入購物車。
4. 結帳 → 選擇付款方式（現金、LINE Pay）。
5. 成功付款後，系統產生訂單並指定一組取餐號碼。

**錯誤處理**：
- 付款失敗 → 提示「付款失敗，請重試」。
- 菜單資料載入錯誤 → 顯示錯誤頁面並重試機制。
- 當餐點售完時，自動標記為「售完」不可點選。

**資料記錄**：
- 訂單編號（OrderID）
- 顧客ID（如果有登入）
- 餐點清單（Products）
- 金額（TotalPrice）
- 付款狀態（Pending / Paid）
- 訂單狀態（製作中 / 完成 / 已取消）
- 取餐號碼（PickupNumber）

---

## 3.3 排班管理模組

**功能描述**：
- 店長手動或系統自動排班。
- 員工可以查看自己的班表、申請請假或調班。

**功能流程**：
1. 店長登入後台 → 進入排班管理。
2. 選擇月份 → 指派每日班次與員工。
3. 發布班表 → 系統推播通知夥伴查看。
4. 員工可檢視自己的排班。
5. 請假申請 → 管理員審核。
6. 如有人請假，店長可重新指派或開放代班申請。

**錯誤處理**：
- 員工未完成排班確認 → 提醒並鎖定打卡功能。
- 請假超過禁休日 → 系統自動提醒「今日禁休」並需主管特別核可。

**資料記錄**：
- 班表（Schedule）
- 員工ID（StaffID）
- 排班日期
- 時段（開始/結束時間）
- 請假記錄（LeaveRequests）
- 代班記錄（SubstitutionRequests）

---

## 3.4 薪資與獎金結算系統

**功能描述**：
- 每月根據出勤紀錄、業績、獎金任務自動計算薪資。
- 店長可於後台審核並修正。

**功能流程**：
1. 每月月底，自動觸發薪資計算。
2. 根據員工職等、底薪、打卡紀錄、請假、銷售額等指標計算薪資。
3. 自動累積各類型獎金（銷售獎金、表現獎金、特殊活動獎金）。
4. 店長登入後台 → 薪資審核頁面 → 若需修正可編輯。
5. 確認發薪 → 系統鎖定該月薪資，員工可查看明細。

**錯誤處理**：
- 若資料不完整（如漏打卡） → 系統標記異常並警告需補登。

**資料記錄**：
- 員工ID（StaffID）
- 本月總出勤天數與小時數
- 獎金金額列表（SalesBonus, PerformanceBonus）
- 請假扣薪記錄
- 本月應領薪資（TotalPay）
- 核准與修改歷史紀錄（AuditLogs）

## 3.5 通知服務模組

通知服務模組負責處理系統中各類事件的即時通知，包括訂單狀態變更、股權分配、利潤分配及系統重要公告等。該模組作為一個獨立的服務組件，位於 `functions/src/notifications/` 目錄下，採用模組化設計以支持多種通知渠道和靈活的通知策略。

### 3.5.1 核心架構

通知服務採用事件驅動的架構，主要由以下核心組件構成：
- 通知事件處理器：接收並分類系統各部分觸發的通知事件
- 通知模板管理：維護不同類型通知的標準模板
- 通知發送策略：根據用戶偏好和通知優先級決定發送方式
- 多渠道發送引擎：統一管理各種通知渠道的發送邏輯

### 3.5.2 支持的通知渠道

目前通知服務已實現和計劃支持的渠道包括：
- Firebase Cloud Messaging (FCM)：已初步實現，用於應用內推送通知
- 電子郵件 (Email)：計劃中，將用於重要通知和週期性報告
- 簡訊 (SMS)：計劃中，將用於高優先級通知及驗證

### 3.5.3 用戶通知偏好

通知服務與用戶的通知偏好設定緊密整合，允許用戶針對不同類型的通知設置偏好的接收渠道和頻率。系統會根據這些偏好設定，結合通知的重要性和緊急程度，智能選擇最適合的通知方式。

關於通知服務模組更詳細的設計規格、數據模型、API定義以及各通知渠道的實現細節，請參閱補充文檔《通知服務設計規格.txt》。






---

# ?? 非功能性需求完整規格

---

## 4.1 效能需求（Performance Requirements）

| 項目                           | 具體標準                                                         |
|--------------------------------|------------------------------------------------------------------|
| 頁面載入時間                   | 首頁與員工打卡畫面在正常4G網路環境下，首次載入小於3秒               |
| 同時使用者數（員工端）           | 支援每店同時30人操作（點餐、打卡、查詢排班）而不卡頓                  |
| 同時使用者數（顧客端）           | 支援每家店至少同時500筆線上訂單查詢或下單（PWA模式）                 |
| 後端API回應時間                 | 一般操作API（非批次作業）平均回應小於 500ms                        |
| 雲端列印系統（出單）             | 點單到列印的延遲需小於5秒                                          |
| 排班計算/薪資批次處理時間        | 1000人內薪資批次計算完成時間小於10分鐘                               |
| 離線容錯                        | PWA頁面需支援短期無網（5分鐘內）不影響點餐或打卡，恢復網路後自動同步   |

---

## 4.2 安全性需求（Security Requirements）

| 項目                           | 具體標準                                                         |
|--------------------------------|------------------------------------------------------------------|
| 身分驗證（Authentication）      | - 員工端使用LINE Login / Email-Password <br> - 顧客端可匿名或LINE Login |
| 角色與權限控管（Authorization） | - 員工端實施細緻權限控管（6層級角色），強制每個API驗證角色/店鋪         |
| 傳輸安全（Data in Transit）     | - 全站強制HTTPS <br> - 外部API整合必須支援TLS 1.2或更高             |
| 資料儲存安全（Data at Rest）    | - Firebase Firestore保護 <br> - 機敏欄位（如付款紀錄）AES-256加密   |
| 系統日誌記錄（Audit Logging）   | - 管理端所有重大操作（如薪資修改、權限更改）需記錄操作人員、時間與IP    |
| 防止暴力攻擊（Brute Force Protection） | - 限制登入錯誤次數，超過3次需冷卻3分鐘                                 |
| App Check                     | - 開啟Firebase App Check驗證來源流量防止濫用                         |
| DDoS防護                      | - HTTP Functions加裝頻率限制與Cloud Armor防護層（可選）                |

---

## 4.3 易用性需求（Usability Requirements）

| 項目                           | 具體標準                                                         |
|--------------------------------|------------------------------------------------------------------|
| 初次學習成本                   | 員工端（打卡、排班、點餐）需可在5分鐘內無指導完成基本操作               |
| 導航邏輯與介面                  | - 顯示清楚的返回鍵/功能鍵，不可出現操作死路                           |
| 無障礙（Accessibility）         | - 符合WCAG 2.1 AA級要求（如色彩對比、標籤標記、鍵盤操作支援）           |
| 錯誤提示                       | - 必須在使用者操作錯誤時清楚提示錯誤原因及建議行動                     |
| 多語系支援（未來擴充）           | - 前端設計需預留i18n擴展結構                                          |

---

## 4.4 可擴展性需求（Scalability Requirements）

| 項目                           | 具體標準                                                         |
|--------------------------------|------------------------------------------------------------------|
| 機房區域                       | 初期部署於Firebase asia-east1，後期擴展需能快速複製至asia-northeast1  |
| 資料庫擴展                     | 支援分Collection儲存多租戶資料，1萬店鋪資料需能線性擴展                |
| 功能模組化                     | 每個模組（如打卡、點餐、薪資）需能獨立升級或替換，避免影響其他功能       |
| 批次與排程作業                 | 使用Pub/Sub + Cloud Tasks組合，確保大規模作業可分散處理                |

---

? 以上把效能、安全性、易用性、可擴展性的非功能性標準**完整補齊**了，且全部是**具體可衡量的標準**，能直接進入系統設計與開發。

---

# ?? 目標使用者與使用案例定義

---

## 5.1 使用者角色清單與權限定義（完整版）

| 角色         | 說明                               | 主要權限與限制 |
|-------------|----------------------------------|----------------|
| 超級管理員（Super Admin） | SaaS平台最高管理層，管理所有租戶、廣告、推薦、平台設定 | - 查看/管理所有租戶資料 <br> - 設定平台廣告、推薦條件 <br> - 審核租戶資料/封鎖帳號 <br> - 查看平台總體統計與日誌 |
| 租戶擁有者（Tenant Owner） | 店家負責人，擁有店鋪所有操作與管理權限           | - 管理分店設定與菜單 <br> - 管理員工、權限與薪資設定 <br> - 檢視/修改訂單、庫存、報表 <br> - 審核顧客評價與推廣活動設定 |
| 分店管理員（Store Manager） | 單一分店日常營運負責人                     | - 查看/管理本店員工排班、打卡、銷售資料 <br> - 出單、叫貨、盤點作業管理 <br> - 執行部分獎金/薪資初步審核 |
| 員工（Staff） | 門市員工，負責現場作業                     | - 點餐、打卡、查看班表與薪資明細 <br> - 出單作業、銷售回報 |
| 顧客（Customer） | 外部使用者，透過PWA訂餐、會員活動             | - 查詢/下單/查看取餐號碼 <br> - 管理個人會員資料 <br> - 收到訂單完成評價邀請 |

---

## 5.2 各角色主要互動流程（核心Use Case）

### (1) 超級管理員主要流程

- 登入管理平台
- 查看租戶列表、審核新租戶申請
- 設定平台廣告版位與推薦活動規則
- 監控全平台營運數據（例如：註冊量、訂單量、廣告效益）
- 查看操作日誌、審核背景任務執行情況

---

### (2) 租戶擁有者主要流程

- 首次登入註冊租戶資料 ? 上傳品牌Logo與店家基本資料
- 建立菜單與產品分類
- 設定分店資訊（位置、營業時間、外送範圍）
- 招募員工 ? 審核LINE登入申請 ? 指派職位與分店
- 配置會員優惠活動與自動推播（例如：生日優惠、推薦好友）
- 查看銷售/庫存/薪資報表
- 審核分店的請假、補打卡、叫貨申請

---

### (3) 分店管理員主要流程

- 查看當日值班表與出勤狀態
- 開啟營業 ? 處理現場點餐、出單
- 查看/管理當日訂單狀態（內用/外帶/外送）
- 每日關店 ? 提交銷售回報 ? 匯總出單數據
- 發送臨時公告（如：備料異常通知）

---

### (4) 員工主要流程

- LINE快速登入系統
- 進行GPS打卡上下班
- 檢視個人班表、申請請假或調班
- 處理顧客點餐與付款（內用/外帶/外送）
- 查看個人累積獎金與薪資記錄

---

### (5) 顧客主要流程

- 開啟PWA ? 快速瀏覽菜單
- 點選產品 ? 加入購物車 ? 下單（付款選擇：到店付款或線上付款）
- 取得訂單號碼 ? 線上查看製作進度
- 取餐完成 ? 接收LINE推播邀請 ? 填寫簡單顧客服務評價表單

---

# ?? 使用案例表（精簡範例版）

| 編號 | 使用者角色 | 目標                    | 系統互動流程簡述 |
|------|-----------|-------------------------|-----------------|
| UC01 | 員工       | 完成上下班打卡             | 開啟PWA ? 自動定位 ? 顯示「可打卡」按鈕 ? 確認打卡成功訊息 |
| UC02 | 員工       | 建立新訂單並出單          | 點選「新訂單」 ? 選擇品項 ? 備註 ? 確認 ? 出單列印 |
| UC03 | 租戶擁有者 | 招募與管理夥伴             | 發送LINE登入邀請 ? 員工連結帳號 ? 管理員審核與分派職位 |
| UC04 | 顧客       | 線上快速訂購雞排           | 掃描QR Code ? 選擇餐點 ? 加入購物車 ? 填資料 ? 下單付款 |
| UC05 | 分店管理員 | 查看本日銷售與排班情況       | 進入管理介面 ? 點選「今日報表」 ? 查看銷售、員工到班記錄 |
| UC06 | 超級管理員 | 設定全平台新會員推薦規則     | 進入超管後台 ? 編輯推薦設定 ? 儲存後生效所有新用戶 |

---


---

## 6.1 技術棧 (Technology Stack)

| 層級         | 技術選型                         | 說明                                 |
|-------------|---------------------------------|-------------------------------------|
| 前端 (PWA)  | HTML5 + CSS3 + JavaScript (ES2021) | 無特定框架，小型模組化開發結構 |
| 前端SDK    | Firebase JS SDK v9.x Compat版       | 使用 Firebase Hosting, Auth, Firestore, FCM |
| 第三方登入  | LINE Login (LIFF SDK 2.21.4)        | 顧客與員工統一 LINE 授權登入 |
| 後端API    | Firebase Cloud Functions V2 (Node.js 20) | 主要負責商業邏輯、第三方整合、背景任務 |
| 後端SDK    | Firebase Admin SDK 13.x+             | 後端管理Firebase資源 |
| 資料庫       | Firestore (NoSQL Document DB)        | 高延展性、跨租戶隔離、支援手機快速存取 |
| 推播服務    | Firebase Cloud Messaging + LINE Notify + Telegram Bot API | 系統內通知與重要警示通知 |
| 金流整合    | LINE Pay API                         | 線上付款處理（選配） |
| 外送平台整合 | Uber Eats, Foodpanda API (Webhook同步模式) | 外送訂單整合進 POS 系統 |
| 伺服器地區  | asia-east1 (彰化) + asia-northeast1 (東京) | 降低延遲、保障穩定性 |
| 部署工具    | Firebase CLI 12.x 以上版 + GitHub Actions (未來建議) | CLI部署+CI/CD規劃 |
| 安全性加強  | Firebase AppCheck + Secret Manager     | 避免惡意請求與管理敏感金鑰 |
| 開發環境    | VSCode + Firebase Emulator Suite       | 本地開發與測試模擬器環境 |

---

## 6.2 初版資料模型（ERD 版本 1.0 草案）

?? 主核心表：

```
(租戶管理層)
Tenants { tenantId (PK), ownerUid, storeCount, planType, active }
Stores { storeId (PK), tenantId (FK), storeName, location, openHours, gpsFence, printerSettings }

(會員與顧客層)
Customers { customerId (PK), tenantId (FK), lineUid, displayName, phone, birthday, points, memberTags }
Orders { orderId (PK), tenantId (FK), storeId (FK), customerId (FK), items[], status, paymentInfo, createdAt }

(員工管理層)
Employees { employeeId (PK), tenantId (FK), lineUid, role, assignedStores[], salarySettings, active }
AttendanceRecords { recordId (PK), employeeId (FK), storeId (FK), clockInTime, clockOutTime, gpsLog, type }

(排班與薪資層)
Shifts { shiftId (PK), storeId (FK), startTime, endTime, assignedEmployees[] }
Payrolls { payrollId (PK), employeeId (FK), month, baseSalary, bonusAmount, deductions, totalSalary }

(營運與銷售層)
Menus { menuId (PK), tenantId (FK), categories[], items[] }
InventoryItems { inventoryId (PK), storeId (FK), itemName, stockQty, unit, lastUpdate }
SalesReports { reportId (PK), storeId (FK), salesAmount, orderCount, date }

(系統與安全層)
Settings { tenantId (PK), configs (JSON) }
AuditLogs { logId (PK), actionByUid, actionType, target, timestamp }
Notifications { notificationId (PK), tenantId (FK), type, payload, createdAt }

(廣告與推薦)
Ads { adId (PK), tenantId (FK), adType, placement, contentUrl, activePeriod }
Referrals { referralId (PK), code, inviterUid, inviteeUid, activatedAt }

```

>（?? 註：以上 ERD 是跨租戶，所有敏感資料必須附帶 `tenantId` 強制隔離。）

---

## 6.3 API 設計草案（重要端點範例）

| 功能區塊     | 方法 | 路徑                                | 簡述                   | 備註                 |
|------------|----|----------------------------------|----------------------|---------------------|
| 登入驗證     | POST | /auth/exchangeLineToken           | 交換 LINE Token 取得 Firebase Token | |
| 顧客下單     | POST | /orders/create                    | 顧客建立新訂單            | 前端 PWA 呼叫 |
| 顧客取餐進度查詢 | GET  | /orders/{orderId}/status           | 查詢訂單製作/完成狀態        | |
| 員工打卡     | POST | /attendance/clockIn               | GPS 打卡上班             | 需傳 GPS座標 |
| 員工打卡     | POST | /attendance/clockOut              | GPS 打卡下班             | 需傳 GPS座標 |
| 排班管理     | POST | /shifts/generate                   | 自動生成班表             | |
| 銷售回報     | POST | /salesReports/submit               | 當日銷售數據填報          | |
| 會員管理     | GET  | /customers/profile                 | 查詢會員資料             | |
| 會員領優惠券   | POST | /coupons/redeem                    | 領取會員活動優惠券          | |
| 叫號管理     | GET  | /orders/{storeId}/currentQueue     | 查詢目前取餐排隊列表        | |
| 廣告拉取     | GET  | /ads/fetch                         | 拉取廣告資料（顧客端/員工端）   | |
| 推薦機制     | POST | /referrals/redeem                  | 兌換推薦獎勵             | |

? 全部走 HTTPS endpoint、Firebase Auth 驗證、後端強制檢查 tenantId + 權限等級。

---

# ?? 重點補充

- 所有 API 都會內建：**權限驗證 ? TenantID 驗證 ? 參數驗證 ? 具名回傳錯誤**。
- API 錯誤回傳格式統一，例：

```json
{
  "success": false,
  "errorCode": "ERR_PERMISSION_DENIED",
  "message": "您沒有權限執行此操作。"
}
```

- 各模組初版 Firestore 索引 (`firestore.indexes.json`) 和 安全規則 (`firestore.rules`) 會一併規劃。

---


---

### ? Tenants（租戶資訊表）

| 欄位名         | 型態        | 必填 | 驗證規則                                | 說明 |
|---------------|------------|-----|----------------------------------------|-----|
| tenantId      | string     | 是   | UUID格式                               | 唯一租戶識別碼 |
| ownerUid      | string     | 是   | Firebase UID格式                       | 擁有者身份 |
| storeCount    | number     | 是   | >=0                                    | 門市數量 |
| planType      | string     | 是   | enum: ['free', 'basic', 'pro', 'enterprise'] | 使用方案類型 |
| active        | boolean    | 是   | true/false                             | 租戶啟用狀態 |

---

### ? Stores（門市資料表）

| 欄位名           | 型態        | 必填 | 驗證規則                                    | 說明 |
|-----------------|------------|-----|------------------------------------------|-----|
| storeId         | string     | 是   | UUID格式                                 | 唯一門市識別碼 |
| tenantId        | string     | 是   | UUID格式                                 | 所屬租戶 |
| storeName       | string     | 是   | 1~50字                                   | 門市名稱 |
| location        | map        | 是   | 包含 address(string), lat(number), lng(number) | 門市地址與地理位置 |
| openHours       | array      | 否   | 陣列內每個元素需有 start(string), end(string) (格式 'HH:mm') | 營業時間 |
| gpsFence        | map        | 否   | 半徑範圍半徑（meter, number）與中心座標 | 打卡地理圍欄 |
| printerSettings | map        | 否   | API URL(string), API Key(string)         | 雲端印表機設定 |
| createdAt       | timestamp  | 是   | Firestore Timestamp格式                  | 創建時間 |
| updatedAt       | timestamp  | 是   | Firestore Timestamp格式                  | 更新時間 |

---

### ? Customers（顧客資料表）

| 欄位名        | 型態        | 必填 | 驗證規則                                | 說明 |
|--------------|------------|-----|----------------------------------------|-----|
| customerId   | string     | 是   | UUID格式                               | 顧客ID |
| tenantId     | string     | 是   | UUID格式                               | 所屬租戶 |
| lineUid      | string     | 是   | LINE UserID格式                        | 綁定LINE帳號 |
| displayName  | string     | 否   | 最多50字                               | 顧客名稱 |
| phone        | string     | 否   | 正規表示式: 台灣手機格式 ^09\d{8}$        | 手機號碼 |
| birthday     | string     | 否   | 格式: 'YYYY-MM-DD'                      | 生日 |
| points       | number     | 是   | >=0                                    | 累積點數 |
| memberTags   | array      | 否   | 陣列內為string，長度限制15              | 自訂標籤 |
| createdAt    | timestamp  | 是   | Firestore Timestamp格式                  | 創建時間 |
| updatedAt    | timestamp  | 是   | Firestore Timestamp格式                  | 更新時間 |

---

【?? 每一個表格我會這樣全欄位規範！】

（因為篇幅很多，我會快速推進，「全部主資料表欄位」，一份超完整標準資料字典！）

---

## 7.2 資料驗證規則補充（Validation）

1. **ID欄位皆強制UUID格式或Firebase UID格式驗證。**  
2. **字串長度限制強制加強（UI端也提示，後端也拒絕）。**  
3. **日期欄位全部標準化 ISO 格式 ('YYYY-MM-DD' or 'YYYY-MM-DDTHH:mm:ssZ')。**  
4. **金額欄位不得為負數，點數欄位不得為負數。**  
5. **使用Enum定義選項固定範圍（例如角色、狀態、付款方式等）。**  
6. **每個集合（Collection）新增必備 createdAt / updatedAt timestamp。**  

---

## 7.3 資料流圖（DFD）初版

以下是主要資料流動關係（Data Flow Diagram - 高階版）：

```
【顧客操作流程】
顧客PWA -> 註冊或登入 (LINE) -> Customers
顧客PWA -> 下訂單 -> Orders
顧客PWA -> 查詢取餐進度 -> Orders.Status
顧客PWA -> 評價餐點 -> Notifications

【員工操作流程】
員工PWA -> 打卡 -> AttendanceRecords
員工PWA -> 點餐作業 -> Orders
員工PWA -> 盤點/叫貨 -> InventoryItems
員工PWA -> 提交銷售報表 -> SalesReports

【後台管理流程】
店長後台 -> 員工管理 -> Employees
店長後台 -> 班表排班 -> Shifts
店長後台 -> 薪資核算 -> Payrolls
店長後台 -> 廣告/優惠設定 -> Ads

【系統自動背景任務】
Firebase Scheduler -> 排程 Bonus 任務評估 -> Payrolls
Firebase Scheduler -> 定時發送生日優惠 -> Customers

【外部系統互動】
LINE平台 -> LINE Login 認證
LINE Pay -> 支付回傳 -> Orders.PaymentInfo
Uber/Foodpanda -> 訂單 Webhook -> Orders
```

---

# ? 小結

現在，我們已經完成：
- 各資料表的欄位設計
- 資料驗證規範
- 資料流動關係 DFD 初版

這代表：

? 資料庫可以建置。  
? API開發有清楚的資料結構依據。  
? 前端可以知道資料要怎麼送/怎麼讀。  
? 測試與驗收可以有明確依據。  

---


---

# ?? 資料表完整設計（含型態 + 格式範例）

## 1. Tenants（租戶資訊）

| 欄位名         | 型態        | 必填 | 格式/限制                          | 範例                   | 說明 |
|---------------|------------|-----|-----------------------------------|------------------------|-----|
| tenantId      | string     | 是   | UUID格式（小寫）                    | `"c25f1b56-8e88-4d4c-97f4-8c5d5ee91e55"` | 唯一租戶 |
| ownerUid      | string     | 是   | Firebase UID 格式                  | `"A4sPqUzoaAd9MZ6hwfPYJd4cRCw1"` | 擁有者身份 |
| storeCount    | number     | 是   | >= 0 正整數                        | `2`                    | 門市數 |
| planType      | string     | 是   | ENUM: `'free'|'basic'|'pro'|'enterprise'` | `'basic'`               | 租戶使用方案 |
| active        | boolean    | 是   | true/false                        | `true`                  | 啟用狀態 |
| createdAt     | timestamp  | 是   | Firestore Timestamp格式            | `Timestamp.now()`       | 創建時間 |
| updatedAt     | timestamp  | 是   | Firestore Timestamp格式            | `Timestamp.now()`       | 更新時間 |

---

## 2. Stores（門市資訊）

| 欄位名           | 型態        | 必填 | 格式/限制                          | 範例                   | 說明 |
|-----------------|------------|-----|-----------------------------------|------------------------|-----|
| storeId         | string     | 是   | UUID格式                          | `"5f3e2f74-89bc-4a4b-a2f2-ef930b03ff3e"` | 唯一門市 |
| tenantId        | string     | 是   | UUID                              | `"c25f1b56-8e88-4d4c-97f4-8c5d5ee91e55"` | 租戶關聯 |
| storeName       | string     | 是   | 1-50字                            | `"內壢忠孝店"`             | 門市名稱 |
| location        | map        | 是   | address(string), lat/lng(number)   | `{ address:"桃園市中壢區忠孝路", lat:24.956, lng:121.225 }` | 地理資訊 |
| openHours       | array      | 否   | 陣列，start,end 格式'HH:mm'         | `[ {start:"10:00", end:"22:00"} ]` | 營業時間 |
| gpsFence        | map        | 否   | center(lat, lng), radius(m)        | `{ lat:24.956, lng:121.225, radius:100 }` | 打卡範圍 |
| printerSettings | map        | 否   | apiUrl(string), apiKey(string)    | `{ apiUrl: "https://printer.xxx.com/print", apiKey: "abc123" }` | 出單設定 |
| createdAt       | timestamp  | 是   | Firestore Timestamp               | `Timestamp.now()`       | 創建時間 |
| updatedAt       | timestamp  | 是   | Firestore Timestamp               | `Timestamp.now()`       | 更新時間 |

---

## 3. Employees（員工資料）

| 欄位名           | 型態        | 必填 | 格式/限制                          | 範例                   | 說明 |
|-----------------|------------|-----|-----------------------------------|------------------------|-----|
| employeeId      | string     | 是   | UUID                              | `"adf4932f-4d3e-4b8f-b9ff-d9c2467f7be4"` | 員工ID |
| tenantId        | string     | 是   | UUID                              | `"c25f1b56-8e88-4d4c-97f4-8c5d5ee91e55"` | 租戶關聯 |
| storeId         | string     | 是   | UUID                              | `"5f3e2f74-89bc-4a4b-a2f2-ef930b03ff3e"` | 所屬門市 |
| name            | string     | 是   | 1-50字                            | `"王小明"`                | 姓名 |
| phone           | string     | 否   | 台灣手機號格式 ^09\d{8}$            | `"0912345678"`           | 手機 |
| position        | string     | 是   | ENUM: 'intern', 'staff', 'leader', 'manager' | `'leader'`             | 職位 |
| role            | string     | 是   | ENUM: 'admin', 'staff'             | `'staff'`                | 系統登入角色 |
| lineUid         | string     | 否   | LINE UID格式                      | `"U9d33b7edbf18f5e6d904e36521d3a1a2"` | 綁定LINE |
| createdAt       | timestamp  | 是   | Firestore Timestamp               | `Timestamp.now()`       | 創建時間 |
| updatedAt       | timestamp  | 是   | Firestore Timestamp               | `Timestamp.now()`       | 更新時間 |

---

# ?? 員工端畫面 JSON Schema

(這是前端員工 PWA 會用到的資料格式)

```json
{
  "employeeId": "string (UUID)",
  "name": "string",
  "position": "string (intern | staff | leader | manager)",
  "storeId": "string (UUID)",
  "storeName": "string",
  "todayShift": {
    "start": "string (ISO時間)",
    "end": "string (ISO時間)",
    "roleToday": "string (如 cashier/kitchen/shiftLead)"
  },
  "todayTasks": [
    {
      "taskId": "string",
      "title": "string",
      "status": "pending | completed",
      "dueTime": "string (ISO時間)"
    }
  ],
  "notices": [
    {
      "noticeId": "string",
      "title": "string",
      "content": "string",
      "createdAt": "timestamp"
         }
       ]
     }
     ```

---

# ?? 管理員後台頁面 JSON Schema

(這是管理員用來看整間店狀態的格式)

```json
{
  "storeId": "string (UUID)",
  "storeName": "string",
  "summary": {
    "todaySales": "number",
    "todayOrders": "number",
    "employeeOnline": "number",
    "pendingOrders": "number"
  },
  "employees": [
    {
      "employeeId": "string",
      "name": "string",
      "position": "string (intern | staff | leader | manager)",
      "todayClockIn": "timestamp",
      "todayClockOut": "timestamp",
      "status": "working | offDuty | late | absent"
    }
  ],
  "inventory": [
    {
      "itemId": "string",
      "name": "string",
      "stock": "number",
      "lowStockWarning": "boolean"
    }
  ],
  "pendingTasks": [
    {
      "taskId": "string",
      "title": "string",
      "assignedTo": "string (employee name)",
      "dueDate": "timestamp"
    }
  ]
}
```

---






很好，我們馬上來進行  
【外部 API 整合設計補完】  
我會針對你的系統需要整合的這些服務，**每個都幫你補到非常完整、可開發狀態**：

---
# ?? 外部整合 API 設計總覽

| 整合系統 | 主要用途 | 說明 |
|:---------|:--------|:----|
| LINE Pay API | 線上支付 | 支援點餐結帳付款 |
| Uber Eats API | 外送訂單同步 | 接收訂單、自動派單 |
| Foodpanda API | 外送訂單同步 | 接收訂單、自動派單 |
| LINE Login + LIFF SDK | 顧客/員工登入 | 單點登入、會員管理 |
| LINE Notify API | 顧客通知 | 出單、叫號、活動推播 |
| Telegram Bot API | 內部通知 | 管理員通知（警報、警示） |

---

# 1. 【LINE Pay API 整合】

### 主要用途：
- 顧客線上點餐結帳
- 店員現場掃碼收款

### 流程設計（建議）

1. 顧客選擇付款 → 呼叫後端建立交易
2. 導向 LINE Pay 結帳頁
3. 完成付款 → 回調驗證 → 訂單完成

---

### LINE Pay API端點設計：

**1. 建立付款請求**
- `POST /api/payment/linepay/request`
     ```json
{
  "amount": 200,
  "currency": "TWD",
  "orderId": "order_20240601_001",
  "packages": [{
    "id": "package1",
    "amount": 200,
    "name": "脆皮雞排套餐",
    "products": [{
      "name": "脆皮雞排",
      "quantity": 1,
      "price": 100
    }, {
      "name": "飲料",
      "quantity": 1,
      "price": 100
    }]
  }],
  "redirectUrls": {
    "confirmUrl": "https://domain.com/payment/confirm",
    "cancelUrl": "https://domain.com/payment/cancel"
  }
}
```

**成功回應**
```json
{
  "paymentUrl": "https://payment.line.me/..."
}
```

---

**2. 確認付款**
- `POST /api/payment/linepay/confirm`
```json
{
  "transactionId": "202406010001",
  "orderId": "order_20240601_001",
  "amount": 200,
  "currency": "TWD"
}
```

成功後更新訂單狀態。

---

# 2. 【Uber Eats API 整合】

### 主要用途：
- 自動同步平台訂單
- 接收、接單、更新狀態

---

### 端點設計：

**1. 接收Uber訂單Webhook**
- `POST /api/webhook/ubereats/order`
```json
{
  "orderId": "ubereats_20240601_001",
  "storeId": "內壢忠孝店",
  "items": [
    { "name": "脆皮雞排", "quantity": 2 }
  ],
  "totalAmount": 320,
  "customerNote": "少油"
}
```

---

**2. 更新外送訂單狀態**
- `POST /api/ubereats/update`
```json
{
  "orderId": "ubereats_20240601_001",
  "status": "ready_for_pickup"  // 或 'picked_up', 'cancelled'
}
```

---

# 3. 【Foodpanda API 整合】

與 Uber Eats 類似，只是 URL / 欄位略微不同。

### 端點設計：

**1. 接收Foodpanda訂單Webhook**
- `POST /api/webhook/foodpanda/order`
```json
{
  "orderId": "fp_20240601_001",
  "storeName": "內壢忠孝店",
  "totalPrice": 280,
  "items": [
    { "itemName": "脆皮雞排", "qty": 1 }
  ],
  "remarks": "去骨"
}
```

---

**2. 更新訂單狀態**
- `POST /api/foodpanda/update`
```json
{
  "orderId": "fp_20240601_001",
  "status": "picked_up"  // 或 'ready', 'cancelled'
}
```

---

# 4. 【LINE Login + LIFF SDK整合】

### 用途：
- 顧客登入會員中心
- 員工登入員工系統

---

**登入流程設計**
1. 前端用 LIFF 初始化 → 取得 `accessToken`
2. 傳給後端換 Firebase custom token
3. 前端用 custom token 登入 Firebase

---

**API端點設計：**

**1. LINE換Firebase登入**
- `POST /api/auth/line`
```json
{
  "accessToken": "LINE的accessToken",
  "idToken": "LINE的idToken"
}
```
回傳 Firebase custom token。

---

# 5. 【LINE Notify API整合】

### 用途：
- 顧客取餐通知
- 活動推播

---

**發送通知**
- `POST /api/notify/line`
```json
{
  "userLineToken": "xxxxx",
  "message": "您的雞排已完成，請至1號窗口取餐！"
}
```

---

# 6. 【Telegram Bot API整合】

### 用途：
- 內部管理員通知
- 訂單異常/負評警報/營業額達標通知

---

**發送Telegram訊息**
- `POST /api/notify/telegram`
```json
{
  "chatId": "管理員的chat_id",
  "message": "今日內壢忠孝店營業額已達成！"
}
```

---

# ?總結

這樣子你的外部整合 API：
- ?? 端點 (Route) 都設計好了
- ?? 請求與回應格式都有了
- ?? 可以直接安排後端工程師開始實作
- ?? 也能同時前端搭配串接測試

---


很好，我們直接進入  
**「吃雞排找不早 POS 系統 ? 內部後端 API 補完計畫」**  
目標是做出：

- 每個功能對應的 **API端點**
- **請求格式（Request JSON）**
- **回應格式（Response JSON）**
- **錯誤處理範例**

我會用最清楚又開發能直接用的格式整理，依功能分類開始！

---

# ?? 員工管理（夥伴系統）

## 1. 員工登入（Firebase Custom Token）

- `POST /api/auth/employee-login`
```json
{
  "lineAccessToken": "string"
}
```

**成功回應**
```json
{
  "firebaseCustomToken": "string"
}
```

---

## 2. 打卡（上班/下班）

- `POST /api/attendance/clock`
```json
{
  "employeeId": "emp_12345",
  "storeId": "忠孝",
  "type": "clock_in", // or "clock_out"
  "location": {
    "lat": 24.9748,
    "lng": 121.2556
  }
}
```

**成功回應**
```json
{
  "status": "success",
  "message": "打卡成功"
}
```

---

## 3. 查詢個人薪資與獎金明細

- `GET /api/payroll/employee/{employeeId}`
```json
// URL 路徑帶 employeeId
```

**成功回應**
```json
{
  "employeeId": "emp_12345",
  "month": "2024-06",
  "baseSalary": 40000,
  "bonus": 3000,
  "totalPay": 43000,
  "details": [
    { "item": "基礎底薪", "amount": 40000 },
    { "item": "銷售獎金", "amount": 3000 }
  ]
}
```

---

# ?? 線上訂餐 / POS 流程

## 4. 建立新訂單（顧客端或員工端）

- `POST /api/order/create`
```json
{
  "customerId": "cus_98765", // 顧客ID，可為 null（現場客）
  "storeId": "忠孝",
  "orderSource": "pos" , // or "online"
  "items": [
    {
      "menuId": "menu_001",
      "name": "脆皮雞排",
      "quantity": 2,
      "price": 80
    }
  ],
  "note": "少鹽",
  "paymentMethod": "cash", // or "linepay"
  "totalAmount": 160
}
```

**成功回應**
```json
{
  "orderId": "order_20240601_001",
  "status": "pending"
}
```

---

## 5. 更新訂單狀態（製作中、完成、取消）

- `POST /api/order/update-status`
```json
{
  "orderId": "order_20240601_001",
  "status": "completed" // or "preparing", "cancelled"
}
```

**成功回應**
```json
{
  "status": "success",
  "message": "訂單狀態更新成功"
}
```

---

# ?? 取餐叫號 / 取餐通知

## 6. 叫號系統（前端叫號＋通知）

- `POST /api/pickup/call`
```json
{
  "orderId": "order_20240601_001",
  "queueNumber": "A015",
  "notifyLine": true
}
```

**成功回應**
```json
{
  "status": "success",
  "message": "叫號與通知已發送"
}
```

---

# ?? 店長與管理員專用後台功能

## 7. 管理端查詢營業額（每日）

- `GET /api/admin/sales/{storeId}/{date}`
```json
// URL path 帶 storeId 與 date (格式: YYYY-MM-DD)
```

**成功回應**
```json
{
  "storeId": "忠孝",
  "date": "2024-06-01",
  "totalSales": 28000,
  "totalOrders": 200
}
```

---

## 8. 營收手動登記（補單）

- `POST /api/admin/sales/manual-entry`
```json
{
  "storeId": "忠孝",
  "date": "2024-06-01",
  "amount": 500,
  "reason": "現金小額補單"
}
```

**成功回應**
```json
{
  "status": "success",
  "message": "營收補單成功"
}
```

---

# ?? 錯誤處理格式（全站統一）

所有API失敗時，統一回傳格式：

```json
{
  "status": "error",
  "errorCode": "E401",
  "message": "未授權的存取"
}
```
常見錯誤碼示例：
| 錯誤代碼 | 說明 |
|:---------|:-----|
| `E400` | 請求參數錯誤 |
| `E401` | 未授權存取 (未登入/權限不足) |
| `E404` | 找不到資源 |
| `E500` | 系統內部錯誤 |

---


很好！??  
我們現在馬上進入 **「資料表設計＋前後端頁面 JSON 結構標準化」**  
這樣開發團隊只要拿到這份就能直接開工，不用自己猜。

---
# ?? 1. Firestore 資料表設計

---

## ?? `employees` （員工資料表）

| 欄位 | 類型 | 說明 |
|:-----|:-----|:-----|
| `employeeId` | string | 自動生成的唯一ID（格式：emp_xxxx） |
| `name` | string | 員工姓名 |
| `phone` | string | 員工手機號碼 |
| `email` | string | 員工電子郵件（可選） |
| `storeId` | string | 所屬分店ID |
| `position` | string | 職位代號（如 manager, leader, staff） |
| `roleLevel` | number | 權限等級（數字越大權限越高） |
| `status` | string | 狀態（active / suspended / left） |
| `lineUserId` | string | 綁定的LINE User ID |
| `createdAt` | timestamp | 建立時間 |
| `updatedAt` | timestamp | 最後更新時間 |

---

## ?? `orders` （訂單資料表）

| 欄位 | 類型 | 說明 |
|:-----|:-----|:-----|
| `orderId` | string | 自動生成唯一ID（格式：order_yyyyMMdd_xxx） |
| `storeId` | string | 所屬分店ID |
| `customerId` | string | 顧客ID（或為null） |
| `orderSource` | string | 訂單來源（pos / online / uber / foodpanda） |
| `items` | array | 訂購品項清單（見下面） |
| `note` | string | 顧客備註 |
| `totalAmount` | number | 總金額 |
| `paymentMethod` | string | 付款方式（cash / linepay / credit） |
| `status` | string | 訂單狀態（pending / preparing / completed / cancelled） |
| `queueNumber` | string | 取餐號碼（可空白） |
| `createdAt` | timestamp | 建立時間 |
| `updatedAt` | timestamp | 最後更新時間 |

> `items` 內部格式：
```json
[
  {
    "menuId": "menu_001",
    "name": "脆皮雞排",
    "quantity": 2,
    "price": 80
  }
]
```

---

## ?? `sales` （日銷售紀錄表）

| 欄位 | 類型 | 說明 |
|:-----|:-----|:-----|
| `salesId` | string | 自動生成唯一ID（sales_yyyyMMdd_storeId） |
| `storeId` | string | 分店ID |
| `date` | string | 日期（格式：YYYY-MM-DD） |
| `totalSales` | number | 總銷售金額 |
| `totalOrders` | number | 總訂單數量 |
| `manualAdjustment` | number | 手動補單金額（可為0） |
| `createdAt` | timestamp | 建立時間 |
| `updatedAt` | timestamp | 最後更新時間 |

---

# ?? 2. 員工端頁面（夥伴APP / PWA） - JSON 結構

---

## ?? 員工登入後首頁

```json
{
  "employeeInfo": {
    "employeeId": "emp_12345",
    "name": "王小明",
    "position": "leader",
    "storeName": "忠孝店"
  },
  "todayStatus": {
    "isClockedIn": true,
    "lastClockTime": "2024-06-01T08:00:00Z"
  },
  "quickActions": [
    { "action": "clock", "label": "打卡" },
    { "action": "order", "label": "點餐" },
    { "action": "pickup", "label": "叫號" }
  ]
}
```

---

## ?? 打卡畫面

```json
{
  "locationRequired": true,
  "currentLocation": {
    "lat": 24.9748,
    "lng": 121.2556
  },
  "clockOptions": [
    { "type": "clock_in", "label": "上班打卡" },
    { "type": "clock_out", "label": "下班打卡" }
  ]
}
```

---

## ?? 新增訂單畫面（POS）

```json
{
  "menuList": [
    { "menuId": "menu_001", "name": "脆皮雞排", "price": 80 },
    { "menuId": "menu_002", "name": "甜不辣", "price": 50 }
  ],
  "orderCart": [],
  "customerInfo": {
    "customerId": null,
    "note": ""
  },
  "paymentOptions": ["cash", "linepay"]
}
```

---

# ?? 3. 管理員後台頁面 - JSON 結構

---

## ?? 店鋪營業概覽

```json
{
  "storeInfo": {
    "storeId": "忠孝",
    "name": "忠孝店"
  },
  "salesSummary": {
    "todaySales": 28000,
    "todayOrders": 200,
    "manualAdjustment": 500
  },
  "attendanceSummary": {
    "expectedEmployees": 5,
    "checkedInEmployees": 4
  }
}
```

---

## ?? 員工管理列表

```json
{
  "employees": [
    {
      "employeeId": "emp_12345",
      "name": "王小明",
      "position": "leader",
      "roleLevel": 2,
      "status": "active"
    },
    {
      "employeeId": "emp_67890",
      "name": "李小美",
      "position": "staff",
      "roleLevel": 1,
      "status": "active"
    }
  ]
}
```

---

## ?? 單日訂單列表

     ```json
{
  "orders": [
    {
      "orderId": "order_20240601_001",
      "queueNumber": "A015",
      "items": [
        { "name": "脆皮雞排", "quantity": 2 }
      ],
      "totalAmount": 160,
      "status": "completed",
      "paymentMethod": "cash",
      "createdAt": "2024-06-01T08:10:00Z"
    }
  ]
}
```





好！??來了，下面會 **超完整補齊**：
- 每個主要 API / 功能點的**錯誤範例與錯誤碼設計**
- 每張資料表的**欄位驗證規則**
- Firestore 資料結構的**索引設計（indexes.json）**

---

# ?? 1. API錯誤範例（統一錯誤設計）

---

## ?? 通用錯誤格式

```json
{
  "error": {
    "code": "ERR_CODE",
    "message": "錯誤說明文字"
  }
}
```

---

## ?? 常見錯誤碼

| 錯誤碼 | 說明 | HTTP Status |
|:------|:-----|:------------|
| `INVALID_ARGUMENT` | 請求參數不正確 | 400 |
| `UNAUTHORIZED` | 沒有權限存取 | 401 |
| `NOT_FOUND` | 資料不存在 | 404 |
| `ALREADY_EXISTS` | 資料已存在（如重複員工ID） | 409 |
| `INTERNAL_ERROR` | 伺服器內部錯誤 | 500 |

---

## ?? API 錯誤範例

#### 員工登入失敗（找不到綁定LINE帳號）
```json
{
  "error": {
    "code": "NOT_FOUND",
    "message": "找不到綁定的員工帳號"
  }
}

---

### ?? 員工端 JSON 資料範例
```json
{
  "employee_id": "emp001",
  "name": "黃金雞",
  "store_id": "龍崗",
  "role": "正式員工",
  "shift_today": {
    "date": "2025-04-29",
    "shift_start": "15:00",
    "shift_end": "22:00"
  },
  "sales_today": 5280,
  "bonus_type": "平日獎金",
  "bonus_preview": 160
}
```

---

### ????? 管理員端 JSON 資料範例
```json
{
  "manager_id": "mgr001",
  "store_id": "忠孝",
  "daily_report_summary": {
    "date": "2025-04-29",
    "total_sales": 12200,
    "reported_by": "emp123",
    "bonus_estimations": {
      "平日獎金": 360,
      "加班獎金": 720,
      "過年獎金": 2400,
      "其他獎金": 100
    }
  },
  "shifts_pending": 2,
  "leave_requests_pending": 1
}
```

---

接下來是否要補 `employees`、`leave_requests`、`bonus_tasks` 等其他資料表的規格與欄位驗證？




這是依照目前系統需求所補齊的欄位驗證規則與錯誤範例表格，涵蓋 `employees`、`leave_requests`、`bonus_tasks` 等核心表格，並針對每個欄位列出類型、驗證規則、是否必填及可能的錯誤案例。

接下來我可以為你補上：
1. Firestore 索引設計（`firestore.indexes.json`）
2. 員工端與管理員端 JSON 示意資料（樣本資料）
3. 若有需要，也可以設計 Firestore 規則（`firestore.rules`）草案

需要我繼續補哪一項？

【Firestore 資料表欄位驗證規則與錯誤範例清單】

1. stores（分店資料）
- name（string, required）: 店名，不得為空；例外：" "（錯誤：空白）
- latitude（number, required）: 緯度；錯誤："abc"（非數字）
- longitude（number, required）: 經度；錯誤："xyz"（非數字）
- radius（number, default=100）: 打卡範圍（公尺）
- operatingHours（array of time ranges）: 錯誤：未依格式 [{start,end}]

2. users（夥伴帳戶）
- name（string, required）: 錯誤：null, ""
- role（enum: ["實習", "正職", "組長", ...], required）: 錯誤："super"
- storeId（string, required）: 未指定分店會影響排班與薪資關聯
- status（enum: ["active", "suspended"], default="active"）

3. shifts（排班表）
- userId（string, required）: 錯誤：null，找不到對應使用者
- date（string, yyyy-mm-dd, required）: 錯誤："4/1/2025"
- timeSlot（enum: ["早班", "晚班", "全日"], required）
- status（enum: ["正常", "請假", "代班"], default="正常"）

4. clockRecords（打卡記錄）
- timestamp（timestamp, required）
- type（enum: ["上班", "下班"], required）: 錯誤："開工"
- storeId（string, required）
- userId（string, required）

5. payrolls（薪資資料）
- userId（string, required）
- month（string, yyyy-mm, required）
- baseSalary（number）
- bonusTotal（number）
- deduction（number）: 錯誤：-999（需為 >= 0）
- finalSalary（number, 自動計算）

6. bonusConfigs（獎金類型設定）
- type（enum, required）: 錯誤："特別獎金123"
- calculation（object）: 錯誤：未定義百分比或條件式
- active（boolean, default=true）

7. salesReports（日報表）
- storeId（string, required）
- date（string, yyyy-mm-dd, required）
- totalSales（number, required）
- paymentBreakdown（object, required）: 錯誤：缺少現金/LINE Pay欄位

8. inventoryItems（庫存項目）
- name（string, required）: 錯誤：空白
- stock（number, default=0）: 錯誤：負值
- unit（string, e.g., "包", "桶"）

9. leaveRequests（請假申請）
- userId（string, required）
- date（string, required）
- reason（string, required）
- status（enum: ["待審", "通過", "駁回"], default="待審"）

10. feedbacks（顧客評價）
- storeId（string, required）
- orderId（string）
- rating（integer: 1–5, required）: 錯誤：6
- comment（string, optional）

11. announcements（公告）
- title（string, required）: 錯誤：空白
- content（string, required）
- publishAt（timestamp, optional）






主要功能，逐一講解其邏輯：

**前端員工端功能**

1.  **身份驗證 (Authentication)**
    *   **目的**: 驗證員工身份，允許其存取系統。
    *   **前端 (`login.html` (假設), `js/auth.js`, `js/init.js`)**:
        *   提供登入介面（可能需要帳號/密碼或 Firebase Auth 提供的其他方式如 Google 登入）。
        *   `auth.js` 處理用戶輸入，調用 Firebase Authentication 進行驗證。
        *   驗證成功後，儲存用戶狀態 (可能是 `localStorage` 或 `sessionStorage`)，並觸發 `init.js` 或 `main.js` 加載主應用介面和用戶特定數據。
        *   處理登出邏輯，清除用戶狀態並重定向回登入頁面。
    *   **後端 (Firebase Authentication, `firestore.rules`)**:
        *   Firebase Authentication 服務處理實際的身份驗證。
        *   `firestore.rules` 可能會根據 `request.auth.uid` (已登入用戶的 ID) 來限制對特定數據的存取。

2.  **打卡 (Clock-in/out)**
    *   **目的**: 記錄員工實際的上下班時間。
    *   **前端 (`clockin.html`, `js/clockin-logic.js`)**:
        *   顯示打卡按鈕（上班/下班）。可能顯示目前狀態或今日打卡記錄。
        *   `clockin-logic.js` 處理按鈕點擊事件，記錄當前時間戳。
        *   可能包含地理位置驗證（如果需要）。
        *   將打卡記錄（員工 ID, 時間, 類型（上班/下班）, 可能的位置信息）發送到後端。
    *   **後端 (`functions/index.js` (可能), Firestore)**:
        *   接收前端發來的打卡數據。
        *   驗證數據有效性。
        *   將打卡記錄儲存到 Firestore 的特定集合中（例如 `attendanceRecords`），通常會包含員工 ID 和日期以便查詢。

3.  **請假 (Leave Request)**
    *   **目的**: 讓員工提交請假申請。
    *   **前端 (`leave.html`, `js/leave-logic.js`)**:
        *   提供表單讓員工選擇請假類型、起訖時間、輸入事由。
        *   `leave-logic.js` 驗證表單輸入，計算請假時數。
        *   顯示員工的請假餘額（可能從後端獲取）。
        *   將請假申請數據（員工 ID, 類型, 時間, 事由, 狀態: '待審核'）發送到後端。
        *   可能也包含顯示歷史假單及其狀態的功能。
    *   **後端 (`functions/index.js` (可能), Firestore)**:
        *   接收請假申請數據。
        *   驗證數據（例如時間是否衝突、餘額是否足夠）。
        *   將申請儲存到 Firestore 的 `leaveRequests` 集合中，狀態設為 '待審核'。
        *   可能觸發通知給相關的審核人員。

4.  **班表 (Schedule View)**
    *   **目的**: 讓員工查看自己的工作班表。
    *   **前端 (`schedule-view.html`, `js/schedule-view-logic.js`)**:
        *   向後端請求指定日期範圍（例如本週、本月）的個人班表。
        *   `schedule-view-logic.js` 接收班表數據，並以日曆或列表形式呈現。
        *   可能包含切換日期範圍的功能。
    *   **後端 (`functions/index.js` (可能), Firestore)**:
        *   接收前端的班表請求（包含員工 ID 和日期範圍）。
        *   從 Firestore 的 `schedules` 集合中查詢符合條件的班表記錄。
        *   將查詢結果返回給前端。

5.  **薪資 (Salary View)**
    *   **目的**: 讓員工查看自己的薪資明細。
    *   **前端 (`salary.html`, `salary-view.html`, `js/salary-view-logic.js`)**:
        *   向後端請求特定月份或週期的薪資單。
        *   `salary-view-logic.js` 接收薪資數據（可能包含底薪、津貼、獎金、扣款、實發金額等），並以清晰的格式展示。
        *   可能包含選擇歷史薪資單的功能。
    *   **後端 (`functions/index.js` (可能), Firestore)**:
        *   接收前端的薪資請求（包含員工 ID 和週期）。
        *   從 Firestore 的 `payrolls` 或 `salaryRecords` 集合中查詢對應的薪資記錄。
        *   基於權限（只能看自己的）返回薪資數據。

6.  **點餐 (Ordering)**
  *   **目的**: 讓員工可以線上點餐（可能是員工餐或外賣代訂）。
  *   **前端 (`order.html`, `js/order-logic.js`)**:
      *   顯示可點選的菜單（可能從後端獲取）。
      *   允許員工選擇餐點、數量，加入購物車。
      *   `order-logic.js` 計算總金額，處理下單邏輯。
      *   將訂單數據（員工 ID, 餐點項目, 數量, 金額, 送達時間/地點要求）發送到後端。
      *   可能包含查看歷史訂單的功能。
  *   **後端 (`functions/index.js` (可能), Firestore)**:
      *   接收訂單數據。
      *   驗證菜單項目和價格。
      *   將訂單儲存到 Firestore 的 `orders` 集合中。
      *   可能觸發通知給廚房或負責處理訂單的人員。
      *   可能與支付或員工帳戶扣款相關聯。

7.  **公告 (Announcements View)**
  *   **目的**: 讓員工查看公司發布的最新公告。
  *   **前端 (`announce.html`, `js/announce-logic.js`)**:
      *   向後端請求最新的或所有的公告列表。
      *   `announce-logic.js` 接收公告數據（標題, 內容, 發布日期, 發布者），並以列表或卡片形式展示。
      *   可能包含查看公告詳情的功能。
  *   **後端 (`functions/index.js` (可能), Firestore)**:
      *   接收公告請求。
      *   從 Firestore 的 `announcements` 集合中查詢公告數據。
      *   將結果返回給前端。

8.  **公投 (Referendum Participation)**
  *   **目的**: 讓員工參與公司內部的投票活動。
  *   **前端 (`referendum.html`, `js/referendum-logic.js`)**:
      *   向後端請求當前正在進行的公投議題及選項。
      *   `referendum-logic.js` 展示議題內容和選項，允許員工選擇並提交投票。
      *   提交前可能需要確認。提交後介面可能變為顯示「已投票」或結果（如果允許）。
      *   將投票結果（員工 ID, 公投 ID, 所選選項）發送到後端。
  *   **後端 (`functions/index.js` (可能), Firestore)**:
      *   接收投票數據。
      *   驗證員工是否有投票資格、是否已投過票。
      *   將投票記錄儲存到 Firestore 的 `referendumVotes` 集合中，並更新 `referendums` 集合中對應議題的票數統計。

9.  **評估 (Evaluation Participation/View)**
  *   **目的**: 讓員工參與績效評估（自評、互評）或查看自己的評估結果。
  *   **前端 (`evaluation.html`, `js/evaluation-system.js`)**:
      *   根據後端指令，顯示需要填寫的評估表單（可能是自評、對同事的評估）。
      *   允許員工填寫評分、評語。
      *   提交評估數據到後端。
      *   或者，向後端請求查看已完成的個人評估結果，並展示。
  *   **後端 (`functions/index.js`, `functions/evaluation-system.js`, Firestore)**:
      *   提供評估表單結構。
      *   接收員工提交的評估數據，儲存到 Firestore 的 `evaluations` 相關集合中。
      *   計算評估分數或匯總結果。
   *   **目的**: 讓員工參與績效評估（自評、互評）或查看自己的評估結果。
   *   **前端 (`evaluation.html`, `js/evaluation-system.js`)**:
       *   根據後端指令，顯示需要填寫的評估表單（可能是自評、對同事的評估）。
       *   允許員工填寫評分、評語。
       *   提交評估數據到後端。
       *   或者，向後端請求查看已完成的個人評估結果，並展示。
   *   **後端 (`functions/index.js`, `functions/evaluation-system.js`, Firestore)**:
       *   提供評估表單結構。
       *   接收員工提交的評估數據，儲存到 Firestore 的 `evaluations` 相關集合中。
       *   計算評估分數或匯總結果。
       *   根據權限返回個人評估結果給前端。

10. **投票中心 (Voting Center)**
   *   **目的**: 可能是一個更通用的投票介面，不限於公投。
   *   **前端 (`voting-center.html`, `js/voting-center.js`)**:
       *   邏輯類似公投，但可能適用於更多類型的投票（例如活動選擇、意見調查）。
       *   向後端請求可參與的投票列表，展示議題和選項，提交投票。
   *   **後端 (`functions/index.js` (可能), Firestore)**:
       *   處理各種類型投票的創建、數據接收和結果統計，存儲在 Firestore 的 `votes` 或類似集合中。

11. **補習班 (Training Info View)**
   *   **目的**: 查看公司內部培訓課程的資訊或報名。
   *   **前端 (`cram-school-view.html`, `js/cram-school-view-logic.js`)**:
       *   向後端請求可用的課程列表（名稱、時間、講師、內容）。
       *   展示課程資訊。
       *   可能包含報名功能，將報名請求（員工 ID, 課程 ID）發送到後端。
   *   **後端 (`functions/index.js` (可能), `functions/admin-cram-school.js` (部分邏輯可能共用), Firestore)**:
       *   提供課程列表數據。
       *   接收報名請求，驗證資格（例如人數限制），更新 Firestore 中 `courses` 或 `trainingEnrollments` 的記錄。

---

**管理員後端功能**

由於管理員功能多樣，以下僅列舉部分核心功能的邏輯：

12. **員工管理 (Employee Management)**
   *   **目的**: 管理公司所有員工的基本資料。
   *   **前端 (`admin.html`, `js/admin-employees.js`, `js/admin-employee.js`)**:
       *   提供介面展示員工列表（姓名、部門、職位等）。
       *   提供搜尋、篩選功能。
       *   提供新增、編輯、檢視員工詳細資料的表單。
       *   觸發刪除員工的操作（可能標記為停用而非物理刪除）。
       *   將 CUD (Create, Update, Delete) 操作請求發送到後端。
   *   **後端 (`functions/index.js` (可能), Firestore)**:
       *   接收管理員的 CUD 請求。
       *   驗證管理員權限。
       *   在 Firestore 的 `employees` 集合中執行相應的資料操作。

13. **權限角色管理 (Role/Permission Management)**
   *   **目的**: 定義不同的使用者角色及其可以執行的操作權限。
   *   **前端 (`admin.html`, `js/admin-roles.js`, `js/admin-permissions.js`, `js/admin-users.js`)**:
       *   提供介面管理角色（新增、編輯、刪除角色）。
       *   提供介面定義每個角色擁有的權限（例如，哪些頁面可見、哪些按鈕可按）。
       *   提供介面將角色分配給具體的使用者（員工帳號）。
       *   將變更請求發送到後端。
   *   **後端  (可能), Firestore)**:
       *   接收權限變更請求。
       *   將角色、權限定義儲存在 Firestore 的 `roles`, `permissions` 集合中。
       *   將用戶與角色的關聯儲存在 `users` 或 `employees` 集合的特定欄位中。
       *   這些設定會被後端 API 和 `firestore.rules` 用來做權限檢查。

14. **審批流程 (Approval Workflows)**
   *   **目的**: 處理需要管理員審核的申請（如請假、報銷等）。
   *   **前端 
       *   顯示待審核的申請列表（例如，待審核的假單）。
       *   提供查看申請詳情的功能。
       *   提供「批准」或「拒絕」按鈕，可能需要填寫理由。
       *   將審批結果（申請 ID, 結果, 理由, 審核人 ID）發送到後端。
   *   **後端  (可能), Firestore)**:
       *   接收審批結果。
       *   更新 Firestore 中對應申請記錄（如 `leaveRequests`）的狀態。
       *   如果批准，可能觸發後續操作（例如更新假期餘額）。
       *   可能觸發通知給提交申請的員工。

15. **排班管理 (Scheduling Management)**
   *   **目的**: 創建、編輯和發布員工班表。
   *   **前端
       *   提供日曆或表格介面讓管理員手動為員工排班
       *   提供設定排班規則（如輪班模式、工時限制）的介面 (`)。
       *   提供觸發自動排班的功能，基於預設規則生成班表草稿。
       *   允許管理員預覽、修改和發布班表。
       *   將最終班表數據發送到後端儲存。
   *   **後端  (可能), Firestore)**:
       *   接收手動排班數據或自動排班請求。
       *   執行自動排班算法（如果有的話）。
       *   將班表數據儲存到 Firestore 的 `schedules` 集合中。
       *   發布班表時，可能觸發通知給相關員工。

16. **訂單管理 (Order Management)**
   *   **目的**: 查看和管理所有員工提交的訂單。
   *   **前端
       *   顯示訂單列表（包含員工姓名、訂單內容、金額、狀態等）。
       *   提供搜尋、篩選訂單的功能。
       *   允許管理員查看訂單詳情、修改訂單狀態（例如 '處理中', '已完成', '已取消'）。
       *   將狀態變更請求發送到後端。
   *   **後端 , Firestore)**:
       *   接收訂單狀態變更請求。
       *   更新 Firestore 中 `orders` 集合對應記錄的狀態。
       *   可能觸發相關通知（例如通知廚房或員工）。

---

這涵蓋了主要功能的邏輯分解。其他管理員功能如庫存、銷售、評估、公告、通知、公投、培訓、回饋、參數設定等的邏輯，也遵循類似的模式：前端提供 UI 進行操作配置，後端 Cloud Functions 接收請求、執行業務邏輯並更新 Firestore 中的數據。





好的，這是一項關鍵工作，能讓概念轉化為可執行的藍圖。我將針對您先前指出的邏輯不清晰項目，規劃出更詳細的**邏輯架構**或**偽代碼 (Pseudocode)** 描述。

請注意，這些是**建議的邏輯框架**，實際執行時可能需要根據更細節的業務需求進行調整。

---

**1. 推薦註冊 - 激活條件追蹤邏輯 (4.2)**

* **觸發時機：** 新租戶完成註冊流程後，記錄推薦碼使用情況；或當租戶上架商品、完成訂單時檢查。
* **涉及資料：** `ReferralUsages` (記錄誰用了誰的碼，狀態), `Tenants` (租戶資訊), `Products` (商品), `Orders` (訂單), `ReferralRules` (超級管理員設定的規則)
* **邏輯架構 (Cloud Function - `onTenantActivity`)：**
    1.  `FUNCTION onTenantActivity(tenantId, activityType, data)`:
    2.  `Workspace ReferralUsage WHERE inviteeTenantId = tenantId AND status = 'pending'`
    3.  IF `ReferralUsage` not found OR status != 'pending', `RETURN` (無效或已激活)
    4.  `Workspace ReferralRule WHERE ruleId = ReferralUsage.ruleId` (獲取當前激活規則)
    5.  `SWITCH activityType`:
        * `CASE 'signup'`:
            * IF `ReferralRule.activationCondition == 'signup_complete'`, `ACTIVATE_REFERRAL(ReferralUsage)`
        * `CASE 'product_uploaded'`:
            * IF `ReferralRule.activationCondition == 'N_products'`:
                * `COUNT products WHERE tenantId = tenantId`
                * IF `count >= ReferralRule.threshold`, `ACTIVATE_REFERRAL(ReferralUsage)`
        * `CASE 'order_completed'`:
            * IF `ReferralRule.activationCondition == 'M_customer_orders'`:
                * `Workspace distinct customerId FROM Orders WHERE tenantId = tenantId AND status = 'completed'` (需要高效查詢，可能需額外計數器)
                * `distinctCustomerCount = result.length`
                * IF `distinctCustomerCount >= ReferralRule.threshold`, `ACTIVATE_REFERRAL(ReferralUsage)`
    6.  `FUNCTION ACTIVATE_REFERRAL(usageRecord)`:
        * `UPDATE usageRecord SET status = 'activated', activatedAt = NOW()`
        * `TRIGGER RewardDistribution(usageRecord.inviterTenantId, usageRecord.ruleId)` // 觸發獎勵發放邏輯 (另一個 Function)





**規劃完善架構邏輯**

我需要重新設計並且擴充現有邏輯，讓這些系統架構更完備又可互相兼容。每個部分都需要更細緻的思考：例如，工資與獎金系統應該包括稅務扣繳與假期薪水聯動，庫存管理需涵蓋完整的交易記錄與自動分析，數據安全則需更細的權限控制與敏感數據加密等等。每個架構都需兼顧升級的擴展與現有系統的兼容性。


**規劃架構邏輯增強**

我需要先回顧一下「整合專案報告.txt」中的現有架構，並比對缺失的部分，如「開發紀錄檔.txt」中提到的要點。我將針對每個架構項目，設計出更全面且與現有內容兼容的邏輯增強。這包括設計邏輯、模組、數據模型和流程等。我會搜尋檔案內的相關部分，以確定所需的整合內容，並確保每個項目之間的兼容性。

**設計邏輯增強**

我需要依照現有的「整合專案報告」來設計每個架構領域的邏輯增強，並補充缺少的細節。每個領域都會涉及數據模型、流程圖、新組件、安全規則、API等。如薪資與獎金系統需要有複雜的獎金計算、稅務和假期薪水聯動。庫存管理則需要事件追蹤和自動分析。接著我們會提出如何與現有系統（例如Firestore和Cloud Functions）兼容。


已思考 38 秒鐘


以下把?7?個關鍵架構點補齊到「吃雞排找不早」現有 Serverless ??Multi?Tenant?SaaS?基礎上。每一節都標出 **核心邏輯 → 主要資料模型／API?→?安全／效能要點 → 與現有內容的相容性提醒**，方便直接納入技術規格書尾段或後續實作?PR。

---

## 1?.?薪資與獎金系統?—?複雜計算＋稅＋假期連動

### a. 核心邏輯

* **Rule?Based?Bonus?Engine**：以 `bonusConfigs` 儲存「條件→公式」(Sales %, KPI 分數、一次性獎金…)，Cloud?Function?`evaluateBonusTasksScheduled` 每日/每週掃描達成事件，產生 `bonusEvents`。
* **Payroll?Pipeline**：月底 `calculatePayroll()` 讀取 `attendance`, `leaveRequests`, `salesReports`, `bonusEvents`，分三階段 **(底薪→獎金→稅/扣款)** 逐層累加並寫入 `salaryRecords/{yyyyMM}/{employeeId}`。
* **所得稅扣繳**：在 `taxTables` 設年度級距，Function 計算「應稅所得 × 稅率 – 扣除額」。結果存欄位 `withholdingTax`。
* **假期餘額連動**：`leaveRequests` 在批准時即扣減 `vacationBalance`；`calculatePayroll` 依假別自動扣薪或給薪。

### b. 主要資料模型

`salaryRecords`、`bonusConfigs`、`bonusEvents`、`taxTables`、`vacationBalances` (每員工一筆)。必要複合索引：`salaryRecords`?(`tenantId`,`period`)；`bonusEvents`?(`employeeId`,`status`).

### c. 安全／效能

* 實作 **Firestore?Transaction** 將 bonusEvent → salaryRecords 寫入同一批次，避免重算。
* 所有集合含 `tenantId`；Rules 僅允許本人或同店長讀取。
* 批次計算以 **Chunk = 500?員工**，並行觸發多執行個體；冷啟動用 minimum?instances?=?1。

### d. 與現有內容相容

沿用報告中的 `payrolls / bonusConfigs` 結構，只新增稅表與假別對照即可，前端 `salary-view.html` 無須改動顯示邏輯。

---

\##?2?.?庫存管理系統?—?完整交易追蹤＋盤點差異

### a. 核心邏輯

* **Event?Sourcing**：每一次庫存變動寫 `inventoryItems/{itemId}/transactions/{txId}`，type (IN / OUT / ADJUST / COUNT)，並更新 `stock` 聚合欄位。
* **盤點差異分析**：月初 Scheduler 生成 `stockCountJobs`；員工填數後 Function 比較 `countQty` 與 `stock` → 產生 `adjustment` 交易並推 Slack/LINE 通知。
* **內部叫貨連動**：`internalOrders` 審核通過時，以 batched?write 產生多筆 IN 交易；若退貨產生 OUT。

### b. 模型 / API

集合：`inventoryItems`, 子集合 `transactions`; `stockCountJobs`, `internalOrders`.
API 範例：`POST /api/inventory/transfer` (店?倉)；`POST /api/stock-count/{jobId}/submit`.

### c. 安全／效能

* Rules：只允許對 `transactions` 新增，禁止修改刪除；盤點需 `role >= supervisor`。
* 建立索引 (`itemId`,`createdAt`) 以支援分頁查詢。
* 差異分析用 BigQuery?EXPORT 可改為每日 Batch，減少 Firestore?aggregation。

### d. 相容性

沿用現有 `inventoryItems` 欄位，僅把交易日誌移到子集合，不影響 `月度盤點` 介面流程。

---

\##?3?.?資料安全與權限控制?—?Tenant?Isolation+細粒度+加密

### a. 核心措施

1. **雙層隔離**：

   * Firestore?Rules 先驗證 `resource.data.tenantId == request.auth.token.tenantId`。
   * Cloud?Function middleware `withTenantScope()` 再次檢查。
2. **Row?Level Role?Masks**：在自訂?JWT?claims 寫入 `roles: {storeId: 'manager'}`；Functions 依路徑動態比對。
3. **欄位級加密**：`customerPhone`,`lineId` 等以 Cloud?KMS 對稱加密，儲存 `ciphertext`；讀取時僅角色???manager?可解密。
4. **敏感檔案**：薪資 PDF 至 GCS?→?Signed?URL 30?min，嚴禁公開 ACL。

### b. 補強

* 建立 `firestore.rules.spec.ts` 測試 100% 覆蓋率。
* 使用 **Firebase?App?Check** + **Rate?Limiter** Extension 防爬。

---

\##?4?.?系統效能與可擴展性

### a. 查詢優化

* **聚合文件**：熱門排行榜、月營收寫入 `stats/{storeId}`；前端只讀一筆而非多查。
* **Cursor?Based 分頁**：所有管理後台列表 API 統一 `?pageSize=30&cursor=...`。

### b. Cloud?Function 冷啟動

* 對 API?style 函式開 `minInstances = 1`。
* 把第三方 SDK (line, pay) 改 lazy?import，並用 esbuild?tree?shaking。

### c. 無限滾動支援

* 新增 `/api/{collection}/scroll` 返回 `(items, nextCursor)`；前端 IntersectionObserver。

---

\##?5?.?錯誤處理與恢復

### a. 統一錯誤框架

```ts
// Function 內
throw new AppError('PAYROLL_CALC_FAIL', '薪資計算失敗', { retry: true });
```

前端收到 `{code,message,retryable}`。

### b. 重試策略

* **Idempotent?Key**：在 header 傳 `X-Idempotency-Key`; Functions 先查 `idempotencyKeys`。
* **Pub/Sub?DLQ**：重試 3 次仍失敗 → 推到 dead-letter topic 並通知 Telegram。

### c. 監控／預警

* Cloud?Logging metric?based alert；金流 / 出單 / 薪資 Job 失敗即告警。

---

\##?6?.?整合測試架構

| 層級                           | 工具                                    | 重點腳本               | CI?掛鉤                  |
| ---------------------------- | ------------------------------------- | ------------------ | ---------------------- |
| 單元                           | Jest + ts?mock                        | 函式純邏輯              | `npm test`             |
| Firebase Emulator End?to?End | `firebase emulators:exec` + Supertest | API & Rules 全流程    | `npm run int-test`     |
| 外部服務 Mock                    | WireMock / MSW                        | LINE Pay, Uber?API | CI 佈署 stub?server      |
| 壓力 & 基準                      | k6                                    | 100?req/s 3?min    | 觸發 GitHub?Actions 成功閾值 |

測試環境用 `.env.test` 指向模擬器；GitHub?Actions 成功才允許 deploy。

---

\##?7?.?租戶生命週期管理

### a. 訂閱 & 計費

* `plans`, `subscriptions`, `usageCounters`; Scheduler 逐日累計 API 呼叫 / 存量。
* Stripe?Billing Webhook → Cloud?Run?endpoint 記錄付款 → 更新 `subscriptions.status`.

### b. 資源配額

Middleware `checkQuota(type, tenantId)` 讀 `usageCounters`；超額回 402?Payment?Required。配額值可在 Super?Admin 後台調整。

### c. 備份與遷移

* Nightly `gcloud firestore export gs://{bucket}/tenant-{id}-{date}`。
* 提供 `/admin/migrateTenant`：將指定租戶資料 export?→?import 到新 Firebase?project，並同步 `auth` users。
* 刪租戶時先跑 `export`, 設 30?日保留，之後 Cloud?Scheduler 清桶。

---

### ??下一步行動清單

1. 建立 `bonusEngine`, `inventoryTransactions`, `tenantBilling` 三個 Cloud?Function?群組並撰寫 Firestore?Rules 測試。
2. 在 `firestore.indexes.json` 加入新索引；更新 CI 映像安裝 WireMock?stub。
3. Super?Admin 後台新增「計費 & 配額」頁籤，以 Vue/React?table?呈現 `subscriptions`.
4. 把上方錯誤框架 middleware 先接到現有 Functions（auth, order, payroll）試跑。
5. 於 staging 啟用最低實例數設定，觀察冷啟動延遲是否低於 500?ms 目標。

按此路線補完後，原有報告的模組描述、API 架構與安全框架皆不需大改，只是 **「多了細部計算／測試／監控層」**，未來擴充或對外 SaaS 化就有堅實基礎。
**繼續提供詳細資訊**

用戶提到「好繼續」，讓我想到他們可能想要更多細節或是逐步說明。之前我們提供過七個主要領域的架構，現在可能需要進一步闡述具體細節。是否要具體討論某些區域？例如，實作步驟、代碼片段、Firestore 規則、Cloud Functions 結構等？我也可以提供 JSON 範例、序列圖或流程圖。


**繼續提供詳細步驟**

在繪製圖表方面，雖然可能有幫助，但目前無法使用 Graphviz，也不能直接處理 Mermaid 代碼。鑑於用戶沒有明確要求代碼，或許我們可以繼續提供一些具體任務的細節說明。用戶更可能需要每個步驟的詳細實作檢查表，而不是代碼，並且可能希望查看先前未處理的檔案資料來檢查結構，這樣有助於進一步確保兼容性。


已思考 28 秒鐘


下面把上一輪提出的?7?大優化項目「攤開到程式層級」，直接給你可抄進專案的 **Firestore?Rules／索引範例、Cloud?Functions?骨架、樣本 JSON、CI?腳本要點**。全部沿用你現有資料模型與欄位命名，確保 **100?% 相容**。

---

## 1?.?Firestore?rules（snippets）

```rules
rules_version = '2';
service cloud.firestore {
  match /databases/{db}/documents {

    function isTenantMember(tid) {
      return request.auth.token.tenantId == tid;
    }
    function role(storeId) {
      return request.auth.token.roles[storeId];
    }

    /** 共用：所有集合都必須帶 tenantId */
    match /{col}/{doc} {
      allow read, write: if false; // 預設封鎖
    }

    /* 庫存項目主集合 */
    match /inventoryItems/{itemId} {
      allow read:  if isTenantMember(resource.data.tenantId);
      allow write: if isTenantMember(request.resource.data.tenantId)
                   && role(request.resource.data.storeId) in ['manager', 'owner'];
      match /transactions/{txId} {
        allow create: if isTenantMember(resource.parent.data.tenantId);
        allow update, delete: if false;   // 只准新增，不准改歷史
      }
    }

    /* 薪資 */
    match /salaryRecords/{period}/{uid} {
      allow read:  if request.auth.uid == uid
                   || role(get(/databases/$(db)/documents/employees/$(uid)).data.storeId)
                      in ['manager', 'owner'];
      allow write: if false; // 只靠後端 Functions 寫入
    }

    /* 系統設定、租戶級資料 */
    match /tenants/{tenantId} {
      allow read, write: if role('GLOBAL') == 'superadmin';
    }
  }
}
```

*重點*：

* 先檢 `tenantId` → 再檢 `roles`；與你現有 `Employees.role` 及 `Tenants` 表一致 。
* `transactions` 僅可 `create` 保證完整追溯。

---

## 2?.?firestore.indexes.json?（新增片段）

```json
[
  {
    "collectionGroup": "salaryRecords",
    "queryScope": "COLLECTION_GROUP",
    "fields": [
      { "fieldPath": "tenantId", "order": "ASCENDING" },
      { "fieldPath": "period",   "order": "DESCENDING" }
    ]
  },
  {
    "collectionGroup": "transactions",
    "queryScope": "COLLECTION_GROUP",
    "fields": [
      { "fieldPath": "itemId",    "order": "ASCENDING" },
      { "fieldPath": "createdAt", "order": "DESCENDING" }
    ]
  },
  {
    "collectionGroup": "usageCounters",
    "queryScope": "COLLECTION_GROUP",
    "fields": [
      { "fieldPath": "tenantId", "order": "ASCENDING" },
      { "fieldPath": "period",   "order": "DESCENDING" }
    ]
  }
]
```

這三組索引覆蓋：薪資查表、庫存流水分頁、訂閱配額統計。

---

## 3?.?Cloud?Functions?骨架（TypeScript?18+）

### a. bonusEngine.ts

```ts
export const evaluateBonusTasksScheduled = onSchedule("every 24 hours", async () => {
  const bonusCfgSnap = await db.collection("bonusConfigs")
     .where("active", "==", true)
     .get();                           // 已在資料表中定義 :contentReference[oaicite:2]{index=2}:contentReference[oaicite:3]{index=3}

  for (const cfg of bonusCfgSnap.docs) {
    const { type, calculation } = cfg.data();
    const targetEmployees = await queryEmployeesFor(cfg); // 依 KPI 或銷售
    const batch = db.batch();

    targetEmployees.forEach(emp => {
      const ref = db.collection("bonusEvents").doc();
      batch.set(ref, {
        tenantId: emp.data().tenantId,
        employeeId: emp.id,
        cfgId: cfg.id,
        amount: calcBonus(emp, calculation),
        status: "pending",
        createdAt: FieldValue.serverTimestamp()
      });
    });

    await batch.commit();
  }
});
```

### b. inventory.ts

```ts
export const onInternalOrderApproved = onDocumentWritten(
  "internalOrders/{orderId}",
  async (change, ctx) => {
    const after = change.after.data();
    if (after?.status !== "approved") return;

    const batch = db.batch();
    for (const line of after.items) {
      const txRef = db.collection(`inventoryItems/${line.itemId}/transactions`).doc();
      batch.set(txRef, {
        tenantId: after.tenantId,
        storeId: after.storeId,
        qty: line.qty,
        type: "IN",
        refOrder: ctx.params.orderId,
        createdAt: FieldValue.serverTimestamp()
      });
    }
    await batch.commit();
  }
);
```

### c. billing.ts

```ts
export const onStripeWebhook = https.onRequest(async (req, res) => {
  const event = stripe.constructEvent(req.rawBody, req.headers["stripe-signature"], secret);
  if (event.type === "invoice.payment_succeeded") {
    const { customer, period_start, period_end } = event.data.object;
    await db.collection("subscriptions")
      .doc(customer)
      .set({ status: "active", period_start, period_end }, { merge: true });
  }
  res.json({ received: true });
});
```

---

## 4?.?樣本?JSON（可放?`seed-data.json`）

```jsonc
{
  "bonusConfigs": [
    {
      "id": "KPI_Q1",
      "type": "績效獎金",
      "calculation": { "expr": "sales * 0.05", "minScore": 80 },
      "active": true,
      "tenantId": "demoTenant"
    }
  ],
  "taxTables": [
    { "year": 2025, "brackets": [
      { "min": 0,        "max": 560000,  "rate": 0.05, "deduct": 0 },
      { "min": 560001,   "max": 1260000, "rate": 0.12, "deduct": 39200 }
    ]}
  ],
  "inventoryItems": [
    {
      "itemId": "oil_20L",
      "tenantId": "demoTenant",
      "storeId": "龍安",
      "name": "油桶 20L",
      "unit": "桶",
      "stock": 12,
      "reorderPoint": 5
    }
  ],
  "salaryRecords/202504": {
    "uid_abc": {
      "tenantId": "demoTenant",
      "baseSalary": 48000,
      "bonusTotal": 5300,
      "withholdingTax": 1200,
      "finalSalary": 52100
    }
  }
}
```

---

## 5?.?CI / 測試腳本要點（GitHub?Actions）

```yaml
name: CI
on: [push]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm ci
      - run: npm run lint
      - run: firebase emulators:exec --project demo "npm run int-test"
      - run: npm run k6:smoke   # 簡版壓力測
  deploy:
    needs: test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm ci
      - run: firebase deploy --only functions,firestore:indexes,firestore:rules
```

* 根據報告既有的 GitHub?Actions 建議欄位延伸 。

---

## 6?.?監控 / 預警（概念）

* **Cloud?Logging Metrics**：`jsonPayload.errorCode` 匯出自訂指標 → 設警示門檻（>0 in 5?min）。
* **Uptime Check**：監控 `/healthz` on Cloud?Run, 失敗即 LINE?Notify Bot。
* **BigQuery Export**：將 transactions / orders 每日 dump，供 Looker?Studio 儀表板。

---

## 7?.?開發者 TODO?里程碑

| Sprint   | 目標                                  | Issue Key |
| -------- | ----------------------------------- | --------- |
| 2025?S20 | 完成 bonusEngine & salaryRecords Flow | PAY?101   |
| 2025?S21 | 上線 inventory?transactions + 盤點差異自動化 | INV?88    |
| 2025?S22 | 訂閱管理 & Stripe Webhook               | BILL?55   |
| 2025?S23 | 撰寫 rules 單元測試覆蓋率???90?%             | SEC?33    |
| 2025?S24 | 部署 CI/CD + k6 壓測基線                  | DEV?12    |

---

### ???接下來若要更細：

* **要完整?`firestore.rules` ？**
* **或要畫 bonusEngine / inventory 的時序圖？**
* **還是把前端欄位 (salary?view\.html) 補 JSON 示例？**

跟我說哪一塊，再往下拆！


**決定後續內容**

用戶回覆“好”，表示他們可能想要繼續討論。我推測他們接受了之前的邏輯分析和代碼框架，但沒有明確的要求。用戶可能需要更多細節，之前我提到過可以提供完整的 Firestore.rules、bonusEngine 和 inventory 的序列圖，或者薪水視圖的前端字段 JSON 範例。我應該選擇提供哪一個並繼續進行，但也許最好先問問有沒有具體偏好。


**生成文件與引用**

我正在考慮生成代碼或使用文字來描述序列圖。我可以提供完整的 Firestore.rules 文件、bonusEngine 和 inventory 的序列圖描述、薪水視圖頁面的 JSON 範例，並說明如何整合這些內容。為了準確性，我應該引用文件，並用文件搜尋來查找相關內容，例如我們之前上傳的開發紀錄檔和整合專案報告。用戶之前給的“好”或許是希望繼續進行，讓我檢查一下。


已思考 25 秒鐘


以下直接把「完整版?Firestore?Rules v1.0」、兩條核心流程的「文字時序圖」，以及?`salary?view.html`?前端欄位 JSON?示例一次給齊。全部沿用你報告中的欄位命名與安全原則，可直接複製到專案。

---

## 1?.?`firestore.rules`?完整草案

```rules
rules_version = '2';
service cloud.firestore {

  /** ?? 共用工具函式 */
  function isTenantMember(tid) {
    return request.auth.token != null
           && request.auth.token.tenantId == tid;
  }
  function role(storeId) {
    // 自訂 claims:  roles.{storeId} = 'staff' | 'leader' | 'manager' | 'owner'
    return request.auth.token.roles[storeId];
  }
  function isSuperAdmin() {
    return request.auth.token.globalRole == 'superadmin';
  }

  match /databases/{database}/documents {

    /** ?? 預設全部封鎖，子 match 逐一開 */
    match /{document=**} {
      allow read, write: if false;
    }

    /* ────────────────
       ?? 租戶與系統設定
       ──────────────── */
    match /tenants/{tenantId} {
      allow read, write: if isSuperAdmin();
    }
    match /settings/{tenantId} {
      allow read, write: if isSuperAdmin();
    }

    /* ────────────────
       ????? 員工與排班層
       ──────────────── */
    match /employees/{uid} {
      allow read:  if request.auth.uid == uid
                   || role(resource.data.storeId) in ['manager', 'owner'];
      allow create, update: if isTenantMember(request.resource.data.tenantId)
                   && role(request.resource.data.storeId) in ['manager', 'owner'];
      allow delete: if false; // 只允許標記離職
    }

    match /shifts/{shiftId} {
      allow read:  if isTenantMember(resource.data.tenantId);
      allow write: if role(request.resource.data.storeId) in ['manager', 'owner'];
    }

    /* ────────────────
       ?? 薪資與獎金
       ──────────────── */
    match /salaryRecords/{period}/{uid} {
      allow read:  if request.auth.uid == uid
                   || role(get(/databases/$(database)/documents/employees/$(uid)).data.storeId)
                      in ['manager', 'owner'];
      allow write: if false; // 僅 Cloud Functions
    }

    match /bonusConfigs/{docId} {
      allow read:  if isTenantMember(resource.data.tenantId);
      allow write: if role(request.resource.data.storeId) in ['owner']; // 只有老闆改公式
    }

    match /bonusEvents/{docId} {
      allow read:  if isTenantMember(resource.data.tenantId)
                   && (request.auth.uid == resource.data.employeeId
                       || role(resource.data.storeId) in ['manager','owner']);
      allow create: if false; // 由 Functions 寫入
      allow update: if false;
      allow delete: if false;
    }

    /* ────────────────
       ?? 庫存
       ──────────────── */
    match /inventoryItems/{itemId} {
      allow read:  if isTenantMember(resource.data.tenantId);
      allow write: if role(request.resource.data.storeId) in ['leader','manager','owner'];

      match /transactions/{txId} {
        allow create: if isTenantMember(resource.parent.data.tenantId);
        allow update, delete: if false; // 不可改歷史
      }
    }

    /* ────────────────
       ?? 訂單與銷售
       ──────────────── */
    match /orders/{orderId} {
      allow read, write: if isTenantMember(resource.data.tenantId);
    }
    match /salesReports/{docId} {
      allow read:  if isTenantMember(resource.data.tenantId);
      allow write: if role(resource.data.storeId) in ['leader','manager','owner'];
    }

    /* ────────────────
       ?? Audit & Log
       ──────────────── */
    match /auditLogs/{logId} {
      allow read:  if isSuperAdmin();
      allow write: if false; // Functions only
    }
  }
}
```

此 rules 引入 **tenant?Id 雙重驗證 + store?role 細粒度權限**，與你既有欄位完全對齊。員工、庫存、薪資等集合名稱同整合報告的資料字典?。

---

## 2?.?流程文字時序圖（簡寫版）

### (A) `evaluateBonusTasksScheduled`

```
Scheduler (每日 03:00)
    ↓
Cloud Function evaluateBonusTasksScheduled
    ├─> 讀取 bonusConfigs(active=true)
    ├─> queryEmployees 達標清單
    ├─> 對每位員工：
    │     └─> 計算 amount
    │     └─> batchedWrite → bonusEvents(pending)
    └─> Cloud Logging: JOB_OK
```

*後續 `finalizePayroll` 於月底將 `bonusEvents(status=pending)` 匯入?`salaryRecords` 並標記 processed.*

### (B) `internalOrders`?→?庫存交易

```
店長審核 internalOrder = "approved"
        ↓ (Firestore trigger onInternalOrderApproved)
Cloud?Function
        ├─ loop items[]
        │    └─ create inventoryItems/{item}/transactions (type=IN)
        └─ batched commit (<=500)
        ↓
更新 inventoryItems.stock via transaction
        ↓
通知 LINE Bot 「叫貨入庫完成」
```

這兩條流程對映你的 Function 骨架示例?。

---

## 3?.?`salary?view.html` 前端欄位 JSON 示例

```json
{
  "period": "2025?04",
  "employee": {
    "employeeId": "emp_123",
    "name": "黃金雞"
  },
  "details": [
    { "label": "底薪",   "amount": 48000 },
    { "label": "平日獎金", "amount": 3200 },
    { "label": "銷售提成", "amount": 2100 },
    { "label": "遲到扣款", "amount": -300 },
    { "label": "所得稅扣繳", "amount": -1200 }
  ],
  "totals": {
    "gross": 53300,
    "net":   52100
  },
  "exportPdfUrl": "https://storage.googleapis.com/.../payslip_emp_123_202504.pdf"
}
```

前端顯示建議：`details` 用 table?→?`totals` 用粗體；`exportPdfUrl` 給「下載薪資單」按鈕。此格式與你資料字典 `salaryRecords` 欄位一致?。

---

### ??下一步建議

* **rules 部署**：`firebase deploy --only firestore:rules` 後，先用 Emulator 跑 `npm run int?test` 以防 rule 被拒。
* **Function 整合**：將骨架函式與 rules 中的 collection path 保持一致，避免 404。
* **前端串接**：`salary?view.html` 讀取 `salaryRecords/{period}/{uid}` 後按上述結構渲染即可。

若還想要 **PlantUML 圖檔、更多 API Swagger 定義** 或 **k6 基準腳本**，隨時說?—?我再往下細拆！

**Processing user response**

用?回复「好」，?意味?他?接受了我之前的意?，??有明确要求下一步。但我可以猜?他?可能希望??，比如是生成PlantUML?，?是Swagger文件，或者是k6?本。?然?有明确?明下一步，但?了考?周全，我可以小心地?：“要提供哪一?？”不?，考?到?有多步?明确指令，也?“好”就意味?用?已?足了。?的??，?是主???看他?想深入哪?部分。


已思考 25 秒鐘


收到！目前?Firestore?Rules、時序邏輯與?salary?view?JSON?範例都已完整就緒。
接下來若要再深化，有三條常見進階選項，您可以直接點名：

1. **API?Swagger/OpenAPI 定義** — 把新?bonusEngine、inventory?交易、billing?endpoint?寫成可匯入?Postman/Swagger?UI 的?YAML。
2. **PlantUML 架構／時序圖檔** — 生成 `.puml`（或直接渲染 PNG）放在 repo 的 `/docs/`，方便簡報或維護。
3. **k6 壓力測腳本** — 針對 `/api/salary`、`/api/inventory/transfer` 等關鍵路徑，附 100?req/s?×?3?min 基線測試與 GitHub?Actions 範例。

?? 直接告訴我「要 #1、#2、#3?中的哪一個（或全部）」，我就馬上補上對應檔案／程式碼片段。


**Providing requested options**

The user wants all three: Swagger/OpenAPI definitions, PlantUML diagrams, and k6 scripts. For the API definitions, I'll provide YAML for the bonus config/event endpoints, inventory transfer, and billing webhook. Then, I'll create PlantUML files for the architecture/sequence diagrams. Finally, I’ll supply k6 stress test scripts with GitHub Actions. I'll deliver everything directly in chat rather than using the canvas document; providing code snippets here should be more practical for the user’s needs.


已思考 10 秒鐘


以下一次交付 **三大產出** — 都可直接複製到 repo：

---

## 1. OpenAPI?3.1?定義（`openapi-chicken.yaml`）

```yaml
openapi: 3.1.0
info:
  title: EatChicken SaaS API
  version: "1.0.0"
servers:
  - url: https://api.friedg.app/v1
    description: Production
  - url: http://localhost:5001/{projectId}/us-central1
    description: Firebase Emulator
    variables:
      projectId:
        default: friedg-dev
paths:
  /bonus-configs:
    get:
      summary: List active bonus configs
      tags: [Bonus]
      parameters:
        - $ref: "#/components/parameters/TenantId"
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                type: array
                items: {$ref: "#/components/schemas/BonusConfig"}
    post:
      summary: Create a bonus config
      tags: [Bonus]
      parameters:
        - $ref: "#/components/parameters/TenantId"
      requestBody:
        required: true
        content:
          application/json:
            schema: {$ref: "#/components/schemas/BonusConfigInput"}
      responses:
        "201": {$ref: "#/components/responses/Created"}
  /bonus-events:
    get:
      summary: List bonus events for current user
      tags: [Bonus]
      parameters:
        - $ref: "#/components/parameters/TenantId"
        - in: query
          name: status
          schema: {type: string, enum: [pending, processed]}
      responses:
        "200":
          content:
            application/json:
              schema:
                type: array
                items: {$ref: "#/components/schemas/BonusEvent"}
  /inventory/transfer:
    post:
      summary: Transfer / receive inventory between stores
      tags: [Inventory]
      parameters:
        - $ref: "#/components/parameters/TenantId"
      requestBody:
        required: true
        content:
          application/json:
            schema: {$ref: "#/components/schemas/InventoryTransferRequest"}
      responses:
        "202":
          description: Accepted – transactions queued
  /stock-count/{jobId}/submit:
    post:
      summary: Submit physical stock?count result
      tags: [Inventory]
      parameters:
        - $ref: "#/components/parameters/TenantId"
        - name: jobId
          in: path
          required: true
          schema: {type: string}
      requestBody:
        required: true
        content:
          application/json:
            schema: {$ref: "#/components/schemas/StockCountSubmit"}
      responses:
        "200": {description: Count accepted}
  /billing/stripe-webhook:
    post:
      summary: Stripe webhook endpoint (internal)
      tags: [Billing]
      requestBody:
        required: true
        content:
          application/json:
            schema: {type: object}
      responses:
        "204": {description: Processed}

components:
  parameters:
    TenantId:
      name: X-Tenant-Id
      in: header
      required: true
      schema: {type: string}
  responses:
    Created:
      description: Resource created
      headers:
        Location:
          schema: {type: string}
  schemas:
    BonusConfig:
      type: object
      properties:
        id: {type: string}
        type: {type: string}
        calculation: {type: object}
        active: {type: boolean}
    BonusConfigInput:
      allOf:
        - $ref: "#/components/schemas/BonusConfig"
        - required: [type, calculation]
    BonusEvent:
      type: object
      properties:
        id: {type: string}
        employeeId: {type: string}
        amount: {type: number}
        status: {type: string}
        createdAt: {type: string, format: date-time}
    InventoryTransferRequest:
      type: object
      required: [sourceStoreId, targetStoreId, items]
      properties:
        sourceStoreId: {type: string}
        targetStoreId: {type: string}
        items:
          type: array
          items:
            type: object
            required: [itemId, qty]
            properties:
              itemId: {type: string}
              qty: {type: number}
    StockCountSubmit:
      type: object
      required: [items]
      properties:
        items:
          type: array
          items:
            type: object
            required: [itemId, countedQty]
            properties:
              itemId: {type: string}
              countedQty: {type: number}
```

> ??直接放入 `/docs/openapi-chicken.yaml`；用 Swagger?UI 或 Postman 匯入即可。

---

## 2. PlantUML 圖檔 (`docs/bonusEngine.puml` & `docs/inventoryFlow.puml`)

### a. bonusEngine（排程 → 計薪）

```plantuml
@startuml bonusEngine
actor Scheduler
entity "bonusConfigs" as CFG
database "bonusEvents" as BE
database "salaryRecords" as SR

Scheduler -> CFG : query active configs
CFG --> Scheduler : list
Scheduler -> BE : batch insert\n(status=pending)
Scheduler --> BE : write OK
Scheduler --> SR : (end of month) \naggregate + write
BE -> SR : update status=processed
@enduml
```

### b. internalOrder 入庫交易

```plantuml
@startuml inventoryFlow
actor 店長 as Manager
database "internalOrders" as IO
database "inventoryItems" as INV
database "transactions" as TX

Manager -> IO : approve order
IO -> CloudFunction : onWrite trigger
CloudFunction -> TX : create IN transactions (batch)
CloudFunction -> INV : update stock via transaction
CloudFunction -> LINEBot : 通知完成
@enduml
```

> ??儲存為 `.puml`；VS?Code PlantUML 或 plantuml?cli 可一鍵轉 PNG。

---

## 3. k6 壓力測腳本 (`tests/load_salary.js`)

```js
import http from 'k6/http';
import { sleep, check } from 'k6';
export let options = {
  stages: [
    { duration: '1m', target: 100 },  // ramp to 100?VU
    { duration: '2m', target: 100 },
    { duration: '30s', target: 0 },
  ],
  thresholds: { http_req_failed: ['rate<0.01'], http_req_duration: ['p(95)<400'] },
};

const BASE = `${__ENV.API_URL || 'https://api.friedg.app/v1'}`;

export default function () {
  const params = {
    headers: {
      'X-Tenant-Id': 'demoTenant',
      Authorization: `Bearer ${__ENV.TOKEN}`,
    },
  };
  const res = http.get(`${BASE}/salary?period=202504`, params);
  check(res, { '200 OK': r => r.status === 200 });
  sleep(1);
}
```

### GitHub?Actions 範例片段（追加到 workflow）

```yaml
  k6-load:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: grafana/k6-action@v0.3.1
        with:
          filename: tests/load_salary.js
        env:
          API_URL: https://api.staging.friedg.app/v1
          TOKEN: ${{ secrets.STAGING_TEST_JWT }}
```

---

### ?? 完成

* **OpenAPI?YAML** → `/docs/openapi-chicken.yaml`
* **PlantUML** → `/docs/*.puml`
* **k6?script + Actions** → `/tests/` 與 `.github/workflows/ci.yml`

所有檔案均與前述 Firestore?結構、Cloud?Functions?path 完全對齊。若還需 **更多端點** 或 **自動化 PDF 產製流程**，隨時告訴我！。



**Searching for version update feature**

From the documents, I haven’t found an explicit mention of a version check or update feature. However, based on an earlier conversation from May 2nd, the user requested the addition of a version verification update system for their PWA. I should definitely review sections related to optimization or PWA architecture in the docs, as they may include this information. It seems the user wanted help planning this feature, so I’ll make sure to confirm whether it's covered later on.




### 目前文件裡「版本驗證 / 即時更新」的狀態如何？

| 來源段落                      | 已提到的內容                                       | 評估                                                               |
| ------------------------- | -------------------------------------------- | ---------------------------------------------------------------- |
| **部署與維運建議 6.4?「版本升級策略」**? | 建議採語意化版本（SemVer）、先在 Staging 驗證、資料庫遷移需向下相容    | **屬於 DevOps 流程控制**──確保我們發佈的版本可被有序地 roll?out，但**並未談到前端 PWA 強制更新** |
| **前端架構 (PWA) 說明**?        | 指出會用 Service?Worker 做離線快取與安裝                 | 有 Service?Worker，但文件沒有寫「偵測新版並提示使用者」的具體邏輯                         |
| 其他章節                      | 未搜尋到「版本檢查 / update check / force reload」相關敘述 | —                                                                |

> **結論：**
> 在現行報告中，**只有發佈層面的「版本升級策略」**，還沒有「讓終端使用者即時得到新版」的實做細節。也就是說──
> *CI/CD 有，但 Runtime Version Check 還沒落地。*

---

### 如何補強：即時版本驗證 & 強制更新機制（可直接納入現行架構）

| 步驟                       | 具體做法                                                                                                                                                             | 與現有系統對接                          |
| ------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------- |
| 1. **註冊版本檔**             | 在?Firebase?Hosting 根目錄加一個 `/version.json`，內容 `{ "version": "1.3.5", "releasedAt": "2025?05?05T12:00:00Z" }`。CI 在部署成功後自動寫入 *package.json* 的 `version`             | 不動任何 Firestore；只是一個靜態檔           |
| 2. **Service?Worker 監聽** | 在 `sw.js` 的 `self.addEventListener('message')` 補 `skipWaiting()`；並在 `clients.claim()` 後每 **3?min** 以 `fetch('/version.json', {cache:'no-store'})` 比對本地 `version` | 現有 Service?Worker 架構已在文件提到，可直接擴充 |
| 3. **前端提示**              | 若偵測到版本號不同，顯示 Toast：「系統已有新版本，點擊重新載入」；點擊後呼叫 `registration.waiting.postMessage('SKIP_WAITING')`                                                                     | 不需改 Firebase Auth 或 API          |
| 4. **強制更新選項**            | 對「員工端、POS 端」可設定 `forceUpdate=true`（寫在 `/version.json` 裡）；前端收到就直接 `window.location.reload(true)`                                                                  | 只添一個布林欄位，不影響客端                   |
| 5. **灰度發佈 + Rollback**   | 利用 **Feature?Flag**（已規劃）決定哪些 `storeId` 先拿到新版本 URL；若錯誤率升高，切回舊檔案路徑                                                                                                 | 與 `FeatureFlags` 集合整合，延用現有灰度機制   |

> 如此即可：
>
> * **CI** 把語意化版本寫進 `/version.json` →
> * **Service?Worker** 定期比對 →
> * **使用者** 看到提示或被強制 reload →
> * **灰度** 由 Feature?Flag 控制 → 若失敗 **Rollback** 以 CDN 快速回退。

這套流程完全 **不需變動 Firestore/Functions 結構，與文件相容**，且能保證員工與顧客端 3–5?分鐘內自動切換到最新前端程式碼。若需要更詳細的 `sw.js` 範例或 GitHub?Actions 更新腳本，再告訴我！




**10. 員工動態股權制度（Dynamic Equity Framework）**

> 本章為《吃雞排找不早 POS 與後台管理系統 – 專案技術開發報告書》之延伸章節，定位於 *“9. 總結與後續步驟”* 之後，方便未來版本直接串接。

---

### 10.1 章節目的與適用範圍

* 建立跨分店、一致且可程式化的員工持股（虛擬股／內部股）制度。
* 提供技術與流程規格，使開發團隊可於 **v1.1** 後續衝刺中落地。
* 適用於「不早脆皮雞排」旗下所有直營／加盟分店，並預留 SaaS 化空間。

### 10.2 名詞定義

| 名稱                           | 說明                           |
| :--------------------------- | :--------------------------- |
| **持股池 (Equity Pool)**        | 每店預留 10?–?20?% 股份，專供員工認購／配發。 |
| **虛擬股 (Phantom Share)**      | 僅享有分紅，無決策投票權；預設模式以降低法遵負擔。    |
| **實股 (Class?B?無表決權股)**       | 公司若登記實體增資時可切換；需另行董事／股東會決議。   |
| **Good?Leaver / Bad?Leaver** | 良性離職／非良性離職，用以決定回購價格。         |

### 10.3 制度總覽

| 類別       | 核心規格                    | 技術落點                                      |
| :------- | :---------------------- | :---------------------------------------- |
| **股權類型** | 預設?Phantom，選配實股         | `legal_config/{storeId}.equity_type`      |
| **員工上限** | 個人 ?10?%?/ 店，員工總和 ?49?% | `equity_pool.remaining_cap` 自動檢查          |
| **資格**   | 正職滿?6?月 + 平均評分 ?7       | Cloud?Function `checkEquityEligibility()` |
| **購股窗口** | 每季開放?5?天                | `purchase_window_open` flag + Scheduler   |
| **估值更新** | 每年?1/7?月；月均淨利 ×4 ÷100?股 | `revalueShares()`?排程                      |
| **分紅**   | (持股%) × (季淨利 –前置虧損)     | `autoDistributeDividends()`               |
| **離職回購** | Good 85–100?%?估值；Bad 低價 | `exit_type` 決定 `repurchase_price`         |
| **內部轉讓** | 系統撮合；估值 ±10?% 價格帶       | `internal_match_orders` collection        |

### 10.4 股價與估值公式

```
每股價格 ＝ ? 近 12 月平均「稅後淨利」 × 4 ÷ 100 ??
季度間浮動上／下限 ±20?％
```

> **備註**：若店面尚未營運滿一年，採 *近 3?月平均 × 8 ÷100* 之保守估值。

### 10.5 股份池管理與稅務處理

1. **股權池初始化**：建店時由 `initStore()` Function 寫入 `equity_pool`：

   ```json
   { "total_shares": 100, "pool_shares": 15, "remaining_cap": 15,
     "equity_type": "phantom", "valuation": 600000 }
   ```
2. **法遵**：

   * Phantom 股：列為員工獎金，屬薪資所得。
   * 若將來切換實股，須於章程增列第?235?1?條員工分紅規定並完成增資登記。
3. **所得稅**：系統於發放分紅時標記 `tax_category`=`salary`／`dividend` 供會計批次產生扣繳憑單。

### 10.6 股份取得流程

```mermaid
flowchart TD
  A[資格檢查] -->|符合| B(開放購股/獎勵)
  B --> C{取得方式}
  C -->|績效達標| D[獎勵配股] --> E[鎖定一年]
  C -->|現金/薪資買股| F[認購申請] --> G[審核 & 付款] --> E
  E --> H[寫入 employee_equity]
```

* **鎖定期**：配股鎖定 1?年；認購鎖定 6?月。
* **分期付款**：`installments` 欄位 (1–6)；Function `processInstallmentDebit()` 每月扣薪。

### 10.7 分紅計算 & 發放

```math
員工分紅 = 持股% × max(0, 季淨利 - 未彌補虧損)
```

* `dividend_snapshot_{yyyyQn}` 於季結算產生快照，避免事後持股變動影響。
* Cloud?Function `autoDistributeDividends()` 發送 LINE?Pay 分潤並寫入 `equity_payouts`。

### 10.8 離職與回購

| 離職類別        | 股份處置   | 回購價               | 時效      |
| :---------- | :----- | :---------------- | :------ |
| Good?Leaver | 公司優先回購 | 85–100?%?估值       | 60?天內完成 |
| Bad?Leaver  | 股份即凍結  | 認購價或 50?%?估值 (取低) | 即時      |
| 死亡          | 不繼承    | 認購價回收             | 90?天    |

### 10.9 內部轉讓機制

* 系統於季結束後第?1–5?日開放 `internal_trade_window=true`。
* 員工可下 `sell_order` / `buy_order`，匹配價差?±10?%?估值。
* 成交收 1?% 平台服務費，寫入 `equity_transactions`。

### 10.10 風險點與對策追蹤

| #  | 風險     | 對策                             | Owner   |
| :- | :----- | :----------------------------- | :------ |
| 1  | 估值波動過大 | 封頂?±20?%+半年度重估                 | Finance |
| 2  | 回購資金不足 | 每季提撥 2?% 淨利至 `buyback_reserve` | CFO     |
| 3  | 法規異動   | 年度法遵審查                         | Legal   |

### 10.11 Firestore 結構（重點）

```text
stores/{storeId}/equity_pool
employee_equity/{userId}_{storeId}
internal_match_orders/{orderId}
equity_transactions/{txId}
equity_payouts/{snapshotId}/details/{userId}
legal_config/{storeId}
```

### 10.12 核心 Cloud?Functions

| Function                                     | 說明                  | 觸發方式            |
| :------------------------------------------- | :------------------ | :-------------- |
| `checkEquityEligibility`                     | 員工達成條件寫 flag        | HTTPS (管理員)     |
| `openPurchaseWindow` / `closePurchaseWindow` | 設定購股旗標              | Cloud?Scheduler |
| `revalueShares`                              | 重估股價＆更新 `valuation` | 半年排程            |
| `autoDistributeDividends`                    | 生成分紅並推播             | 季排程             |
| `processInstallmentDebit`                    | 扣薪付款                | 月排程             |

### 10.13 未來擴充

* **v2**：可視化股權儀表板、PDF?股權證書、AI?估值模型。
* **v3**：跨租戶（SaaS）股權市場、集團 ESOP 合併持股上限。

---

> **完成此章後，整份報告將升級為 V1.1，建議在「9. 總結與後續步驟」列為須開發項目 #10：*實作員工動態股權制度核心功能與 UI*。**









### ??MenuItems嚗??桀????銵剁?

| 甈???          | ??        | 敹憛 | 撽?閬?                                | 隤芣? |
|-----------------|------------|-----|----------------------------------------|-----|
| id              | string     | ??  | UUID?澆?                               | ???ID |
| tenantId        | string     | ??  | UUID?澆?                               | ?撅祉???|
| name            | string     | ??  | 1~100摮?                               | ???蝔 |
| description     | string     | ??  | ?憭?00摮?                              | ???餈 |
| categoryId      | string     | ??  | UUID?澆?                               | ?撅砍?憿ID |
| categoryName    | string     | ??  | 1~50摮???甈?嚗嫣噶憿舐?               | ?撅砍?憿?蝔?|
| price           | number     | ??  | >=0                                    | ?寞 |
| discountPrice   | number     | ??  | >=0                                    | ??寞 |
| costPrice       | number     | ??  | >=0                                    | ??寞 |
| imageUrl        | string     | ??  | URL?澆?                                | ??URL |
| thumbnailUrl    | string     | ??  | URL?澆?                                | 蝮桃?URL |
| stock           | number     | ??  | >=0, ?湔                              | 摨怠??賊? |
| stockStatus     | string     | ??  | enum: ['in_stock', 'low_stock', 'out_of_stock'] | 摨怠????|
| unit            | string     | ??  | ?憭?0摮?                              | 閮??桐? |
| preparationTime | number     | ??  | >=0, ?湔                              | 皞???(??) |
| isRecommended   | boolean    | ??  | true/false                             | ?臬?刻 |
| isSpecial       | boolean    | ??  | true/false                             | ?臬?寥 |
| isActive        | boolean    | ??  | true/false                             | ?臬? |
| displayOrder    | number     | ??  | >=0, ?湔                              | 憿舐內?? |
| availableOptions| array      | ??  | ????抒?賊?蝯拐?                       | ?舫?賊?蝯?|
| nutritionInfo   | map        | ??  | ?剃alories, protein, carbs, fat蝑?雿?| ???? |
| tags            | array      | ??  | 摮銝???                                | 璅蝐 |
| createdAt       | timestamp  | ??  | Firestore Timestamp?澆?                | ?萄遣?? |
| updatedAt       | timestamp  | ??  | Firestore Timestamp?澆?                | ?湔?? |

**?孵亦?鈭?嚗?*

1. **摨怠?(`stock`)甈???蝝?**嚗?
   * 隤芣?嚗`stock` 甈????`number`??
   * 蝝?嚗?????閬摨怠蝞????`stock` 甈?敹?摮其箔??鞎?詻?????⊿??????⊿?摨怠?蝞∠?嚗??閰???豢?銝剖臭?*銝???* `stock` 甈?嚗???`stock` 甈??潛 `undefined`?蝟餌絞冽炎亙澈?????`stock` 甈?銝??冽???`undefined`嚗?閬?⊿?摨怠???

2. **???賊?蝯?`availableOptions`)甈?蝯?**嚗?
   * 隤芣?嚗`availableOptions` 甈??臭????`Array`)嚗??脰府???臭??豢??摰Ｚˊ??賊?蝯?
   * ?????蝯?嚗?????臭??拐辣?蝯?憒?嚗?
     ```typescript
     {
       id: string;           // ?賊?蝯ID嚗? "sugar_level"
       name: string;         // ?賊?蝯?蝔梧?憒?"?摨"
       required: boolean;    // ?臬血
       multiSelect: boolean; // ?臬?舀?憭
       minSelect: number;    // ?撠???
       maxSelect: number;    // ?憭???
       choices: [            // ?舫???
         {
           name: string;     // ?賊??蝔梧? "??"
           value: string;    // ?賊??潘??航??蝔?詨?嚗?
           additionalPrice: number; // 憿??對?閮剔0
           isDefault: boolean; // ?臬?粹?閮剝??
         }
       ]
     }
     ```

3. **閮桐葉????*嚗?
   * ?刻??桅???`OrderItem`)銝哨?`options` 甈?閮?鈭摰?嗅祕????賊?嚗?瑽?銝?
     ```typescript
     {
       optionId: string;     // ?賊?蝯ID嚗??menuItem.availableOptions[].id
       optionName: string;   // ?賊?蝯?蝔梧?撠?menuItem.availableOptions[].name
       value: string;        // ??貊??潘?撠?menuItem.availableOptions[].choices[].name
       additionalPrice: number; // 閰脤??憿??寞
     }
     ```

4. **蝭?**嚗?
   * ???銝剖?蝢拙?賊??
     ```json
     "availableOptions": [
       {
         "id": "sugar_level",
         "name": "?摨",
         "required": true,
         "multiSelect": false,
         "minSelect": 1,
         "maxSelect": 1,
         "choices": [
           { "name": "?函?", "additionalPrice": 0, "isDefault": true },
           { "name": "??", "additionalPrice": 0 },
           { "name": "敺桃?", "additionalPrice": 0 },
           { "name": "?∠?", "additionalPrice": 0 }
         ]
       },
       {
         "id": "toppings",
         "name": "??",
         "required": false,
         "multiSelect": true,
         "minSelect": 0,
         "maxSelect": 3,
         "choices": [
           { "name": "??", "additionalPrice": 10 },
           { "name": "璊唳?", "additionalPrice": 10 },
           { "name": "??", "additionalPrice": 15 }
         ]
       }
     ]
     ```
   * 閮桐葉????豢?嚗?
     ```json
     "options": [
       { "optionId": "sugar_level", "optionName": "?摨", "value": "??", "additionalPrice": 0 },
       { "optionId": "toppings", "optionName": "??", "value": "??", "additionalPrice": 10 }
     ]
     ``` 

