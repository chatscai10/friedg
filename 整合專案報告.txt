這份報告書將整合您提供的來源資料，包含對系統核心理念、技術架構、各功能模組的詳細描述、安全性考量、部署維運建議、已知的問題與風險，以及未來的擴展規劃。這份報告的目標是讓任何僅閱讀這份報告的新公司，都能清晰地理解整個專案的需求與功能全貌。

以下是根據您的要求和提供的資料，為您整理的完整專案技術開發報告書：

---

**「吃雞排找不早」POS 與後台管理系統 - 專案技術開發報告書**

**日期：** 2024 年 05 月 30 日

**文件版本：** V1.0

**來源文件依據：** 本報告書係根據多份專案規劃與技術文件整合編寫而成，包含：
*   全方位 POS 系統模組分析與設計
*   不早 脆皮雞排 線上訂餐 (部分內容)
*   已貼上文字 (技術規格書草稿、問題修復記錄、版本與技術棧建議等)
*   炸雞排POS後台系統簡報

---

**1. 專案概述 (Project Overview)**

**1.1. 專案核心理念與目標**

本專案的核心理念是打造一套不僅能處理訂單，更能驅動成長、增加營收、優化顧客關係、降低營運成本的「全方位、高度客製化智慧餐飲解決方案」。目標是成為店家的「經營大腦」與成長夥伴。系統設計採用 **多租戶 (Multi-Tenant) SaaS 架構**，為眾多獨立店家（租戶）提供服務。其核心策略是提供媲美高階付費系統的質感與深度功能，但以 **免費註冊使用** 作為核心，吸引廣大用戶基礎，再透過增值服務與平台營運獲利。系統需具備高度靈活性與擴展性，以適應各行各業的需求，並確保租戶擁有高度的自主設定權。即使在無專用硬體（如出單機）的環境下，也能流暢使用。

專案具體目標包括：
*   提升營運效率：自動化與數位化日常營運流程（打卡、排班、叫貨、薪資計算等）。
*   實現數據整合與透明：集中管理多來源數據（訂單、庫存、銷售、績效、評價等），提供決策支援。
*   強化內部管理：標準化員工、流程、庫存與溝通管理。
*   改善內部溝通：提供公告、知識庫、投票等工具。
*   支援行動操作：員工主要功能應可在手機上完成 (透過 PWA)。
*   建立激勵機制：明確獎金與晉升管道。
*   優化人力資源：支援手動及自動排班。

**1.2. 專案範圍**

本系統涵蓋的主要功能模組與範圍如下：
*   超級管理後台 (Super Admin)
*   租戶後台 (店家管理後台)
*   線上點餐 & 會員中心 & 租戶探索平台
*   線下點餐模組 (員工端 - PWA)
*   身份認證、職位與權限管理
*   GPS 定位打卡系統
*   庫存管理系統 (月度盤點與內部叫貨)
*   排班與請假系統
*   銷售回報系統
*   薪資與獎金系統
*   績效考核、提升與降級系統
*   顧客評價系統
*   內部溝通系統 (公告、知識庫、投票)
*   系統管理功能 (審核、參數設定、日誌、基本分析)
*   取餐編號管理模組
*   硬體周邊整合模組 (雲端出單模式)
*   推薦註冊與自動獎勵機制
*   廣告投放與管理系統
*   租戶探索平台
*   系統安全框架

**本系統目前範圍外 (Out of Scope) 的項目包括**：
*   完整的即時進銷存管理 (目前僅含內部叫貨與月度盤點，不含成本計算)。
*   完整的顧客關係管理系統 (CRM)。
*   完整的線下 POS 硬體整合 (專注於 PWA 和雲端出單模式)。
*   全面的財務會計系統整合。
*   原生行動 App 開發 (目前主要為 Web App / PWA)。
*   詳細的高階數據分析儀表板 (目前提供基本數據查看及與薪資/績效相關的指標)。

**1.3. 目標使用者**

系統服務於以下幾類使用者：
*   **服務商/超級管理員 (Super Admin):** 擁有最高權限，管理所有租戶、全局設定、平台廣告與推薦系統等.
*   **租戶管理員 (店家管理員)/分店經理:** 管理其所屬店家的員工、菜單、訂單、查看報表等.
*   **分店員工/夥伴:** 處理日常點餐、接單、出單、打卡、排班、查看薪資等.
*   **顧客:** 線上點餐、查看訂單、管理會員資料、提交評價、在探索平台尋找店家.

**1.4. 文件目的**

本報告書旨在明確定義系統的架構、技術選型、開發標準、API 規範、安全要求、部署維運策略及已知風險與未來規劃。作為開發團隊的共同依循準則，確保專案品質、一致性與可維護性。這份報告特別著重於提供足夠的細節與注意事項，使新的開發團隊能夠順利接手專案。

---

**2. 架構設計 (Architectural Design)**

**2.1. 宏觀架構**

系統採用基於 Firebase 的 **無伺服器 (Serverless)** 和 **多租戶 (Multi-Tenant) SaaS 架構**。
*   **前端 (PWA):** 部署於 Firebase Hosting，處理使用者介面與互動邏輯。透過 Firebase Client SDK 與後端服務溝通。
*   **後端 (Firebase Functions):** 提供業務邏輯 API，處理第三方服務整合（金流、外送、通知）、執行身份驗證輔助（LINE Login Token 交換）、執行排程任務與背景任務。本專案將全面採用 Cloud Functions **第二代 (2nd gen)** 進行開發與部署，利用其並行處理能力降低冷啟動和延遲。
*   **資料庫 (Firestore):** 儲存所有結構化數據，如訂單、用戶、菜單、分店資訊等。強調 **共享資料庫、共享 Schema，並透過強制 TenantID 或 StoreID 過濾** 來實現多租戶資料隔離。
*   **身份驗證 (Authentication):** 主要整合 LINE Login，透過 Cloud Function 產生 Firebase 自定義 Token 進行驗證。員工可能使用 Email/Password 或其他方式（待定義）。Firebase Authentication 儲存用戶基本身份資訊並與 LINE 帳號綁定。
*   **訊息推送 (Cloud Messaging):** 用於向前端 PWA 或透過 Cloud Functions 觸發向 LINE/Telegram 發送即時通知。

**宏觀架構圖** (概念示意，詳細請參考來源文件)：
[顧客/員工 PWA @ Firebase Hosting] <--> [Firebase Client SDK] <--> [Firebase Services]
                                                    |/|\
                                                    | | (Auth, Firestore, FCM)
                                                    +---------------------> [Firebase Cloud Functions v2] <-------+
                                                    (API Logic, Node.js 20) |
                                                                            |
                                                    +-------------------------+-------------------------+
                                                    |                         |                         |
                                                [LINE Pay API] [Delivery Platform API] [Notification API]
                                                (Uber Eats, Foodpanda) (LINE Notify, Telegram)


**2.2. 前端架構 (PWA)**

*   **技術：** 標準 HTML/CSS/JavaScript。目前未指定特定前端框架 (如 Vue, React)。
*   **核心功能：** Service Worker 實現離線快取與 PWA 安裝，Manifest file 定義應用程式特性。
*   **Firebase 整合：** 必須使用 Firebase Client SDK v9.x.x (Compat) 版本，且所有引入的 SDK 組件必須使用完全相同的版本號 (目前建議 v9.22.2)。長期規劃遷移至 v9+ 模組化 SDK (建議 v11.6.1+) 以減小打包體積。
*   **UI/UX：** 介面與操作流程需高度直觀且可配置 (尤其線下點餐模組)。注重響應式設計 (RWD) 與視覺回饋。**一個關鍵風險是缺乏 UI/UX 設計稿**，可能導致後期大量調整。

**2.3. 後端架構 (Firebase Functions)**

*   **技術：** Node.js 20 LTS。使用 Cloud Functions for Firebase (第二代 - 2nd gen)。
*   **觸發器類型：** HTTPS 觸發器用於 API 請求；Authentication 觸發器用於用戶創建初始化；Pub/Sub 觸發器和 Cloud Scheduler 觸發器用於處理定時任務或異步批次任務。
*   **部署策略：** 建議將功能相關的函數組織在不同的檔案中。考慮將高度獨立或資源需求不同的功能部署為獨立的 Function Group。必須在 asia-east1 (彰化) 或 asia-northeast1 (東京) 地區部署函數，以降低延遲。
*   **冷啟動優化：** 設定合理的記憶體 (至少 256MB)。若預算允許，可設定最小實例數 (Minimum Instances) 保持函數實例活躍。避免在全局範圍內執行耗時操作。利用打包工具進行 Tree Shaking。

**2.4. 資料庫設計 (Firestore)**

*   **類型：** Firestore (NoSQL)。
*   **設計原則：** 採用共享資料庫、共享 Schema。所有敏感或租戶特定的數據必須包含 TenantID 或 StoreID 欄位，並在所有讀寫操作中強制進行過濾，確保數據隔離。需根據預期查詢模式定義必要的複合索引 (firestore.indexes.json)。
*   **限制與注意事項：** Firestore 不支援複雜的 Join 或大量聚合運算。一次查詢的返回筆數與大小有限制 (1MB)。單文件寫入頻率有限制。這些限制需要在設計時透過資料結構優化 (如適當重複儲存、建立複合索引) 或將複雜計算轉移到後端批次處理來克服。

**2.5. 外部整合 (Integrations)**

系統需要整合多個外部服務：
*   外送平台：Uber Eats API, Foodpanda API (或 Webhook 模擬)。
*   金流：LINE Pay API。
*   通知：LINE Notify, Telegram Bot API, Firebase Cloud Messaging (FCM)。
*   LINE Login (LIFF SDK)。
*   LINE Messaging API (Webhook) - 可能用於接收顧客評價.

**注意事項：** 第三方服務依賴可能受其 API 配額限制或延遲影響。需考慮請求緩存、錯誤重試與過載保護機制。

---

**3. 技術標準與規範 (Technical Standards & Specifications)**

為確保專案一致性、可維護性與穩定性，需嚴格遵循以下標準：

**3.1. 版本控制與依賴管理**
*   **版本統一：** 所有頁面必須使用相同版本的 Firebase Client SDK (建議 v9.22.2 Compat 短期統一，長期規劃 v9+ Modular SDK v11.6.1+)。所有頁面必須使用相同版本的 LIFF SDK (建議 2.21.4 或當時最新穩定版)。SDK 版本更新必須經過完整測試並同步更新所有頁面。
*   **後端 SDK 版本：** Firebase Admin SDK 建議使用最新的穩定主版本 (v13.x+)。Cloud Functions V2 SDK。
*   **Node.js Runtime：** 統一使用 Node.js 20 LTS。
*   **NPM 套件管理：** 強制使用並提交 package-lock.json 到版本控制系統 (Git)。這對於確保不同環境下依賴版本一致性**極其重要**。
*   **Firebase CLI：** 使用最新的穩定版 (v12+)。
*   **Container Base Image (如用於 Cloud Run):** 若未來導入 Cloud Run，建議使用 node:20-slim 或 node:22-slim 與 Node.js Runtime 一致.

**3.2. 編碼風格與文件**
*   **編碼風格：** 遵循一致的 JavaScript 函數命名和宣告風格指南 (docs/coding-style-guide.md)。建議使用 ESLint 搭配 Prettier 進行自動檢查與格式化。
*   **文件與註解：** 為複雜邏輯、函數用途、參數、返回值添加適當的 JSDoc 註解。技術規格書、API 規格、安全規則說明、索引定義等文件需隨開發進度及時創建和更新。

**3.3. 開發實踐**
*   **集中初始化：** 將 Firebase 和 LIFF 的核心初始化邏輯分別集中到專用文件。使用 Promise 或 async/await 確保服務在使用前已完成初始化，**嚴禁使用 setTimeout 輪詢**。
*   **後端優先：** 涉及權限、計算、狀態變更、數據驗證的核心業務邏輯必須放在 Cloud Functions 中處理。不能僅依賴前端或 Firestore Rules 進行權限控制。
*   **數據隔離：** 所有後端數據訪問必須包含並正確使用 TenantID/StoreID 過濾。
*   **原子操作：** 對於需要多步驟更新的操作，應考慮使用 Firestore Transaction 確保原子性。
*   **錯誤處理：** Cloud Functions 內部需妥善處理各種預期和非預期錯誤，並返回有意義的回應或日誌。

---

**4. 功能模組詳述 (Detailed Functional Modules)**

本節將詳細說明專案的各個功能模組，包括其目標、主要功能、邏輯要點，並標示已知的重要待辦事項或缺失的核心邏輯。

**4.1. 超級管理後台 (Super Admin)**
*   **目標：** 提供 POS 服務商中央平台，管理多租戶系統、監控營運、設定全局規則、管理租戶，並全面控制廣告系統、推薦系統與基礎通知設定。
*   **權限：** 最高系統權限，僅限服務商。
*   **主要功能：** 租戶管理（列表、狀態、資源用量、啟用/停用、模擬登入-需嚴格控管）、方案與計費管理（定義方案/層級、功能模組啟用狀態、預設資源限制）、全局設定與公告、功能開關 (Feature Flags)、廣告系統管理（全局開關、租戶狀態、版位、排行榜位置售賣管理）、推薦系統管理（激活條件規則設定-含用戶下單數、獎勵規則設定）、租戶探索平台管理（設定付費排行榜規則、管理精選店家、審核店家公開資訊）、系統監控與分析（含廣告、通知、背景任務、跨租戶匿名化趨勢分析）、安全與日誌（含超級管理員操作稽核）。
*   **技術選型：** 安全的 Web 應用程式框架。

**4.2. 推薦註冊與自動獎勵機制**
*   **目標：** 激勵推廣，降低獲客成本，提高新用戶（租戶）活躍度，自動化獎勵發放。
*   **運作流程：** 推薦碼生成 -> 新用戶註冊輸入推薦碼 -> 驗證與綁定關係 -> **激活條件追蹤 (可配置)：** 例如完成註冊+上架 N 個商品，或完成註冊+獲得至少 M 位獨立顧客透過系統成功下單 (條件 B 新增)。Super Admin 可設定當前有效的激活條件。-> **獎勵觸發與執行** (達到推薦數 -> 自動提升資源限額 / 解鎖功能 / 延長服務期)。
*   **數據模型概念：** Tenants, Plans, TenantLimits, ReferralCodes, ReferralUsages (含 activated_at 欄位), ReferralRules (activation_type, activation_threshold)。

**4.3. 廣告投放與管理系統**
*   **目標：** 為平台創造額外營收，提供靈活配置，允許租戶付費去廣告。
*   **運作流程：** 版位定義 -> 廣告設定 (Super Admin) -> 廣告請求 (Frontend) -> 廣告決策 (Backend) -> 廣告渲染 (Frontend) -> 成效追蹤。
*   **廣告類型與位置 (範例)：** 顧客端 (橫幅、插入式、待機畫面)、員工端 (登入頁、儀表板底部 - **極謹慎**)、租戶後台。廣告載入需非同步，確保不影響核心效能。
*   **獲利模式：** 去廣告訂閱、廣告版位銷售。
*   **重要注意事項：** 使用者體驗 (UX) 與初期關閉策略、效能考量。

**4.4. 線下點餐模組 (員工端 - PWA)**
*   **目標：** 提升效率，減少錯誤，利用 PWA 實現離線操作，介面與操作流程需高度直觀且可配置。
*   **外觀設計：** 大按鈕、觸控優化。**允許租戶自訂常用功能快捷鍵與佈局**。離線/線上狀態指示。預留非干擾性廣告版位 (謹慎)。
*   **功能與邏輯：** **租戶感知與配置加載** (登入驗證 TenantID，加載該租戶的快捷鍵設定、功能開關)。開單與選桌。點餐操作 (含備註、套餐替換)。訂單管理 (暫存、送單、劃單、修改/取消-需權限+Log)。結帳操作 (含混合支付、折扣/招待-需權限+Log、發票、觸發評分機制)。**強化離線模式**。**詳細權限角色定義與管理**。**現金抽屜管理與班別結算**。提供訓練模式。**資源限制檢查** (調用後端 API 檢查 TenantLimits)。**出單** (發送至租戶指定的雲端印表機伺服器 API)。
*   **市場定位：** 核心基礎模組，穩定可靠、離線能力、高自訂性是賣點。

**4.5. 取餐編號管理模組**
*   **目標：** 清晰展示訂單狀態，提升取餐效率，**支援無實體螢幕的運作模式** (透過 LINE 通知顧客)。
*   **功能：** 系統顯示訂單狀態 (如製作中/已完成)。顧客可憑號碼或通知取餐。

**4.6. 會員系統模組 (Web + LINE Login)**
*   **目標：** 建立忠誠度，收集數據，精準行銷，整合評價，**提供豐富且可由租戶自訂的活動機制**。
*   **外觀設計：** 會員中心 (租戶可自訂部分外觀、顯示資料、優惠券列表)。預留廣告版位。
*   **功能與邏輯：** 會員綁定與登入 (LINE - **租戶獨立 Channel**)。點數計算與兌換 (租戶可設定規則)。訂單追蹤與歷史查詢。顧客評價系統整合 (Pull 模式)。會員分眾標籤管理。優惠券/兌換券系統 (租戶可定義券的類型與規則)。**自動化活動設定 (Campaign Management)**: 指定日期發放活動券、生日禮自動發送 (**租戶可設定**)。這些由後端任務定時觸發。
*   **重要注意事項：** 數據隱私與法規遵循 (PDPA)。非同步載入廣告元件。
*   **市場定位：** 核心價值模組，高度客製化是重要賣點。

**4.7. 硬體周邊整合模組 (雲端出單模式)**
*   **目標：** 確保 POS 能將列印任務發送至**租戶指定的雲端印表機伺服器**，**即使無印表機也能運作**。
*   **功能與邏輯：** 雲端印表機整合 (租戶後台配置 API URL, Key, 模板；POS 後端格式化數據並調用租戶指定 API)。響應處理與錯誤重試。**無印表機方案：** 若租戶未配置，系統應能正常運作，訂單透過 KDS/PWA 介面顯示，顧客憑證可為電子郵件、簡訊、或 PWA/會員中心查看 QRCode。
*   **市場評估報告：** 優勢在於簡化客戶端硬體、支援無印表機店家。劣勢是依賴雲端服務穩定性、網路。

**4.8. 庫存管理 (Inventory Management)**
*   **目標：** 協助店家進行基本的庫存追蹤與管理，特別是月度盤點與內部叫貨流程。
*   **功能與邏輯：** 按 TenantID 隔離數據。**月度盤點：** 提供每月盤點流程管理，產生待盤點清單，夥伴線上填報數量，系統計算差異並生成報告。**內部叫貨：** 門市向中央廚房/倉庫訂購流程管理，夥伴填寫叫貨單，系統傳送申請給物流審核，記錄歷史並允許錯誤回報。**租戶可選擇是否啟用原料級管理或僅管理成品庫存**。
*   **範圍外：** 不包含完整的即時進銷存管理或成本計算。
*   **市場定位：** 核心價值模組，提供彈性滿足不同管理深度需求。

**4.9. 進階報表與數據分析 (Reporting & Analytics)**
*   **目標：** 提供經營數據洞察，協助店家優化營運。
*   **功能與邏輯：** 按 TenantID 隔離數據。**租戶可自訂儀表板關注指標**。提供基本的銷售、庫存差異、薪資報表等。**待完善：** 目前僅提供基本數據查看，詳細的數據分析儀表板為範圍外或未來擴展項。需要實現後端獲取分析數據的邏輯。
*   **市場定位：** 核心價值所在，客製化儀表板提升體驗。

**4.10. 排隊叫號系統**
*   **目標：** 管理顧客排隊順序與叫號，提升服務效率。
*   **功能：** 支援按 TenantID 隔離。(詳細功能未在來源中展開，僅列為擴充模組)。

**4.11. 外送平台串接**
*   **目標：** 整合外送平台訂單與流程，減少人工操作，方便對帳。
*   **功能與邏輯：** 按 TenantID 隔離數據。租戶可在後台設定 API Key 等憑證。系統從外送平台匯入訂單。夥伴在系統中處理外送訂單（製作、出單、更新狀態）。支援取消/拒單並同步通知平台。記錄訂單金額、平台佣金等，供結算與對帳。
*   **整合方式：** 透過 API 或 Webhook 模擬。
*   **注意事項：** 依賴第三方服務的穩定性與 API 限制。

**4.12. 租戶探索平台 (Tenant Discovery Platform)**
*   **目標：** 面向終端消費者，展示平台上的店家，為租戶導流，創造額外營收。
*   **功能與邏輯：** **店家專頁：** 顯示店家詳細公開資訊（由租戶在後台維護）、菜單預覽、進行中的活動、營業時間、聯繫方式、線上點餐連結。**店家資料發布：** 租戶可在後台選擇是否發布資訊並維護公開資料。**搜尋功能：** 地理位置、關鍵字/分類、活動篩選。**排行榜機制：** 預設排序（距離、評價），提供「推薦排序」。租戶可透過後台購買排行榜曝光位置（付費曝光）。後端 API 需能安全查詢所有選擇公開的租戶資訊。
*   **獲利模式：** 透過廣告/排名費創造額外營收。
*   **市場定位：** 平台的增值服務，後期發展重點。需要足夠多租戶才有價值。

**4.13. 夥伴管理模組 (員工管理)**
*   **目標：** 統一管理人力資源相關功能，確保人員資料安全、權限分明。
*   **功能與邏輯：** **身份認證與登入：** 整合 LINE 登入作為夥伴身份驗證，初次登入需管理員審核。Firebase Authentication 儲存基本資訊並與 LINE 綁定。**基本資料管理：** 記錄個人與任職資訊，支援匯入/匯出。**職位與權限：** 建立清晰的 6 級職等體系。各職等對應不同系統權限範圍。管理員在後台管理權限角色。權限控制在前端與後端安全規則雙重實施。**夥伴招募與審核：** 新夥伴透過註冊提交申請，管理員後台審核，通過自動建帳號、指派職位/分店。**跨店分派：** 支援夥伴跨分店任職，允許選擇工作分店進行操作，資料按分店區隔。

**4.14. 排班管理模組**
*   **目標：** 提供每家分店的值班表安排與請假管理，確保門市人力配置合理。
*   **功能與邏輯：** **班表排定：** 支援手動與自動排班。管理者可手動排定或使用自動排班演算法。自動生成的班表可在調整確認後發布。**自動排班演算法為關鍵待辦事項**。**手動排班建議優化：** 考慮拖拽、實時反饋、批量操作、載入模擬草稿。**班表發布與通知：** 確認後發布至夥伴前端頁面，可透過 LINE Notify 通知。**請假申請與審批：** 夥伴提交申請，系統檢查禁休日期，管理員後台審批。批准/駁回後通知。**禁休日期管理：** 管理員設定禁休日期。前端需檢查並提示額外扣除，後端需再次驗證並計算額外扣除天數。**需明確假期餘額扣減的完整邏輯**。**調班與代班：** 支援調班申請 (需管理員核可)、臨時指派代班。**出勤預警：** 對於連續高工時或即將超時情況發出預警。

**4.15. 打卡考勤模組**
*   **目標：** 提供以 GPS 定位為基礎的上下班打卡功能，精確記錄出勤。
*   **功能與邏輯：** **GPS 定位打卡：** 夥伴須在分店附近一定範圍內 (地理圍欄) 才能打卡。記錄時間戳與位置。**自動狀態判定：** 根據班表與打卡時間判定準時、遲到、早退、加班。遲到/早退通知管理員。未打卡標記缺勤。提供打卡提醒。**跨店打卡：** 支援跨店支援夥伴選擇當前工作分店後打卡。**漏打卡補登：** 夥伴提交補登申請，經管理員審核通過後補入記錄並標註「補登」。**出勤報表與整合：** 提供打卡資料報表，用於薪資計算和考勤分析。

**4.16. 銷售回報系統**
*   **目標：** 為尚未完全導入 POS 或需要人工校正情境提供銷售數據回報機制。
*   **功能與邏輯：** 分店每日營業結束可提交標準化銷售數據表單。支援自定義欄位。數據集中供財務與營運分析使用。夥伴可在員工頁面提交銷售資料。管理員可在管理頁面檢視銷售數據。

**4.17. 薪資與獎金系統模組**
*   **目標：** 評估夥伴表現並計算薪資獎金，激勵團隊。
*   **功能與邏輯：** **績效指標紀錄：** 自訂多維度指標 (銷售額、評價、出勤率等)，自動累積。管理者後台查看指標達成情況。**獎金任務：** 配置不同類型獎勵方案（條件、對象、獎金），達成條件自動計入獎金帳戶。支援可配置化獎金任務。獎金評估可由自動定時任務觸發。**薪資計算整合：** 每月根據底薪、出勤、績效、獎金等自動計算薪資。生成薪資報表。夥伴可查看個人薪資明細及獎金累計。**核心修正重點：** 需實現核心計算邏輯。**獎金評估** (evaluateBonusTasksScheduled, checkSingleCondition) 需讀取相關數據並判斷條件。**薪資計算** (calculatePayroll) 需讀取所有相關數據計算並寫入。

**4.18. 績效考核、提升與降級系統模組**
*   **目標：** 提供公平的績效評估與職位調整機制。
*   **功能與邏輯：** **績效評估體系：** 建立多維度評估體系。**晉升與降級：** 提供流程管理。支援自動觸發投票 (如實習生轉正服務滿一定時間)。支援全員投票表決。支援老闆直接指派/投票降級流程。結果記錄並更新夥伴職位。夥伴可參與績效評審與投票。**核心後端邏輯待實現**。

**4.19. 顧客評價機制模組**
*   **目標：** 收集顧客對服務與產品的反饋，作為內部改進和夥伴績效參考。
*   **功能與邏輯：** **LINE Bot 問卷：** 消費後透過 LINE Notify 發送問卷收集評分與意見 (需顧客同意)。評價匿名儲存，關聯訂單和服務夥伴。**外部評價匯入：** 支援手動輸入或連結匯入 Google評論、Uber Eats 評分等。**評價展示與告知：** 在員工端展示去識別化評價。管理員可表揚或關注差評。**績效掛鉤：** 評價影響夥伴績效指標一部分。評價採匿名且短期不對個人公開，僅管理層可查詳情。建立申訴機制。**核心修正重點：** 需設計 LINE Bot 的具體互動流程及 lineWebhook 的詳細邏輯。

**4.20. 內部溝通模組**
*   **目標：** 促進內部資訊傳播、知識分享與意見收集。
*   **功能：** 提供公告發布與管理、知識庫 (含測驗/補習班功能) 維護、投票系統 (用於晉升/降級/一般決策)。夥伴可在員工頁面查看公告、知識庫，參與投票。管理員可在管理頁面發布與管理內容。

**4.21. 系統管理功能**
*   **目標：** 提供管理員配置、監控、審核的集中入口。
*   **主要功能：** **審核中心：** 集中處理各模組待審核項目 (請假、補卡、獎金、晉升/降級等)。**參數設定：** 集中管理各模組設定參數 (存於 settings, system_config)。例如分店 GPS 範圍、薪資計算參數、獎金規則、禁休日期等。**核心修正：** **必須解決配置來源衝突** (確保單一入口)，**需明確並改進參數保存邏輯**，**必須補全未實現的參數加載函數**。落實 Firestore Rules (僅高 Level 管理員可寫)。**系統監控：** 查看操作日誌、接收即時通知 (如透過 Telegram)。基本分析數據檢視。手動輸入外部平台評價分數。**操作日誌記錄為待實現的核心後端邏輯**。

---

**5. 系統安全框架 (System Security Framework)**

安全性是 SaaS 服務的基石，尤其涉及交易和客戶數據，必須達到企業級安全標準。這是一個跨模組的框架，其原則和措施需應用到所有其他模組的開發和部署中。

**5.1. 核心原則**
*   深度防禦、最小權限、安全左移 (開發早期介入)。

**5.2. 主要安全措施**
*   **身份驗證 (Authentication):** 強密碼策略、(可選) MFA for 管理員。安全的 Session / JWT Token 管理。LINE Login 整合安全 (驗證 State, 安全處理 Callback)。依賴 Firebase Auth 監聽狀態，禁止使用 sessionStorage 或 localStorage 儲存敏感數據。定期驗證 LIFF 配置有效性。
*   **授權 (Authorization):** 實施基於角色的權限控制。**Firestore 安全規則 (Firestore Rules) 為極高優先度**。為所有 Collection 設計嚴謹讀寫規則，使用 request.auth.uid 和權限等級驗證，遵循最小權限原則。**所有 Cloud Functions 內部必須對調用者的權限進行再次驗證**。關鍵數據操作應同時通過 Firestore Rules 和 Cloud Function 內部邏輯的權限檢查。數據隔離需確保規則和函數邏輯能正確限制跨租戶數據訪問。**需提供 Firestore 安全規則的具體範例和測試計劃**。防止敏感資訊透過 API 洩漏。
*   **數據安全：** 敏感資訊加密存儲 (如：部分金鑰、密碼 Hash)。傳輸加密 (TLS/SSL)，所有前後端通訊強制使用 HTTPS。定期數據備份與加密。對第三方 API 呼叫使用安全憑證並存放於 Cloud Functions 環境變數或 Google Secret Manager。
*   **基礎設施安全：** 伺服器安全加固、防火牆設定 (WAF)。定期進行弱點掃描與修補。啟用 Firebase App Check 等機制避免非法請求。對於公開的 HTTPS 函數入口加入基本的頻率限制和 DDoS 防護。
*   **依賴管理：** 定期掃描第三方函式庫/框架的安全漏洞並及時更新。嚴格統一 SDK 版本。
*   **日誌與監控：** **詳細的操作日誌 (Audit Log)** 記錄所有重要操作 (登入、權限變更、數據修改、配置更改、廣告設定等)，包含時間、操作者 IP、操作內容。系統錯誤日誌。安全事件監控與告警，監控異常登入、權限錯誤、潛在攻擊，設定告警 (如透過 Telegram)。**操作日誌記錄為待實現的核心後端邏輯**。
*   **開發安全 (Security by Design):** 在需求分析和設計階段就考慮安全需求。開發人員安全意識培訓。程式碼安全審查 (Code Review)。**禁止硬編碼敏感資訊 (如密碼、金鑰)**。對來自客戶端或第三方服務的輸入進行嚴格驗證和清理，防止注入攻擊 (XSS, NoSQL Injection 等)。輸出到前端的數據需適當編碼防止 XSS。

**5.3. 整合方式**
這是一個跨模組的框架，其原則和措施需要應用到所有其他模組的開發和部署中。API 設計、資料庫操作、前端渲染、後台邏輯都需要遵守此框架。

**5.4. 風險與對策**
安全漏洞與攻擊是潛在風險。對策包括：定期安全掃描與滲透測試，驗證 Firestore 規則正確性 (使用模擬測試)，啟用 App Check，對公開 HTTP 函數入口加入頻率限制和 DDoS 防護。若發生資安事件，立即啟動應變流程。

---

**6. 部署與維運建議 (Deployment & Operations Recommendations)**

為確保系統順利上線並長期穩定運行，需規劃明確的部署與維運策略。

**6.1. 部署平台**
*   **前端：** Firebase Hosting。
*   **後端：** Firebase Cloud Functions V2。建議部署至 asia-east1 或 asia-northeast1 區域。

**6.2. 環境管理**
*   **必須** 區分開發 (Development) 和生產 (Production) 環境。建議使用獨立的 Firebase 專案。可考慮增加預備 (Staging) 環境用於最終驗收測試。

**6.3. 部署流程**
*   使用 Firebase CLI 手動部署。**建議建立 CI/CD Pipeline** 實現自動化部署，包含單元測試、整合測試、安全性檢查等步驟。前端部分可透過 CI/CD 自動部署至 Firebase Hosting。不同版本的前端可以使用不同子域名進行驗收測試。

**6.4. 版本升級策略**
*   系統採用模組化架構。建議使用語意化版本 (Semantic Versioning) 管理每個模組版本。未來功能更新應先在測試環境驗證再部署至正式環境。資料庫結構升級應撰寫遷移腳本或實現向下兼容讀取邏輯。緊急修復以小版本發佈。

**6.5. 監控與日誌**
*   利用 Firebase 控制台和 Cloud Logging 監控系統狀態、錯誤率、性能等。
*   定期檢視詳細操作日誌和系統錯誤日誌。
*   設定安全事件與異常情況的告警 (如透過 Telegram)。
*   維運時需區分租戶監控、廣告/通知/推薦/背景任務監控。

**6.6. 效能優化**
*   充分利用 Firestore 索引提升查詢速度。
*   運用快取機制減少不必要的重複請求 (前端本地快取菜單/設定檔，後端預計算報表結果)。
*   善用 Cloud Functions 的並行執行能力處理批次任務。
*   開啟 Cloud Functions 常駐實例 (最低暖機實例數) 減少冷啟動。
*   必要時提升 Cloud Function 記憶體配置或將模組拆分至獨立的 Cloud Run 服務進行水平擴充。

**6.7. 測試策略**
*   包含單元測試 (使用模擬器)。
*   整合測試 (測試前端與後端交互，跨模組流程，與外部服務整合)。需細化關鍵跨模組整合場景。
*   端對端測試 (模擬真實用戶場景)。需細化最關鍵的端到端流程。
*   **安全性測試：** **高優先度**。測試 Firestore Rules 和 Cloud Function 權限檢查的有效性。定期進行安全掃描與滲透測試。
*   使用者驗收測試 (UAT)：邀請不同職位/權限的真實用戶在生產前進行測試。
*   提供訓練模式。

**6.8. 資料庫備份與恢復**
*   需規劃 Firestore 定期備份機制 (如使用 Cloud Storage 或導出至備援資料庫)。
*   制定資料保留策略。
*   進行恢復測試計劃。

**6.9. 容錯與備援**
*   針對單點故障設計容錯方案 (如短期切換到本地緩存模式)。
*   維持一套傳統紙本流程或預載獨立 App 作為緊急備用方案。
*   在金流等關鍵節點加入人工介入警示。

---

**7. 已知問題與風險分析 (Known Issues & Risk Analysis)**

本專案在開發過程中已識別出多項潛在問題與風險，新的開發團隊需特別關注。

**7.1. 技術與架構層面風險**
*   **Cloud Functions 冷啟動延遲：** 在流量不連續時可能發生，影響即時響應。
    *   *對策：* 定時喚醒關鍵函式，啟用最低執行個體設定，將函式拆分為輕量觸發器/背景任務。
*   **第三方服務故障或響應延遲：** 外送、支付、通知服務問題可能導致業務中斷。
    *   *對策：* 設計重試機制和後備方案，關鍵節點加入人工介入警示，考慮使用中介服務統一處理外部整合。
*   **資料一致性與競態條件：** 分散式架構和離線功能可能導致資料同步不一致或衝突。
    *   *對策：* 善用 Firestore 事務機制與樂觀鎖，上線同步時檢查衝突並處理，重要數據使用後端批次校正。
*   **Firestore 用量及成本風險：** 高頻寫入/大量存儲可能超額產生費用。Firestore 配額限制 (如寫入次數)。
    *   *對策：* 合併寫入減少次數，定期監控用量並設置預警，優化資料保留策略 (歷史資料轉存)，根據使用情況調整索引/資料結構。
*   **Firestore 複雜查詢效能限制：** 大規模擴展時，複雜查詢受限可能成為挑戰。
    *   *對策：* 資料結構優化，建立複合索引，複雜計算轉移到後端批次處理。
*   **Node.js 單執行緒特性：** Cloud Functions 基於 Node.js，CPU 密集任務可能阻塞。
    *   *對策：* 拆分批次任務或使用雲端排程/背景任務函式。未來考慮 Serverless Containers (Cloud Run) 處理複雜/長時間任務。

**7.2. 開發與管理層面風險**
*   **缺乏 UI/UX 設計稿：** 是關鍵風險，可能導致後期大量介面調整成本高昂。強烈建議盡快取得關鍵介面設計稿。
*   **核心後端邏輯大量缺失或待完善：** 如自動排班演算法、請假扣減、獎金計算、操作日誌、分析數據獲取、審批流程實現等。這是開發的最高優先級。
*   **缺失 API 詳細規格文件：** 是關鍵待辦事項，不利於新團隊理解後端接口用途、參數、返回值和錯誤處理。需另外建立此文件。
*   **缺失 Firestore 安全規則的具體範例和測試計劃：** 是關鍵待辦事項，影響對數據訪問權限控制邏輯的理解和驗證。需提供具體範例。
*   **Firestore 複合索引未定義：** 關鍵待辦，影響查詢效能。需定義具體索引。
*   **系統參數設定的配置來源衝突與保存邏輯未解決：** 需要優先解決，確保配置管理的唯一入口和正確性。
*   **應用錯誤與當機：** Bug 可能導致前端當機，影響營運。
    *   *對策：* 強化測試 (單元、整合、E2E)，導入前端錯誤監控工具，提供緊急備用方案。

**7.3. 安全層面風險**
*   **安全漏洞與攻擊：** JWT 劫持、Firestore 規則配置錯誤、DDoS 等。
    *   *對策：* 定期安全掃描/滲透測試，驗證 Firestore 規則，啟用 App Check，對公開函數入口加入頻率限制和 DDoS 防護，建立資安事件應變流程。
*   **XSS 防護不足：** 用戶輸入內容未經處理直接渲染導致漏洞。
    *   *對策：* 前後端對所有輸入進行嚴格驗證和清理，輸出到前端的數據進行適當編碼。這需要全面覆蓋。

---

**8. 優化與擴展規劃 (Optimization & Expansion Plan)**

本系統已建立穩固基礎，未來可根據業務發展和技術演進進行功能優化與擴展。

**8.1. 短期優化 (Priority)**
*   **解決關鍵待辦事項與風險：** 優先完成缺失的核心後端邏輯、定義並測試 Firestore 安全規則與索引、解決參數配置衝突、建立詳細 API 規格文件。
*   **優化現有功能：** 根據市場評估報告和使用者反饋，提升核心模組的易用性與效能。例如線下點餐模組的高自訂性介面優化。
*   **強化安全防護：** 全面落實 XSS 防護、敏感資訊管理、後端權限檢查等措施。

**8.2. 未來擴展方向 (Future Expansion)**
*   **Kiosk 自助點餐：** 開發門市自助點餐觸控介面，重用現有 POS 邏輯，增加現場出單/螢幕叫號功能。可降低人力負擔，提升效率。
*   **進階數據分析與商業智慧：** 導入 BI 工具 (如 Google Data Studio, Tableau)，將數據匯入數據倉庫 (如 Google BigQuery) 進行大規模分析。應用機器學習模型進行銷量預測、顧客流失預測、排班優化。將決策從經驗轉向數據驅動。
*   **會員儲值與電子錢包：** 在會員系統基礎上增加儲值功能，提高顧客黏著度。需嚴謹金流管理並符合法規。
*   **更多外部平台串接：** 擴展串接更多外送平台、行動支付選項 (如街口支付、Apple Pay)、政府電子發票/報稅系統、社群媒體/評論平台 API。
*   **多語言與海外展店支持：** 加入國際化 (i18n) 支援，適配不同時區、貨幣、當地會計制度和隱私法規。
*   **SaaS 平台化：** 長遠目標，將現有架構升級為成熟的多租戶 SaaS 產品對外提供。需加強超級管理後台、租戶自助開通/配置流程、嚴格租戶數據隔離、計費計量模組等。

**8.3. 技術演進考量**
*   持續評估並採用 Firebase Cloud Functions V2 的新功能與優化。
*   考慮導入 Serverless Containers (如 Google Cloud Run) 處理需要更靈活性或特定環境依賴的模組。
*   持續監控並更新所有使用的 SDK 和第三方依賴，獲取安全更新和性能改進。

---

**9. 總結與後續步驟 (Conclusion & Next Steps)**

本報告書基於現有資料，詳細闡述了「吃雞排找不早」POS 與後台管理系統專案的核心概念、技術架構、功能模組、安全性要求、部署維運建議、已知風險與未來擴展規劃。這份文件旨在提供足夠的廣度和深度，使任何新的開發團隊能夠快速全面地了解專案，並具備接手的能力。

為了讓新團隊能夠更順暢地接手並完成剩餘部分，以下文件和工作是最高優先級的待辦事項：
1.  **完成 API 詳細規格文件：** 針對所有後端 Cloud Functions API，詳細記錄其用途、HTTP 方法、請求 URL、輸入參數格式與範例、成功響應結構與範例、錯誤碼與錯誤訊息規範。
2.  **定義並測試 Firestore 安全規則：** 編寫完整的 firestore.rules 文件，並提供詳細說明和測試範例，確保所有 Collection 的讀寫權限都得到嚴格控制和驗證。強烈建議使用 Emulator Suite 進行徹底測試。
3.  **定義 Firestore 複合索引：** 根據預期查詢模式，在 firestore.indexes.json 中定義所有必要的複合索引。
4.  **補齊缺失的核心後端邏輯：** 優先實現標記為「關鍵」或「核心修正重點」的 Cloud Functions，特別是薪資計算、獎金評估、請假扣減、操作日誌記錄、審批流程後端實現、分析數據獲取、LINE Bot 評價處理等。
5.  **解決系統參數配置的衝突與保存邏輯問題：** 確保參數設定有唯一可靠的入口和保存機制。
6.  **落實全面的安全性措施：** 特別是輸入驗證、輸出編碼 (XSS 防護)、敏感資訊管理 (使用 Secret Manager 或環境變數)、後端權限檢查等，並進行安全性測試。
7.  **產出關鍵介面的 UI/UX 設計稿：** 即使是線框圖，也能極大幫助前端開發，減少返工。
8.  **建立 CI/CD Pipeline：** 自動化測試與部署流程。
9.  **規劃詳細的部署與維運策略：** 包含環境管理、監控告警、資料備份與恢復計劃。

完成上述事項後，專案將具備更清晰的開發方向、更穩定的架構和更可靠的基礎，為後續的功能完善與擴展奠定堅實的基礎。







---

# 📄 專案目標與範疇補齊版（可直接進入開發）

---

## 1. 專案核心目標（SMART 版）

| 項目 | 說明 |
|:---|:---|
| 目標 (Specific) | 建立一套可同時服務內用、外帶、外送線上點餐的「POS點餐+後台管理系統」，並整合員工、薪資、排班、考勤、評價、會員、獎金、庫存管理於一體，且支援無印表機環境的出單。 |
| 可衡量 (Measurable) | 完成系統開發後，90%分店能以本系統成功運營三個月以上、顧客訂單錯誤率降低20%、員工管理效率提升30%、營收資料整合達100%。 |
| 可達成 (Achievable) | 運用 Firebase 全雲端部署+PWA方式，後端 Functions 模組化設計，前端無需安裝 App 也能使用，實際可於三個月內開發初版 MVP。 |
| 相關性 (Relevant) | 完全支援品牌「不早脆皮雞排」現有與擴展中的多分店營運模式，並預留多租戶 SaaS 擴充機制。 |
| 時限 (Time-bound) | 2025 年 8 月完成內部 Beta 版上線，2025 年 10 月正式推向全部分店使用。 |

---

## 2. 交付成果物（Deliverables）

- **前端 PWA 系統（POS點餐端+員工操作端+管理後台端）**
- **後端 API 系統（Firebase Cloud Functions V2）**
- **Firestore 資料庫結構（含索引）**
- **LINE/LINE Pay 整合模組**
- **外送平台 API 整合模組（Uber Eats, Foodpanda）**
- **操作日誌系統與安全性設計文件**
- **完整部署腳本與環境設定檔**
- **使用者操作手冊（簡易版）**
- **技術開發手冊（API, Rules, Data Model）**
- **訓練資料：管理端操作教學、員工端點餐教學**

---

## 3. 專案範疇（In Scope）

✅ POS 點餐模組（PWA）  
✅ 員工登入、打卡、排班、請假管理  
✅ 銷售資料登錄、出單、結帳（支援現金+LINE Pay）  
✅ 出單機雲端列印（若有印表機）、若無印表機則顯示在螢幕  
✅ 會員系統（LINE Login快速綁定）  
✅ 顧客評價機制（LINE通知問卷）  
✅ 庫存基本管理（內部叫貨、月度盤點）  
✅ 夥伴（員工）獎金、薪資計算模組  
✅ 顧客線上訂餐（前台）  
✅ 後台管理系統（店長/分店經理操作）  
✅ 系統管理後台（超級管理員操作）  
✅ 廣告版位管理（內部廣告）  
✅ 推薦碼/推廣註冊獎勵機制  
✅ 簡易報表與儀表板（銷售、出勤、庫存異常）  
✅ 離線運作支援（PWA緩存菜單/訂單草稿）

---

## 4. 非範疇（Out of Scope）— 特別標明！

❌ 不開發原生 App（Android/iOS 版 App）  
❌ 不實作完整 ERP / 進銷存管理（只做月度叫貨+盤點）  
❌ 不整合財會會計系統（例：出總帳、稅務申報）  
❌ 不內建客服系統（LINE群組溝通另案處理）  
❌ 不直接串接政府稅務電子發票（台灣統一發票平台）  
❌ 不支援除 LINE 以外的社群整合（如 FB Messenger、IG等另案）  
❌ 不做客製化每個租戶的樣式主題（僅支援標準版主題）  
❌ 不支援跨國貨幣多幣結帳（初版台灣新台幣）  
❌ 不支援異常高度客製化 API 整合（Uber/Foodpanda以標準API模組整合）

---

## 5. 關鍵績效指標（KPI）

- 90%以上分店導入三個月後無需回退舊系統
- POS訂單完成錯誤率下降 20%（以日訂單比錯單統計）
- 排班、打卡、薪資資料集中度達 95% 以上
- 顧客完成訂餐後回填評價率達 30%
- 整體營收報表自動化準確率達 99%

---






---

# 📄 使用者角色定義（User Roles）

| 角色名稱 | 說明 | 核心權限範圍 |
|:---|:---|:---|
| 超級管理員 (Super Admin) | 系統平台管理者，負責租戶（店家）管理、系統參數設定、廣告與推薦規則管理。 | 可進行所有租戶的模擬登入、參數設定、審核管理、廣告設定、推薦系統設定、營運監控。 |
| 租戶管理員 (Tenant Admin / 店長) | 各分店管理者，負責本店營運與員工管理。 | 員工管理、菜單管理、訂單管理、打卡管理、排班、公告、薪資獎金設定、資料分析查看。 |
| 分店員工 (Store Staff / 員工) | 主要負責現場接單、打卡、點餐、庫存操作。 | 打卡上下班、點餐接單、單據列印、排班查看、銷售資料提交、請假申請。 |
| 顧客 (Customer) | 使用線上點餐系統點餐與付款的終端消費者。 | 線上點餐、訂單查詢、付款、評價回饋、會員中心查看。 |

---

# 📄 使用案例定義（User Cases）

### 2.1 超級管理員的使用案例
- 登入超級後台管理系統
- 新增/編輯/停用租戶（店家）
- 查看租戶列表與使用狀況
- 設定全局功能參數（例如，打卡範圍、公休日）
- 管理推薦註冊獎勵規則
- 上架與排序廣告版位
- 查看營運總覽報表（跨租戶匯總）
- 查看與匯出各種操作日誌
- 設定系統公告（全平台性）
- 收到安全告警通知（如異常登入、過高流量）

---

### 2.2 租戶管理員（店長）的使用案例
- 登入租戶後台
- 查看每日/每月營收報表
- 管理分店菜單（新增、停售、設定價格）
- 指派員工與設定員工職位與權限
- 排班與調班管理
- 薪資獎金審核與修正
- 啟用/停用促銷活動（如生日優惠券）
- 發布門市內公告給員工
- 處理銷售異常或取消單
- 審核員工請假申請
- 審核補打卡申請
- 查看顧客評價記錄
- 自訂取餐叫號規則與螢幕顯示設定

---

### 2.3 分店員工（夥伴）的使用案例
- 使用LINE登入或員工帳號登入系統
- 打卡上下班（GPS定位）
- 查看排班表
- 接單、點餐、劃單、出單、取消訂單（需授權）
- 處理訂單付款（現金、LINE Pay）
- 填寫月度盤點表（庫存數量）
- 提交叫貨單（內部叫貨申請）
- 提交請假申請
- 申請補打卡
- 查看個人獎金累計、出勤紀錄
- 完成訓練課程與小考（知識庫功能）

---

### 2.4 顧客的使用案例
- 進入線上訂餐頁面
- 瀏覽菜單，選擇商品加入購物車
- 自訂商品選項（加料、去冰、加辣等）
- 選擇取餐時間與方式（外帶/內用）
- 完成付款（現金現場付款、或LINE Pay線上付款）
- 查看訂單進度（製作中、完成）
- 取餐通知（顯示取餐號碼或LINE提醒）
- 接收訂單完成後的評價問卷邀請
- 填寫評價（星等+文字）

---

# 📄 使用者角色 × 功能權限矩陣（Summary）

| 功能/角色 | 超級管理員 | 租戶管理員 | 分店員工 | 顧客 |
|:---|:---:|:---:|:---:|:---:|
| 登入系統 | ✅ | ✅ | ✅ | ✅（顧客端線上點餐） |
| 打卡上下班 | ❌ | ❌ | ✅ | ❌ |
| 點餐接單 | ❌ | ❌ | ✅ | ❌ |
| 排班管理 | ❌ | ✅ | 查看 | ❌ |
| 菜單管理 | ❌ | ✅ | ❌ | 查看 |
| 訂單管理 | ❌ | ✅ | ✅ | 查看 |
| 銷售/薪資報表 | ✅（匯總） | ✅（本店） | 查看個人 | ❌ |
| 顧客評價管理 | ✅ | ✅ | 查看個人 | 填寫 |
| 庫存管理 | ❌ | ✅ | 盤點/叫貨 | ❌ |
| 公告發布 | ✅（全平台） | ✅（分店內） | 查看 | ❌ |
| 推薦/廣告管理 | ✅ | ❌ | ❌ | ❌ |

---



# 📄 核心功能性需求補齊（以功能模組為單位）

---

## 3.1 員工打卡功能（GPS 定位打卡）

**功能描述**：
- 員工必須於排班時段開始前打「上班卡」，結束後打「下班卡」。
- 打卡時必須在分店設定的地理圍欄（Geo-fence）內，否則無法打卡。

**功能流程**：
1. 員工開啟員工端PWA → 按下【打卡】。
2. 系統取得使用者即時定位座標。
3. 驗證座標是否在允許範圍內（半徑設定值，如 50 公尺）。
    - **若在範圍內 → 顯示打卡成功畫面，紀錄時間與位置。**
    - **若不在範圍內 → 顯示錯誤：「未在可打卡範圍內」。**

**錯誤處理**：
- 定位失敗 → 提示「請開啟定位功能並重試」。
- 定位資料不完整 → 拒絕打卡並紀錄錯誤日誌。

**資料記錄**：
- 打卡類型（上班/下班）
- 打卡時間（timestamp）
- GPS座標（經緯度）
- 分店ID（StoreID）
- 員工ID（StaffID）
- 打卡結果狀態（成功/失敗）

---

## 3.2 線上點餐功能（顧客端）

**功能描述**：
- 顧客透過手機掃QR Code或直接連到線上訂餐網頁。
- 可以瀏覽菜單、下單、付款、追蹤訂單進度。

**功能流程**：
1. 顧客進入訂餐頁 → 瀏覽菜單。
2. 選擇餐點、選擇加料選項（如加起司/去冰/加辣）。
3. 加入購物車。
4. 結帳 → 選擇付款方式（現金、LINE Pay）。
5. 成功付款後，系統產生訂單並指定一組取餐號碼。

**錯誤處理**：
- 付款失敗 → 提示「付款失敗，請重試」。
- 菜單資料載入錯誤 → 顯示錯誤頁面並重試機制。
- 當餐點售完時，自動標記為「售完」不可點選。

**資料記錄**：
- 訂單編號（OrderID）
- 顧客ID（如果有登入）
- 餐點清單（Products）
- 金額（TotalPrice）
- 付款狀態（Pending / Paid）
- 訂單狀態（製作中 / 完成 / 已取消）
- 取餐號碼（PickupNumber）

---

## 3.3 排班管理模組

**功能描述**：
- 店長手動或系統自動排班。
- 員工可以查看自己的班表、申請請假或調班。

**功能流程**：
1. 店長登入後台 → 進入排班管理。
2. 選擇月份 → 指派每日班次與員工。
3. 發布班表 → 系統推播通知夥伴查看。
4. 員工可檢視自己的排班。
5. 請假申請 → 管理員審核。
6. 如有人請假，店長可重新指派或開放代班申請。

**錯誤處理**：
- 員工未完成排班確認 → 提醒並鎖定打卡功能。
- 請假超過禁休日 → 系統自動提醒「今日禁休」並需主管特別核可。

**資料記錄**：
- 班表（Schedule）
- 員工ID（StaffID）
- 排班日期
- 時段（開始/結束時間）
- 請假記錄（LeaveRequests）
- 代班記錄（SubstitutionRequests）

---

## 3.4 薪資與獎金結算系統

**功能描述**：
- 每月根據出勤紀錄、業績、獎金任務自動計算薪資。
- 店長可於後台審核並修正。

**功能流程**：
1. 每月月底，自動觸發薪資計算。
2. 根據員工職等、底薪、打卡紀錄、請假、銷售額等指標計算薪資。
3. 自動累積各類型獎金（銷售獎金、表現獎金、特殊活動獎金）。
4. 店長登入後台 → 薪資審核頁面 → 若需修正可編輯。
5. 確認發薪 → 系統鎖定該月薪資，員工可查看明細。

**錯誤處理**：
- 若資料不完整（如漏打卡） → 系統標記異常並警告需補登。

**資料記錄**：
- 員工ID（StaffID）
- 本月總出勤天數與小時數
- 獎金金額列表（SalesBonus, PerformanceBonus）
- 請假扣薪記錄
- 本月應領薪資（TotalPay）
- 核准與修改歷史紀錄（AuditLogs）





---

# 📄 非功能性需求完整規格

---

## 4.1 效能需求（Performance Requirements）

| 項目                           | 具體標準                                                         |
|--------------------------------|------------------------------------------------------------------|
| 頁面載入時間                   | 首頁與員工打卡畫面在正常4G網路環境下，首次載入小於3秒               |
| 同時使用者數（員工端）           | 支援每店同時30人操作（點餐、打卡、查詢排班）而不卡頓                  |
| 同時使用者數（顧客端）           | 支援每家店至少同時500筆線上訂單查詢或下單（PWA模式）                 |
| 後端API回應時間                 | 一般操作API（非批次作業）平均回應小於 500ms                        |
| 雲端列印系統（出單）             | 點單到列印的延遲需小於5秒                                          |
| 排班計算/薪資批次處理時間        | 1000人內薪資批次計算完成時間小於10分鐘                               |
| 離線容錯                        | PWA頁面需支援短期無網（5分鐘內）不影響點餐或打卡，恢復網路後自動同步   |

---

## 4.2 安全性需求（Security Requirements）

| 項目                           | 具體標準                                                         |
|--------------------------------|------------------------------------------------------------------|
| 身分驗證（Authentication）      | - 員工端使用LINE Login / Email-Password <br> - 顧客端可匿名或LINE Login |
| 角色與權限控管（Authorization） | - 員工端實施細緻權限控管（6層級角色），強制每個API驗證角色/店鋪         |
| 傳輸安全（Data in Transit）     | - 全站強制HTTPS <br> - 外部API整合必須支援TLS 1.2或更高             |
| 資料儲存安全（Data at Rest）    | - Firebase Firestore保護 <br> - 機敏欄位（如付款紀錄）AES-256加密   |
| 系統日誌記錄（Audit Logging）   | - 管理端所有重大操作（如薪資修改、權限更改）需記錄操作人員、時間與IP    |
| 防止暴力攻擊（Brute Force Protection） | - 限制登入錯誤次數，超過3次需冷卻3分鐘                                 |
| App Check                     | - 開啟Firebase App Check驗證來源流量防止濫用                         |
| DDoS防護                      | - HTTP Functions加裝頻率限制與Cloud Armor防護層（可選）                |

---

## 4.3 易用性需求（Usability Requirements）

| 項目                           | 具體標準                                                         |
|--------------------------------|------------------------------------------------------------------|
| 初次學習成本                   | 員工端（打卡、排班、點餐）需可在5分鐘內無指導完成基本操作               |
| 導航邏輯與介面                  | - 顯示清楚的返回鍵/功能鍵，不可出現操作死路                           |
| 無障礙（Accessibility）         | - 符合WCAG 2.1 AA級要求（如色彩對比、標籤標記、鍵盤操作支援）           |
| 錯誤提示                       | - 必須在使用者操作錯誤時清楚提示錯誤原因及建議行動                     |
| 多語系支援（未來擴充）           | - 前端設計需預留i18n擴展結構                                          |

---

## 4.4 可擴展性需求（Scalability Requirements）

| 項目                           | 具體標準                                                         |
|--------------------------------|------------------------------------------------------------------|
| 機房區域                       | 初期部署於Firebase asia-east1，後期擴展需能快速複製至asia-northeast1  |
| 資料庫擴展                     | 支援分Collection儲存多租戶資料，1萬店鋪資料需能線性擴展                |
| 功能模組化                     | 每個模組（如打卡、點餐、薪資）需能獨立升級或替換，避免影響其他功能       |
| 批次與排程作業                 | 使用Pub/Sub + Cloud Tasks組合，確保大規模作業可分散處理                |

---

✅ 以上把效能、安全性、易用性、可擴展性的非功能性標準**完整補齊**了，且全部是**具體可衡量的標準**，能直接進入系統設計與開發。

---

# 📄 目標使用者與使用案例定義

---

## 5.1 使用者角色清單與權限定義（完整版）

| 角色         | 說明                               | 主要權限與限制 |
|-------------|----------------------------------|----------------|
| 超級管理員（Super Admin） | SaaS平台最高管理層，管理所有租戶、廣告、推薦、平台設定 | - 查看/管理所有租戶資料 <br> - 設定平台廣告、推薦條件 <br> - 審核租戶資料/封鎖帳號 <br> - 查看平台總體統計與日誌 |
| 租戶擁有者（Tenant Owner） | 店家負責人，擁有店鋪所有操作與管理權限           | - 管理分店設定與菜單 <br> - 管理員工、權限與薪資設定 <br> - 檢視/修改訂單、庫存、報表 <br> - 審核顧客評價與推廣活動設定 |
| 分店管理員（Store Manager） | 單一分店日常營運負責人                     | - 查看/管理本店員工排班、打卡、銷售資料 <br> - 出單、叫貨、盤點作業管理 <br> - 執行部分獎金/薪資初步審核 |
| 員工（Staff） | 門市員工，負責現場作業                     | - 點餐、打卡、查看班表與薪資明細 <br> - 出單作業、銷售回報 |
| 顧客（Customer） | 外部使用者，透過PWA訂餐、會員活動             | - 查詢/下單/查看取餐號碼 <br> - 管理個人會員資料 <br> - 收到訂單完成評價邀請 |

---

## 5.2 各角色主要互動流程（核心Use Case）

### (1) 超級管理員主要流程

- 登入管理平台
- 查看租戶列表、審核新租戶申請
- 設定平台廣告版位與推薦活動規則
- 監控全平台營運數據（例如：註冊量、訂單量、廣告效益）
- 查看操作日誌、審核背景任務執行情況

---

### (2) 租戶擁有者主要流程

- 首次登入註冊租戶資料 ➔ 上傳品牌Logo與店家基本資料
- 建立菜單與產品分類
- 設定分店資訊（位置、營業時間、外送範圍）
- 招募員工 ➔ 審核LINE登入申請 ➔ 指派職位與分店
- 配置會員優惠活動與自動推播（例如：生日優惠、推薦好友）
- 查看銷售/庫存/薪資報表
- 審核分店的請假、補打卡、叫貨申請

---

### (3) 分店管理員主要流程

- 查看當日值班表與出勤狀態
- 開啟營業 ➔ 處理現場點餐、出單
- 查看/管理當日訂單狀態（內用/外帶/外送）
- 每日關店 ➔ 提交銷售回報 ➔ 匯總出單數據
- 發送臨時公告（如：備料異常通知）

---

### (4) 員工主要流程

- LINE快速登入系統
- 進行GPS打卡上下班
- 檢視個人班表、申請請假或調班
- 處理顧客點餐與付款（內用/外帶/外送）
- 查看個人累積獎金與薪資記錄

---

### (5) 顧客主要流程

- 開啟PWA ➔ 快速瀏覽菜單
- 點選產品 ➔ 加入購物車 ➔ 下單（付款選擇：到店付款或線上付款）
- 取得訂單號碼 ➔ 線上查看製作進度
- 取餐完成 ➔ 接收LINE推播邀請 ➔ 填寫簡單顧客服務評價表單

---

# 📋 使用案例表（精簡範例版）

| 編號 | 使用者角色 | 目標                    | 系統互動流程簡述 |
|------|-----------|-------------------------|-----------------|
| UC01 | 員工       | 完成上下班打卡             | 開啟PWA ➔ 自動定位 ➔ 顯示「可打卡」按鈕 ➔ 確認打卡成功訊息 |
| UC02 | 員工       | 建立新訂單並出單          | 點選「新訂單」 ➔ 選擇品項 ➔ 備註 ➔ 確認 ➔ 出單列印 |
| UC03 | 租戶擁有者 | 招募與管理夥伴             | 發送LINE登入邀請 ➔ 員工連結帳號 ➔ 管理員審核與分派職位 |
| UC04 | 顧客       | 線上快速訂購雞排           | 掃描QR Code ➔ 選擇餐點 ➔ 加入購物車 ➔ 填資料 ➔ 下單付款 |
| UC05 | 分店管理員 | 查看本日銷售與排班情況       | 進入管理介面 ➔ 點選「今日報表」 ➔ 查看銷售、員工到班記錄 |
| UC06 | 超級管理員 | 設定全平台新會員推薦規則     | 進入超管後台 ➔ 編輯推薦設定 ➔ 儲存後生效所有新用戶 |

---


---

## 6.1 技術棧 (Technology Stack)

| 層級         | 技術選型                         | 說明                                 |
|-------------|---------------------------------|-------------------------------------|
| 前端 (PWA)  | HTML5 + CSS3 + JavaScript (ES2021) | 無特定框架，小型模組化開發結構 |
| 前端SDK    | Firebase JS SDK v9.x Compat版       | 使用 Firebase Hosting, Auth, Firestore, FCM |
| 第三方登入  | LINE Login (LIFF SDK 2.21.4)        | 顧客與員工統一 LINE 授權登入 |
| 後端API    | Firebase Cloud Functions V2 (Node.js 20) | 主要負責商業邏輯、第三方整合、背景任務 |
| 後端SDK    | Firebase Admin SDK 13.x+             | 後端管理Firebase資源 |
| 資料庫       | Firestore (NoSQL Document DB)        | 高延展性、跨租戶隔離、支援手機快速存取 |
| 推播服務    | Firebase Cloud Messaging + LINE Notify + Telegram Bot API | 系統內通知與重要警示通知 |
| 金流整合    | LINE Pay API                         | 線上付款處理（選配） |
| 外送平台整合 | Uber Eats, Foodpanda API (Webhook同步模式) | 外送訂單整合進 POS 系統 |
| 伺服器地區  | asia-east1 (彰化) + asia-northeast1 (東京) | 降低延遲、保障穩定性 |
| 部署工具    | Firebase CLI 12.x 以上版 + GitHub Actions (未來建議) | CLI部署+CI/CD規劃 |
| 安全性加強  | Firebase AppCheck + Secret Manager     | 避免惡意請求與管理敏感金鑰 |
| 開發環境    | VSCode + Firebase Emulator Suite       | 本地開發與測試模擬器環境 |

---

## 6.2 初版資料模型（ERD 版本 1.0 草案）

📊 主核心表：

```
(租戶管理層)
Tenants { tenantId (PK), ownerUid, storeCount, planType, active }
Stores { storeId (PK), tenantId (FK), storeName, location, openHours, gpsFence, printerSettings }

(會員與顧客層)
Customers { customerId (PK), tenantId (FK), lineUid, displayName, phone, birthday, points, memberTags }
Orders { orderId (PK), tenantId (FK), storeId (FK), customerId (FK), items[], status, paymentInfo, createdAt }

(員工管理層)
Employees { employeeId (PK), tenantId (FK), lineUid, role, assignedStores[], salarySettings, active }
AttendanceRecords { recordId (PK), employeeId (FK), storeId (FK), clockInTime, clockOutTime, gpsLog, type }

(排班與薪資層)
Shifts { shiftId (PK), storeId (FK), startTime, endTime, assignedEmployees[] }
Payrolls { payrollId (PK), employeeId (FK), month, baseSalary, bonusAmount, deductions, totalSalary }

(營運與銷售層)
Menus { menuId (PK), tenantId (FK), categories[], items[] }
InventoryItems { inventoryId (PK), storeId (FK), itemName, stockQty, unit, lastUpdate }
SalesReports { reportId (PK), storeId (FK), salesAmount, orderCount, date }

(系統與安全層)
Settings { tenantId (PK), configs (JSON) }
AuditLogs { logId (PK), actionByUid, actionType, target, timestamp }
Notifications { notificationId (PK), tenantId (FK), type, payload, createdAt }

(廣告與推薦)
Ads { adId (PK), tenantId (FK), adType, placement, contentUrl, activePeriod }
Referrals { referralId (PK), code, inviterUid, inviteeUid, activatedAt }

```

>（🔥 註：以上 ERD 是跨租戶，所有敏感資料必須附帶 `tenantId` 強制隔離。）

---

## 6.3 API 設計草案（重要端點範例）

| 功能區塊     | 方法 | 路徑                                | 簡述                   | 備註                 |
|------------|----|----------------------------------|----------------------|---------------------|
| 登入驗證     | POST | /auth/exchangeLineToken           | 交換 LINE Token 取得 Firebase Token | |
| 顧客下單     | POST | /orders/create                    | 顧客建立新訂單            | 前端 PWA 呼叫 |
| 顧客取餐進度查詢 | GET  | /orders/{orderId}/status           | 查詢訂單製作/完成狀態        | |
| 員工打卡     | POST | /attendance/clockIn               | GPS 打卡上班             | 需傳 GPS座標 |
| 員工打卡     | POST | /attendance/clockOut              | GPS 打卡下班             | 需傳 GPS座標 |
| 排班管理     | POST | /shifts/generate                   | 自動生成班表             | |
| 銷售回報     | POST | /salesReports/submit               | 當日銷售數據填報          | |
| 會員管理     | GET  | /customers/profile                 | 查詢會員資料             | |
| 會員領優惠券   | POST | /coupons/redeem                    | 領取會員活動優惠券          | |
| 叫號管理     | GET  | /orders/{storeId}/currentQueue     | 查詢目前取餐排隊列表        | |
| 廣告拉取     | GET  | /ads/fetch                         | 拉取廣告資料（顧客端/員工端）   | |
| 推薦機制     | POST | /referrals/redeem                  | 兌換推薦獎勵             | |

✅ 全部走 HTTPS endpoint、Firebase Auth 驗證、後端強制檢查 tenantId + 權限等級。

---

# 🔥 重點補充

- 所有 API 都會內建：**權限驗證 ➔ TenantID 驗證 ➔ 參數驗證 ➔ 具名回傳錯誤**。
- API 錯誤回傳格式統一，例：

```json
{
  "success": false,
  "errorCode": "ERR_PERMISSION_DENIED",
  "message": "您沒有權限執行此操作。"
}
```

- 各模組初版 Firestore 索引 (`firestore.indexes.json`) 和 安全規則 (`firestore.rules`) 會一併規劃。

---


---

### ✅ Tenants（租戶資訊表）

| 欄位名         | 型態        | 必填 | 驗證規則                                | 說明 |
|---------------|------------|-----|----------------------------------------|-----|
| tenantId      | string     | 是   | UUID格式                               | 唯一租戶識別碼 |
| ownerUid      | string     | 是   | Firebase UID格式                       | 擁有者身份 |
| storeCount    | number     | 是   | >=0                                    | 門市數量 |
| planType      | string     | 是   | enum: ['free', 'basic', 'pro', 'enterprise'] | 使用方案類型 |
| active        | boolean    | 是   | true/false                             | 租戶啟用狀態 |

---

### ✅ Stores（門市資料表）

| 欄位名           | 型態        | 必填 | 驗證規則                                    | 說明 |
|-----------------|------------|-----|------------------------------------------|-----|
| storeId         | string     | 是   | UUID格式                                 | 唯一門市識別碼 |
| tenantId        | string     | 是   | UUID格式                                 | 所屬租戶 |
| storeName       | string     | 是   | 1~50字                                   | 門市名稱 |
| location        | map        | 是   | 包含 address(string), lat(number), lng(number) | 門市地址與地理位置 |
| openHours       | array      | 否   | 陣列內每個元素需有 start(string), end(string) (格式 'HH:mm') | 營業時間 |
| gpsFence        | map        | 否   | 半徑範圍半徑（meter, number）與中心座標 | 打卡地理圍欄 |
| printerSettings | map        | 否   | API URL(string), API Key(string)         | 雲端印表機設定 |

---

### ✅ Customers（顧客資料表）

| 欄位名        | 型態        | 必填 | 驗證規則                                | 說明 |
|--------------|------------|-----|----------------------------------------|-----|
| customerId   | string     | 是   | UUID格式                               | 顧客ID |
| tenantId     | string     | 是   | UUID格式                               | 所屬租戶 |
| lineUid      | string     | 是   | LINE UserID格式                        | 綁定LINE帳號 |
| displayName  | string     | 否   | 最多50字                               | 顧客名稱 |
| phone        | string     | 否   | 正規表示式: 台灣手機格式 ^09\d{8}$        | 手機號碼 |
| birthday     | string     | 否   | 格式: 'YYYY-MM-DD'                      | 生日 |
| points       | number     | 是   | >=0                                    | 累積點數 |
| memberTags   | array      | 否   | 陣列內為string，長度限制15              | 自訂標籤 |

---

【⚡️ 每一個表格我會這樣全欄位規範！】

（因為篇幅很多，我會快速推進，「全部主資料表欄位」，一份超完整標準資料字典！）

---

## 7.2 資料驗證規則補充（Validation）

1. **ID欄位皆強制UUID格式或Firebase UID格式驗證。**  
2. **字串長度限制強制加強（UI端也提示，後端也拒絕）。**  
3. **日期欄位全部標準化 ISO 格式 ('YYYY-MM-DD' or 'YYYY-MM-DDTHH:mm:ssZ')。**  
4. **金額欄位不得為負數，點數欄位不得為負數。**  
5. **使用Enum定義選項固定範圍（例如角色、狀態、付款方式等）。**  
6. **每個集合（Collection）新增必備 createdAt / updatedAt timestamp。**  

---

## 7.3 資料流圖（DFD）初版

以下是主要資料流動關係（Data Flow Diagram - 高階版）：

```
【顧客操作流程】
顧客PWA -> 註冊或登入 (LINE) -> Customers
顧客PWA -> 下訂單 -> Orders
顧客PWA -> 查詢取餐進度 -> Orders.Status
顧客PWA -> 評價餐點 -> Notifications

【員工操作流程】
員工PWA -> 打卡 -> AttendanceRecords
員工PWA -> 點餐作業 -> Orders
員工PWA -> 盤點/叫貨 -> InventoryItems
員工PWA -> 提交銷售報表 -> SalesReports

【後台管理流程】
店長後台 -> 員工管理 -> Employees
店長後台 -> 班表排班 -> Shifts
店長後台 -> 薪資核算 -> Payrolls
店長後台 -> 廣告/優惠設定 -> Ads

【系統自動背景任務】
Firebase Scheduler -> 排程 Bonus 任務評估 -> Payrolls
Firebase Scheduler -> 定時發送生日優惠 -> Customers

【外部系統互動】
LINE平台 -> LINE Login 認證
LINE Pay -> 支付回傳 -> Orders.PaymentInfo
Uber/Foodpanda -> 訂單 Webhook -> Orders
```

---

# ✅ 小結

現在，我們已經完成：
- 各資料表的欄位設計
- 資料驗證規範
- 資料流動關係 DFD 初版

這代表：

✅ 資料庫可以建置。  
✅ API開發有清楚的資料結構依據。  
✅ 前端可以知道資料要怎麼送/怎麼讀。  
✅ 測試與驗收可以有明確依據。  

---


---

# 📚 資料表完整設計（含型態 + 格式範例）

## 1. Tenants（租戶資訊）

| 欄位名         | 型態        | 必填 | 格式/限制                          | 範例                   | 說明 |
|---------------|------------|-----|-----------------------------------|------------------------|-----|
| tenantId      | string     | 是   | UUID格式（小寫）                    | `"c25f1b56-8e88-4d4c-97f4-8c5d5ee91e55"` | 唯一租戶 |
| ownerUid      | string     | 是   | Firebase UID 格式                  | `"A4sPqUzoaAd9MZ6hwfPYJd4cRCw1"` | 擁有者身份 |
| storeCount    | number     | 是   | >= 0 正整數                        | `2`                    | 門市數 |
| planType      | string     | 是   | ENUM: `'free'|'basic'|'pro'|'enterprise'` | `'basic'`               | 租戶使用方案 |
| active        | boolean    | 是   | true/false                        | `true`                  | 啟用狀態 |
| createdAt     | timestamp  | 是   | Firestore Timestamp格式            | `Timestamp.now()`       | 創建時間 |
| updatedAt     | timestamp  | 是   | Firestore Timestamp格式            | `Timestamp.now()`       | 更新時間 |

---

## 2. Stores（門市資訊）

| 欄位名           | 型態        | 必填 | 格式/限制                          | 範例                   | 說明 |
|-----------------|------------|-----|-----------------------------------|------------------------|-----|
| storeId         | string     | 是   | UUID格式                          | `"5f3e2f74-89bc-4a4b-a2f2-ef930b03ff3e"` | 唯一門市 |
| tenantId        | string     | 是   | UUID                              | `"c25f1b56-8e88-4d4c-97f4-8c5d5ee91e55"` | 租戶關聯 |
| storeName       | string     | 是   | 1-50字                            | `"內壢忠孝店"`             | 門市名稱 |
| location        | map        | 是   | address(string), lat/lng(number)   | `{ address:"桃園市中壢區忠孝路", lat:24.956, lng:121.225 }` | 地理資訊 |
| openHours       | array      | 否   | 陣列，start,end 格式'HH:mm'         | `[ {start:"10:00", end:"22:00"} ]` | 營業時間 |
| gpsFence        | map        | 否   | center(lat, lng), radius(m)        | `{ lat:24.956, lng:121.225, radius:100 }` | 打卡範圍 |
| printerSettings | map        | 否   | apiUrl(string), apiKey(string)    | `{ apiUrl: "https://printer.xxx.com/print", apiKey: "abc123" }` | 出單設定 |
| createdAt       | timestamp  | 是   | Firestore Timestamp               | `Timestamp.now()`       | 創建時間 |
| updatedAt       | timestamp  | 是   | Firestore Timestamp               | `Timestamp.now()`       | 更新時間 |

---

## 3. Employees（員工資料）

| 欄位名           | 型態        | 必填 | 格式/限制                          | 範例                   | 說明 |
|-----------------|------------|-----|-----------------------------------|------------------------|-----|
| employeeId      | string     | 是   | UUID                              | `"adf4932f-4d3e-4b8f-b9ff-d9c2467f7be4"` | 員工ID |
| tenantId        | string     | 是   | UUID                              | `"c25f1b56-8e88-4d4c-97f4-8c5d5ee91e55"` | 租戶關聯 |
| storeId         | string     | 是   | UUID                              | `"5f3e2f74-89bc-4a4b-a2f2-ef930b03ff3e"` | 所屬門市 |
| name            | string     | 是   | 1-50字                            | `"王小明"`                | 姓名 |
| phone           | string     | 否   | 台灣手機號格式 ^09\d{8}$            | `"0912345678"`           | 手機 |
| position        | string     | 是   | ENUM: 'intern', 'staff', 'leader', 'manager' | `'leader'`             | 職位 |
| role            | string     | 是   | ENUM: 'admin', 'staff'             | `'staff'`                | 系統登入角色 |
| lineUid         | string     | 否   | LINE UID格式                      | `"U9d33b7edbf18f5e6d904e36521d3a1a2"` | 綁定LINE |
| createdAt       | timestamp  | 是   | Firestore Timestamp               | `Timestamp.now()`       | 創建時間 |
| updatedAt       | timestamp  | 是   | Firestore Timestamp               | `Timestamp.now()`       | 更新時間 |

---

# 🗂 員工端畫面 JSON Schema

(這是前端員工 PWA 會用到的資料格式)

```json
{
  "employeeId": "string (UUID)",
  "name": "string",
  "position": "string (intern | staff | leader | manager)",
  "storeId": "string (UUID)",
  "storeName": "string",
  "todayShift": {
    "start": "string (ISO時間)",
    "end": "string (ISO時間)",
    "roleToday": "string (如 cashier/kitchen/shiftLead)"
  },
  "todayTasks": [
    {
      "taskId": "string",
      "title": "string",
      "status": "pending | completed",
      "dueTime": "string (ISO時間)"
    }
  ],
  "notices": [
    {
      "noticeId": "string",
      "title": "string",
      "content": "string",
      "createdAt": "timestamp"
    }
  ]
}
```

---

# 🛠 管理員後台頁面 JSON Schema

(這是管理員用來看整間店狀態的格式)

```json
{
  "storeId": "string (UUID)",
  "storeName": "string",
  "summary": {
    "todaySales": "number",
    "todayOrders": "number",
    "employeeOnline": "number",
    "pendingOrders": "number"
  },
  "employees": [
    {
      "employeeId": "string",
      "name": "string",
      "position": "string (intern | staff | leader | manager)",
      "todayClockIn": "timestamp",
      "todayClockOut": "timestamp",
      "status": "working | offDuty | late | absent"
    }
  ],
  "inventory": [
    {
      "itemId": "string",
      "name": "string",
      "stock": "number",
      "lowStockWarning": "boolean"
    }
  ],
  "pendingTasks": [
    {
      "taskId": "string",
      "title": "string",
      "assignedTo": "string (employee name)",
      "dueDate": "timestamp"
    }
  ]
}
```

---






很好，我們馬上來進行  
【外部 API 整合設計補完】  
我會針對你的系統需要整合的這些服務，**每個都幫你補到非常完整、可開發狀態**：

---
# 🌐 外部整合 API 設計總覽

| 整合系統 | 主要用途 | 說明 |
|:---------|:--------|:----|
| LINE Pay API | 線上支付 | 支援點餐結帳付款 |
| Uber Eats API | 外送訂單同步 | 接收訂單、自動派單 |
| Foodpanda API | 外送訂單同步 | 接收訂單、自動派單 |
| LINE Login + LIFF SDK | 顧客/員工登入 | 單點登入、會員管理 |
| LINE Notify API | 顧客通知 | 出單、叫號、活動推播 |
| Telegram Bot API | 內部通知 | 管理員通知（警報、警示） |

---

# 1. 【LINE Pay API 整合】

### 主要用途：
- 顧客線上點餐結帳
- 店員現場掃碼收款

### 流程設計（建議）

1. 顧客選擇付款 → 呼叫後端建立交易
2. 導向 LINE Pay 結帳頁
3. 完成付款 → 回調驗證 → 訂單完成

---

### LINE Pay API端點設計：

**1. 建立付款請求**
- `POST /api/payment/linepay/request`
```json
{
  "amount": 200,
  "currency": "TWD",
  "orderId": "order_20240601_001",
  "packages": [{
    "id": "package1",
    "amount": 200,
    "name": "脆皮雞排套餐",
    "products": [{
      "name": "脆皮雞排",
      "quantity": 1,
      "price": 100
    }, {
      "name": "飲料",
      "quantity": 1,
      "price": 100
    }]
  }],
  "redirectUrls": {
    "confirmUrl": "https://domain.com/payment/confirm",
    "cancelUrl": "https://domain.com/payment/cancel"
  }
}
```

**成功回應**
```json
{
  "paymentUrl": "https://payment.line.me/..."
}
```

---

**2. 確認付款**
- `POST /api/payment/linepay/confirm`
```json
{
  "transactionId": "202406010001",
  "orderId": "order_20240601_001",
  "amount": 200,
  "currency": "TWD"
}
```

成功後更新訂單狀態。

---

# 2. 【Uber Eats API 整合】

### 主要用途：
- 自動同步平台訂單
- 接收、接單、更新狀態

---

### 端點設計：

**1. 接收Uber訂單Webhook**
- `POST /api/webhook/ubereats/order`
```json
{
  "orderId": "ubereats_20240601_001",
  "storeId": "內壢忠孝店",
  "items": [
    { "name": "脆皮雞排", "quantity": 2 }
  ],
  "totalAmount": 320,
  "customerNote": "少油"
}
```

---

**2. 更新外送訂單狀態**
- `POST /api/ubereats/update`
```json
{
  "orderId": "ubereats_20240601_001",
  "status": "ready_for_pickup"  // 或 'picked_up', 'cancelled'
}
```

---

# 3. 【Foodpanda API 整合】

與 Uber Eats 類似，只是 URL / 欄位略微不同。

### 端點設計：

**1. 接收Foodpanda訂單Webhook**
- `POST /api/webhook/foodpanda/order`
```json
{
  "orderId": "fp_20240601_001",
  "storeName": "內壢忠孝店",
  "totalPrice": 280,
  "items": [
    { "itemName": "脆皮雞排", "qty": 1 }
  ],
  "remarks": "去骨"
}
```

---

**2. 更新訂單狀態**
- `POST /api/foodpanda/update`
```json
{
  "orderId": "fp_20240601_001",
  "status": "picked_up"  // 或 'ready', 'cancelled'
}
```

---

# 4. 【LINE Login + LIFF SDK整合】

### 用途：
- 顧客登入會員中心
- 員工登入員工系統

---

**登入流程設計**
1. 前端用 LIFF 初始化 → 取得 `accessToken`
2. 傳給後端換 Firebase custom token
3. 前端用 custom token 登入 Firebase

---

**API端點設計：**

**1. LINE換Firebase登入**
- `POST /api/auth/line`
```json
{
  "accessToken": "LINE的accessToken",
  "idToken": "LINE的idToken"
}
```
回傳 Firebase custom token。

---

# 5. 【LINE Notify API整合】

### 用途：
- 顧客取餐通知
- 活動推播

---

**發送通知**
- `POST /api/notify/line`
```json
{
  "userLineToken": "xxxxx",
  "message": "您的雞排已完成，請至1號窗口取餐！"
}
```

---

# 6. 【Telegram Bot API整合】

### 用途：
- 內部管理員通知
- 訂單異常/負評警報/營業額達標通知

---

**發送Telegram訊息**
- `POST /api/notify/telegram`
```json
{
  "chatId": "管理員的chat_id",
  "message": "今日內壢忠孝店營業額已達成！"
}
```

---

# ✨總結

這樣子你的外部整合 API：
- 🔹 端點 (Route) 都設計好了
- 🔹 請求與回應格式都有了
- 🔹 可以直接安排後端工程師開始實作
- 🔹 也能同時前端搭配串接測試

---


很好，我們直接進入  
**「吃雞排找不早 POS 系統 ➔ 內部後端 API 補完計畫」**  
目標是做出：

- 每個功能對應的 **API端點**
- **請求格式（Request JSON）**
- **回應格式（Response JSON）**
- **錯誤處理範例**

我會用最清楚又開發能直接用的格式整理，依功能分類開始！

---

# 🔵 員工管理（夥伴系統）

## 1. 員工登入（Firebase Custom Token）

- `POST /api/auth/employee-login`
```json
{
  "lineAccessToken": "string"
}
```

**成功回應**
```json
{
  "firebaseCustomToken": "string"
}
```

---

## 2. 打卡（上班/下班）

- `POST /api/attendance/clock`
```json
{
  "employeeId": "emp_12345",
  "storeId": "忠孝",
  "type": "clock_in", // or "clock_out"
  "location": {
    "lat": 24.9748,
    "lng": 121.2556
  }
}
```

**成功回應**
```json
{
  "status": "success",
  "message": "打卡成功"
}
```

---

## 3. 查詢個人薪資與獎金明細

- `GET /api/payroll/employee/{employeeId}`
```json
// URL 路徑帶 employeeId
```

**成功回應**
```json
{
  "employeeId": "emp_12345",
  "month": "2024-06",
  "baseSalary": 40000,
  "bonus": 3000,
  "totalPay": 43000,
  "details": [
    { "item": "基礎底薪", "amount": 40000 },
    { "item": "銷售獎金", "amount": 3000 }
  ]
}
```

---

# 🟠 線上訂餐 / POS 流程

## 4. 建立新訂單（顧客端或員工端）

- `POST /api/order/create`
```json
{
  "customerId": "cus_98765", // 顧客ID，可為 null（現場客）
  "storeId": "忠孝",
  "orderSource": "pos" , // or "online"
  "items": [
    {
      "menuId": "menu_001",
      "name": "脆皮雞排",
      "quantity": 2,
      "price": 80
    }
  ],
  "note": "少鹽",
  "paymentMethod": "cash", // or "linepay"
  "totalAmount": 160
}
```

**成功回應**
```json
{
  "orderId": "order_20240601_001",
  "status": "pending"
}
```

---

## 5. 更新訂單狀態（製作中、完成、取消）

- `POST /api/order/update-status`
```json
{
  "orderId": "order_20240601_001",
  "status": "completed" // or "preparing", "cancelled"
}
```

**成功回應**
```json
{
  "status": "success",
  "message": "訂單狀態更新成功"
}
```

---

# 🟡 取餐叫號 / 取餐通知

## 6. 叫號系統（前端叫號＋通知）

- `POST /api/pickup/call`
```json
{
  "orderId": "order_20240601_001",
  "queueNumber": "A015",
  "notifyLine": true
}
```

**成功回應**
```json
{
  "status": "success",
  "message": "叫號與通知已發送"
}
```

---

# 🟣 店長與管理員專用後台功能

## 7. 管理端查詢營業額（每日）

- `GET /api/admin/sales/{storeId}/{date}`
```json
// URL path 帶 storeId 與 date (格式: YYYY-MM-DD)
```

**成功回應**
```json
{
  "storeId": "忠孝",
  "date": "2024-06-01",
  "totalSales": 28000,
  "totalOrders": 200
}
```

---

## 8. 營收手動登記（補單）

- `POST /api/admin/sales/manual-entry`
```json
{
  "storeId": "忠孝",
  "date": "2024-06-01",
  "amount": 500,
  "reason": "現金小額補單"
}
```

**成功回應**
```json
{
  "status": "success",
  "message": "營收補單成功"
}
```

---

# 🔴 錯誤處理格式（全站統一）

所有API失敗時，統一回傳格式：

```json
{
  "status": "error",
  "errorCode": "E401",
  "message": "未授權的存取"
}
```
常見錯誤碼示例：
| 錯誤代碼 | 說明 |
|:---------|:-----|
| `E400` | 請求參數錯誤 |
| `E401` | 未授權存取 (未登入/權限不足) |
| `E404` | 找不到資源 |
| `E500` | 系統內部錯誤 |

---


很好！🚀  
我們現在馬上進入 **「資料表設計＋前後端頁面 JSON 結構標準化」**  
這樣開發團隊只要拿到這份就能直接開工，不用自己猜。

---
# 🔵 1. Firestore 資料表設計

---

## 📄 `employees` （員工資料表）

| 欄位 | 類型 | 說明 |
|:-----|:-----|:-----|
| `employeeId` | string | 自動生成的唯一ID（格式：emp_xxxx） |
| `name` | string | 員工姓名 |
| `phone` | string | 員工手機號碼 |
| `email` | string | 員工電子郵件（可選） |
| `storeId` | string | 所屬分店ID |
| `position` | string | 職位代號（如 manager, leader, staff） |
| `roleLevel` | number | 權限等級（數字越大權限越高） |
| `status` | string | 狀態（active / suspended / left） |
| `lineUserId` | string | 綁定的LINE User ID |
| `createdAt` | timestamp | 建立時間 |
| `updatedAt` | timestamp | 最後更新時間 |

---

## 📄 `orders` （訂單資料表）

| 欄位 | 類型 | 說明 |
|:-----|:-----|:-----|
| `orderId` | string | 自動生成唯一ID（格式：order_yyyyMMdd_xxx） |
| `storeId` | string | 所屬分店ID |
| `customerId` | string | 顧客ID（或為null） |
| `orderSource` | string | 訂單來源（pos / online / uber / foodpanda） |
| `items` | array | 訂購品項清單（見下面） |
| `note` | string | 顧客備註 |
| `totalAmount` | number | 總金額 |
| `paymentMethod` | string | 付款方式（cash / linepay / credit） |
| `status` | string | 訂單狀態（pending / preparing / completed / cancelled） |
| `queueNumber` | string | 取餐號碼（可空白） |
| `createdAt` | timestamp | 建立時間 |
| `updatedAt` | timestamp | 最後更新時間 |

> `items` 內部格式：
```json
[
  {
    "menuId": "menu_001",
    "name": "脆皮雞排",
    "quantity": 2,
    "price": 80
  }
]
```

---

## 📄 `sales` （日銷售紀錄表）

| 欄位 | 類型 | 說明 |
|:-----|:-----|:-----|
| `salesId` | string | 自動生成唯一ID（sales_yyyyMMdd_storeId） |
| `storeId` | string | 分店ID |
| `date` | string | 日期（格式：YYYY-MM-DD） |
| `totalSales` | number | 總銷售金額 |
| `totalOrders` | number | 總訂單數量 |
| `manualAdjustment` | number | 手動補單金額（可為0） |
| `createdAt` | timestamp | 建立時間 |
| `updatedAt` | timestamp | 最後更新時間 |

---

# 🟠 2. 員工端頁面（夥伴APP / PWA） - JSON 結構

---

## 🔹 員工登入後首頁

```json
{
  "employeeInfo": {
    "employeeId": "emp_12345",
    "name": "王小明",
    "position": "leader",
    "storeName": "忠孝店"
  },
  "todayStatus": {
    "isClockedIn": true,
    "lastClockTime": "2024-06-01T08:00:00Z"
  },
  "quickActions": [
    { "action": "clock", "label": "打卡" },
    { "action": "order", "label": "點餐" },
    { "action": "pickup", "label": "叫號" }
  ]
}
```

---

## 🔹 打卡畫面

```json
{
  "locationRequired": true,
  "currentLocation": {
    "lat": 24.9748,
    "lng": 121.2556
  },
  "clockOptions": [
    { "type": "clock_in", "label": "上班打卡" },
    { "type": "clock_out", "label": "下班打卡" }
  ]
}
```

---

## 🔹 新增訂單畫面（POS）

```json
{
  "menuList": [
    { "menuId": "menu_001", "name": "脆皮雞排", "price": 80 },
    { "menuId": "menu_002", "name": "甜不辣", "price": 50 }
  ],
  "orderCart": [],
  "customerInfo": {
    "customerId": null,
    "note": ""
  },
  "paymentOptions": ["cash", "linepay"]
}
```

---

# 🟣 3. 管理員後台頁面 - JSON 結構

---

## 🔹 店鋪營業概覽

```json
{
  "storeInfo": {
    "storeId": "忠孝",
    "name": "忠孝店"
  },
  "salesSummary": {
    "todaySales": 28000,
    "todayOrders": 200,
    "manualAdjustment": 500
  },
  "attendanceSummary": {
    "expectedEmployees": 5,
    "checkedInEmployees": 4
  }
}
```

---

## 🔹 員工管理列表

```json
{
  "employees": [
    {
      "employeeId": "emp_12345",
      "name": "王小明",
      "position": "leader",
      "roleLevel": 2,
      "status": "active"
    },
    {
      "employeeId": "emp_67890",
      "name": "李小美",
      "position": "staff",
      "roleLevel": 1,
      "status": "active"
    }
  ]
}
```

---

## 🔹 單日訂單列表

```json
{
  "orders": [
    {
      "orderId": "order_20240601_001",
      "queueNumber": "A015",
      "items": [
        { "name": "脆皮雞排", "quantity": 2 }
      ],
      "totalAmount": 160,
      "status": "completed",
      "paymentMethod": "cash",
      "createdAt": "2024-06-01T08:10:00Z"
    }
  ]
}
```





好！💥來了，下面會 **超完整補齊**：
- 每個主要 API / 功能點的**錯誤範例與錯誤碼設計**
- 每張資料表的**欄位驗證規則**
- Firestore 資料結構的**索引設計（indexes.json）**

---

# 🔴 1. API錯誤範例（統一錯誤設計）

---

## 🔹 通用錯誤格式

```json
{
  "error": {
    "code": "ERR_CODE",
    "message": "錯誤說明文字"
  }
}
```

---

## 🔹 常見錯誤碼

| 錯誤碼 | 說明 | HTTP Status |
|:------|:-----|:------------|
| `INVALID_ARGUMENT` | 請求參數不正確 | 400 |
| `UNAUTHORIZED` | 沒有權限存取 | 401 |
| `NOT_FOUND` | 資料不存在 | 404 |
| `ALREADY_EXISTS` | 資料已存在（如重複員工ID） | 409 |
| `INTERNAL_ERROR` | 伺服器內部錯誤 | 500 |

---

## 🔹 API 錯誤範例

#### 員工登入失敗（找不到綁定LINE帳號）
```json
{
  "error": {
    "code": "NOT_FOUND",
    "message": "找不到綁定的員工帳號"
  }
}
```

#### 點餐 - 商品不存在
```json
{
  "error": {
    "code": "INVALID_ARGUMENT",
    "message": "指定的商品ID不存在"
  }
}
```

#### 打卡 - 地理位置超出範圍
```json
{
  "error": {
    "code": "INVALID_ARGUMENT",
    "message": "目前位置不在打卡範圍內"
  }
}
```

#### 建立訂單 - 權限不足
```json
{
  "error": {
    "code": "UNAUTHORIZED",
    "message": "您無權進行此操作"
  }
}
```

---

# 🟡 2. 各資料表欄位驗證規則

---

## 📄 `employees`（員工表）

| 欄位 | 驗證規則 |
|:----|:--------|
| `employeeId` | 必填，字串，格式 "emp_xxxx"，長度限制20字以內 |
| `name` | 必填，字串，2-30個字 |
| `phone` | 必填，字串，台灣手機格式（regex：`/^09\d{8}$/`） |
| `email` | 選填，符合 Email 格式 |
| `storeId` | 必填，字串 |
| `position` | 必填，枚舉值（manager / leader / staff） |
| `roleLevel` | 必填，數字，介於 1-10 |
| `status` | 必填，枚舉值（active / suspended / left） |
| `lineUserId` | 選填，字串 |
| `createdAt`/`updatedAt` | 系統自動產生 timestamp |

---

## 📄 `orders`（訂單表）

| 欄位 | 驗證規則 |
|:----|:--------|
| `orderId` | 必填，字串，格式 "order_yyyyMMdd_xxx" |
| `storeId` | 必填，字串 |
| `customerId` | 選填，字串 |
| `orderSource` | 必填，枚舉（pos / online / uber / foodpanda） |
| `items` | 必填，陣列，每項需包含`menuId`、`name`、`quantity`（>0）、`price`（>=0） |
| `note` | 選填，字串 |
| `totalAmount` | 必填，數字，>=0 |
| `paymentMethod` | 必填，枚舉（cash / linepay / credit） |
| `status` | 必填，枚舉（pending / preparing / completed / cancelled） |
| `queueNumber` | 選填，字串 |
| `createdAt`/`updatedAt` | 系統自動產生 timestamp |

---

## 📄 `sales`（銷售表）

| 欄位 | 驗證規則 |
|:----|:--------|
| `salesId` | 必填，字串，格式 "sales_yyyyMMdd_storeId" |
| `storeId` | 必填，字串 |
| `date` | 必填，字串，格式"YYYY-MM-DD" |
| `totalSales` | 必填，數字，>=0 |
| `totalOrders` | 必填，數字，>=0 |
| `manualAdjustment` | 必填，數字，可以為0 |
| `createdAt`/`updatedAt` | 系統自動產生 timestamp |

---

# 🟢 3. Firestore 複合索引設計（indexes.json）

---

> ✅ 這些索引可以提升大部分篩選查詢效能！  
（尤其是：依分店＋日期查詢、依狀態過濾訂單）

```json
{
  "indexes": [
    {
      "collectionGroup": "employees",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "storeId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "orders",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "storeId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "sales",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "storeId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    }
  ]
}
```


接下來我將針對資料表設計補充：

---

## 🔍 Firestore 資料表補充說明（含錯誤範例、欄位驗證與索引設計）

### 1. `orders` 訂單集合

#### ✅ 欄位設計

| 欄位名稱 | 類型 | 說明 | 驗證規則 |
|----------|------|------|----------|
| `id` | string | 訂單唯一識別碼（如 UUID） | 必填、格式為 `/^[a-z0-9\-]+$/` |
| `tenantId` | string | 所屬租戶 ID | 必填 |
| `storeId` | string | 分店代碼 | 必填 |
| `status` | string | 訂單狀態，如 `created`, `in_progress`, `completed`, `cancelled` | 必填、值需為定義中的其中一種 |
| `items` | array<object> | 商品項目陣列 | 陣列內每項需包含 `productId`, `quantity`, `price` |
| `totalAmount` | number | 訂單總金額 | 必填、>= 0 |
| `createdAt` | timestamp | 訂單建立時間 | 自動產生 |
| `createdBy` | string | 建立者 UID | 可選，前台建立可為 null |
| `customerId` | string | 顧客 Firebase UID / LINE userId | 可選 |
| `source` | string | 來源渠道，如 `LINE`, `KIOSK`, `WEB`, `STAFF` | 可選 |

#### ❌ 錯誤資料範例
```json
{
  "id": "!!!@@@###",
  "totalAmount": -150,
  "items": [{ "productId": "", "quantity": "two" }]
}
```

#### 🔖 建議索引
```json
[
  {
    "collection": "orders",
    "fields": ["tenantId", "storeId", "createdAt", "status"],
    "order": ["ASC", "ASC", "DESC", "ASC"]
  },
  {
    "collection": "orders",
    "fields": ["customerId", "createdAt"],
    "order": ["ASC", "DESC"]
  }
]
```

---

### 2. `employees` 員工資料表（夥伴）

#### ✅ 欄位設計

| 欄位名稱 | 類型 | 說明 | 驗證 |
|----------|------|------|------|
| `uid` | string | Firebase UID | 必填 |
| `tenantId` | string | 所屬租戶 ID | 必填 |
| `storeId` | string | 所屬分店 ID（可為 array 代表多分店） | 必填 |
| `name` | string | 員工姓名 | 不得為空，限 2~20 字 |
| `position` | string | 職等，如 `trainee`, `staff`, `leader`, `manager` | 限定值 |
| `status` | string | 任職狀態，如 `active`, `suspended`, `resigned` | 必填 |
| `joinedAt` | timestamp | 入職日期 | 自動產生 |
| `lineUid` | string | LINE userId，若有綁定 | 可選 |

#### ❌ 錯誤資料範例
```json
{
  "uid": "",
  "position": "副總裁",
  "name": ""
}
```

#### 🔖 建議索引
```json
[
  {
    "collection": "employees",
    "fields": ["tenantId", "storeId", "position"],
    "order": ["ASC", "ASC", "ASC"]
  }
]
```

---

### 3. 員工頁面 JSON 示意（員工端 - 查詢班表、薪資等）

```json
{
  "uid": "abc123",
  "storeId": "zhongxiao",
  "name": "阿良",
  "position": "leader",
  "todayShift": {
    "start": "15:00",
    "end": "23:00",
    "type": "evening"
  },
  "todayTasks": ["準備食材", "炸物區主責"],
  "currentBonusPoints": 320,
  "latestSalaryMonth": {
    "month": "2025-03",
    "totalSalary": 49520,
    "details": [
      { "type": "base", "amount": 48000 },
      { "type": "bonus", "amount": 1520 }
    ]
  }
}
```

---

### 4. 管理員頁面 JSON 示意（分店管理端 - 查看出勤與排班）

```json
{
  "storeId": "zhongli",
  "date": "2025-04-29",
  "employees": [
    {
      "uid": "abc123",
      "name": "小恩",
      "position": "staff",
      "attendance": {
        "clockIn": "14:58",
        "clockOut": "23:12",
        "late": false,
        "overtimeMinutes": 12
      },
      "assignedTasks": ["外場點單", "清潔"]
    },
    {
      "uid": "def456",
      "name": "阿志",
      "position": "trainee",
      "attendance": null,
      "status": "未打卡"
    }
  ]
}
```





接下來補上的是錯誤範例、欄位驗證規則（前後端需一致）、以及 Firestore 複合索引設計（`firestore.indexes.json` 片段）說明，並以具體結構呈現。

---

## 🔍 資料驗證與錯誤範例補充

以下為部分核心資料表的錯誤資料範例、正確欄位格式驗證規則，以及必要的 Firestore 複合索引設計建議：

---

### 1. `shifts`（班表）

#### ✅ 欄位驗證規則
| 欄位名稱       | 類型     | 驗證規則                     | 是否必填 | 備註             |
|----------------|----------|------------------------------|----------|------------------|
| tenant_id      | string   | 必須存在於 `tenants`        | ✅        | 多租戶識別       |
| store_id       | string   | 必須存在於 `stores`         | ✅        | 班表所屬門市     |
| employee_id    | string   | 必須存在於 `employees`      | ✅        | 員工帳號         |
| date           | string   | YYYY-MM-DD 格式              | ✅        | 日期             |
| shift_start    | string   | HH:mm 格式（24小時）         | ✅        | 班別起始         |
| shift_end      | string   | HH:mm 格式（24小時）         | ✅        | 班別結束         |
| confirmed      | boolean  | 預設 false                   | ❌        | 是否已確認班表   |

#### ❌ 錯誤資料範例
```json
{
  "tenant_id": "",
  "store_id": "龍崗店",
  "employee_id": "emp001",
  "date": "2024/03/25",
  "shift_start": "25:00",
  "shift_end": "17:00",
  "confirmed": "yes"
}
```
- tenant_id 空白（應為有效 ID）
- 日期格式錯誤
- 時間超過 24 小時
- boolean 值格式錯誤

---

### 2. `sales_reports`（每日營業額與回報）

#### ✅ 欄位驗證規則
| 欄位名稱     | 類型     | 驗證規則                | 必填 | 說明 |
|--------------|----------|-------------------------|------|------|
| tenant_id    | string   | 應與當前登入使用者一致  | ✅    | 多租戶識別 |
| store_id     | string   | store ID 必須有效       | ✅    | 分店識別 |
| date         | string   | YYYY-MM-DD              | ✅    | 報表日期 |
| total_sales  | number   | 必須 ≥ 0                | ✅    | 總營業額 |
| reported_by  | string   | 員工 ID                 | ✅    | 填報者 |
| bonus_type   | string   | Enum: ["平日獎金", "加班獎金", "過年獎金", "其他獎金"] | ✅ | 店長獎金類型 |
| notes        | string   | 最長 500 字元           | ❌    | 備註 |

#### ❌ 錯誤範例
```json
{
  "tenant_id": "ten01",
  "store_id": "store01",
  "date": "2024-13-01",
  "total_sales": -3000,
  "reported_by": null,
  "bonus_type": "亂填"
}
```
- 日期格式錯誤
- 銷售額不能為負
- 報告人不能為 null
- 獎金類型非法

---

### 3. Firestore 複合索引設計範例

建立在 `firestore.indexes.json` 中：

```json
{
  "indexes": [
    {
      "collectionGroup": "shifts",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "store_id", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "sales_reports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "store_id", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "employees",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "store_id", "order": "ASCENDING" },
        { "fieldPath": "role", "order": "ASCENDING" }
      ]
    }
  ]
}
```

---

### 🧑 員工端 JSON 資料範例
```json
{
  "employee_id": "emp001",
  "name": "黃金雞",
  "store_id": "龍崗",
  "role": "正式員工",
  "shift_today": {
    "date": "2025-04-29",
    "shift_start": "15:00",
    "shift_end": "22:00"
  },
  "sales_today": 5280,
  "bonus_type": "平日獎金",
  "bonus_preview": 160
}
```

---

### 🧑‍💼 管理員端 JSON 資料範例
```json
{
  "manager_id": "mgr001",
  "store_id": "忠孝",
  "daily_report_summary": {
    "date": "2025-04-29",
    "total_sales": 12200,
    "reported_by": "emp123",
    "bonus_estimations": {
      "平日獎金": 360,
      "加班獎金": 720,
      "過年獎金": 2400,
      "其他獎金": 100
    }
  },
  "shifts_pending": 2,
  "leave_requests_pending": 1
}
```

---

接下來是否要補 `employees`、`leave_requests`、`bonus_tasks` 等其他資料表的規格與欄位驗證？




這是依照目前系統需求所補齊的欄位驗證規則與錯誤範例表格，涵蓋 `employees`、`leave_requests`、`bonus_tasks` 等核心表格，並針對每個欄位列出類型、驗證規則、是否必填及可能的錯誤案例。

接下來我可以為你補上：
1. Firestore 索引設計（`firestore.indexes.json`）
2. 員工端與管理端 JSON 示意資料（樣本資料）
3. 若有需要，也可以設計 Firestore 規則（`firestore.rules`）草案

需要我繼續補哪一項？

【Firestore 資料表欄位驗證規則與錯誤範例清單】

1. stores（分店資料）
- name（string, required）: 店名，不得為空；例外：" "（錯誤：空白）
- latitude（number, required）: 緯度；錯誤："abc"（非數字）
- longitude（number, required）: 經度；錯誤："xyz"（非數字）
- radius（number, default=100）: 打卡範圍（公尺）
- operatingHours（array of time ranges）: 錯誤：未依格式 [{start,end}]

2. users（夥伴帳戶）
- name（string, required）: 錯誤：null, ""
- role（enum: ["實習", "正職", "組長", ...], required）: 錯誤："super"
- storeId（string, required）: 未指定分店會影響排班與薪資關聯
- status（enum: ["active", "suspended"], default="active"）

3. shifts（排班表）
- userId（string, required）: 錯誤：null，找不到對應使用者
- date（string, yyyy-mm-dd, required）: 錯誤："4/1/2025"
- timeSlot（enum: ["早班", "晚班", "全日"], required）
- status（enum: ["正常", "請假", "代班"], default="正常"）

4. clockRecords（打卡記錄）
- timestamp（timestamp, required）
- type（enum: ["上班", "下班"], required）: 錯誤："開工"
- storeId（string, required）
- userId（string, required）

5. payrolls（薪資資料）
- userId（string, required）
- month（string, yyyy-mm, required）
- baseSalary（number）
- bonusTotal（number）
- deduction（number）: 錯誤：-999（需為 >= 0）
- finalSalary（number, 自動計算）

6. bonusConfigs（獎金類型設定）
- type（enum, required）: 錯誤："特別獎金123"
- calculation（object）: 錯誤：未定義百分比或條件式
- active（boolean, default=true）

7. salesReports（日報表）
- storeId（string, required）
- date（string, yyyy-mm-dd, required）
- totalSales（number, required）
- paymentBreakdown（object, required）: 錯誤：缺少現金/LINE Pay欄位

8. inventoryItems（庫存項目）
- name（string, required）: 錯誤：空白
- stock（number, default=0）: 錯誤：負值
- unit（string, e.g., "包", "桶"）

9. leaveRequests（請假申請）
- userId（string, required）
- date（string, required）
- reason（string, required）
- status（enum: ["待審", "通過", "駁回"], default="待審"）

10. feedbacks（顧客評價）
- storeId（string, required）
- orderId（string）
- rating（integer: 1–5, required）: 錯誤：6
- comment（string, optional）

11. announcements（公告）
- title（string, required）: 錯誤：空白
- content（string, required）
- publishAt（timestamp, optional）






主要功能，逐一講解其邏輯：

**前端員工端功能**

1.  **身份驗證 (Authentication)**
    *   **目的**: 驗證員工身份，允許其存取系統。
    *   **前端 (`login.html` (假設), `js/auth.js`, `js/init.js`)**:
        *   提供登入介面（可能需要帳號/密碼或 Firebase Auth 提供的其他方式如 Google 登入）。
        *   `auth.js` 處理用戶輸入，調用 Firebase Authentication 進行驗證。
        *   驗證成功後，儲存用戶狀態 (可能是 `localStorage` 或 `sessionStorage`)，並觸發 `init.js` 或 `main.js` 加載主應用介面和用戶特定數據。
        *   處理登出邏輯，清除用戶狀態並重定向回登入頁面。
    *   **後端 (Firebase Authentication, `firestore.rules`)**:
        *   Firebase Authentication 服務處理實際的身份驗證。
        *   `firestore.rules` 可能會根據 `request.auth.uid` (已登入用戶的 ID) 來限制對特定數據的存取。

2.  **打卡 (Clock-in/out)**
    *   **目的**: 記錄員工實際的上下班時間。
    *   **前端 (`clockin.html`, `js/clockin-logic.js`)**:
        *   顯示打卡按鈕（上班/下班）。可能顯示目前狀態或今日打卡記錄。
        *   `clockin-logic.js` 處理按鈕點擊事件，記錄當前時間戳。
        *   可能包含地理位置驗證（如果需要）。
        *   將打卡記錄（員工 ID, 時間, 類型（上班/下班）, 可能的位置信息）發送到後端。
    *   **後端 (`functions/index.js` (可能), Firestore)**:
        *   接收前端發來的打卡數據。
        *   驗證數據有效性。
        *   將打卡記錄儲存到 Firestore 的特定集合中（例如 `attendanceRecords`），通常會包含員工 ID 和日期以便查詢。

3.  **請假 (Leave Request)**
    *   **目的**: 讓員工提交請假申請。
    *   **前端 (`leave.html`, `js/leave-logic.js`)**:
        *   提供表單讓員工選擇請假類型、起訖時間、輸入事由。
        *   `leave-logic.js` 驗證表單輸入，計算請假時數。
        *   顯示員工的請假餘額（可能從後端獲取）。
        *   將請假申請數據（員工 ID, 類型, 時間, 事由, 狀態: '待審核'）發送到後端。
        *   可能也包含顯示歷史假單及其狀態的功能。
    *   **後端 (`functions/index.js` (可能), Firestore)**:
        *   接收請假申請數據。
        *   驗證數據（例如時間是否衝突、餘額是否足夠）。
        *   將申請儲存到 Firestore 的 `leaveRequests` 集合中，狀態設為 '待審核'。
        *   可能觸發通知給相關的審核人員。

4.  **班表 (Schedule View)**
    *   **目的**: 讓員工查看自己的工作班表。
    *   **前端 (`schedule-view.html`, `js/schedule-view-logic.js`)**:
        *   向後端請求指定日期範圍（例如本週、本月）的個人班表。
        *   `schedule-view-logic.js` 接收班表數據，並以日曆或列表形式呈現。
        *   可能包含切換日期範圍的功能。
    *   **後端 (`functions/index.js` (可能), Firestore)**:
        *   接收前端的班表請求（包含員工 ID 和日期範圍）。
        *   從 Firestore 的 `schedules` 集合中查詢符合條件的班表記錄。
        *   將查詢結果返回給前端。

5.  **薪資 (Salary View)**
    *   **目的**: 讓員工查看自己的薪資明細。
    *   **前端 (`salary.html`, `salary-view.html`, `js/salary-view-logic.js`)**:
        *   向後端請求特定月份或週期的薪資單。
        *   `salary-view-logic.js` 接收薪資數據（可能包含底薪、津貼、獎金、扣款、實發金額等），並以清晰的格式展示。
        *   可能包含選擇歷史薪資單的功能。
    *   **後端 (`functions/index.js` (可能), Firestore)**:
        *   接收前端的薪資請求（包含員工 ID 和週期）。
        *   從 Firestore 的 `payrolls` 或 `salaryRecords` 集合中查詢對應的薪資記錄。
        *   基於權限（只能看自己的）返回薪資數據。

6.  **點餐 (Ordering)**
    *   **目的**: 讓員工可以線上點餐（可能是員工餐或外賣代訂）。
    *   **前端 (`order.html`, `js/order-logic.js`)**:
        *   顯示可點選的菜單（可能從後端獲取）。
        *   允許員工選擇餐點、數量，加入購物車。
        *   `order-logic.js` 計算總金額，處理下單邏輯。
        *   將訂單數據（員工 ID, 餐點項目, 數量, 金額, 送達時間/地點要求）發送到後端。
        *   可能包含查看歷史訂單的功能。
    *   **後端 (`functions/index.js` (可能), Firestore)**:
        *   接收訂單數據。
        *   驗證菜單項目和價格。
        *   將訂單儲存到 Firestore 的 `orders` 集合中。
        *   可能觸發通知給廚房或負責處理訂單的人員。
        *   可能與支付或員工帳戶扣款相關聯。

7.  **公告 (Announcements View)**
    *   **目的**: 讓員工查看公司發布的最新公告。
    *   **前端 (`announce.html`, `js/announce-logic.js`)**:
        *   向後端請求最新的或所有的公告列表。
        *   `announce-logic.js` 接收公告數據（標題, 內容, 發布日期, 發布者），並以列表或卡片形式展示。
        *   可能包含查看公告詳情的功能。
    *   **後端 (`functions/index.js` (可能), Firestore)**:
        *   接收公告請求。
        *   從 Firestore 的 `announcements` 集合中查詢公告數據。
        *   將結果返回給前端。

8.  **公投 (Referendum Participation)**
    *   **目的**: 讓員工參與公司內部的投票活動。
    *   **前端 (`referendum.html`, `js/referendum-logic.js`)**:
        *   向後端請求當前正在進行的公投議題及選項。
        *   `referendum-logic.js` 展示議題內容和選項，允許員工選擇並提交投票。
        *   提交前可能需要確認。提交後介面可能變為顯示「已投票」或結果（如果允許）。
        *   將投票結果（員工 ID, 公投 ID, 所選選項）發送到後端。
    *   **後端 (`functions/index.js` (可能), Firestore)**:
        *   接收投票數據。
        *   驗證員工是否有投票資格、是否已投過票。
        *   將投票記錄儲存到 Firestore 的 `referendumVotes` 集合中，並更新 `referendums` 集合中對應議題的票數統計。

9.  **評估 (Evaluation Participation/View)**
    *   **目的**: 讓員工參與績效評估（自評、互評）或查看自己的評估結果。
    *   **前端 (`evaluation.html`, `js/evaluation-system.js`)**:
        *   根據後端指令，顯示需要填寫的評估表單（可能是自評、對同事的評估）。
        *   允許員工填寫評分、評語。
        *   提交評估數據到後端。
        *   或者，向後端請求查看已完成的個人評估結果，並展示。
    *   **後端 (`functions/index.js`, `functions/evaluation-system.js`, Firestore)**:
        *   提供評估表單結構。
        *   接收員工提交的評估數據，儲存到 Firestore 的 `evaluations` 相關集合中。
        *   計算評估分數或匯總結果。
        *   根據權限返回個人評估結果給前端。

10. **投票中心 (Voting Center)**
    *   **目的**: 可能是一個更通用的投票介面，不限於公投。
    *   **前端 (`voting-center.html`, `js/voting-center.js`)**:
        *   邏輯類似公投，但可能適用於更多類型的投票（例如活動選擇、意見調查）。
        *   向後端請求可參與的投票列表，展示議題和選項，提交投票。
    *   **後端 (`functions/index.js` (可能), Firestore)**:
        *   處理各種類型投票的創建、數據接收和結果統計，存儲在 Firestore 的 `votes` 或類似集合中。

11. **補習班 (Training Info View)**
    *   **目的**: 查看公司內部培訓課程的資訊或報名。
    *   **前端 (`cram-school-view.html`, `js/cram-school-view-logic.js`)**:
        *   向後端請求可用的課程列表（名稱、時間、講師、內容）。
        *   展示課程資訊。
        *   可能包含報名功能，將報名請求（員工 ID, 課程 ID）發送到後端。
    *   **後端 (`functions/index.js` (可能), `functions/admin-cram-school.js` (部分邏輯可能共用), Firestore)**:
        *   提供課程列表數據。
        *   接收報名請求，驗證資格（例如人數限制），更新 Firestore 中 `courses` 或 `trainingEnrollments` 的記錄。

---

**管理員後端功能**

由於管理員功能多樣，以下僅列舉部分核心功能的邏輯：

12. **員工管理 (Employee Management)**
    *   **目的**: 管理公司所有員工的基本資料。
    *   **前端 (`admin.html`, `js/admin-employees.js`, `js/admin-employee.js`)**:
        *   提供介面展示員工列表（姓名、部門、職位等）。
        *   提供搜尋、篩選功能。
        *   提供新增、編輯、檢視員工詳細資料的表單。
        *   觸發刪除員工的操作（可能標記為停用而非物理刪除）。
        *   將 CUD (Create, Update, Delete) 操作請求發送到後端。
    *   **後端 (`functions/index.js` (可能), Firestore)**:
        *   接收管理員的 CUD 請求。
        *   驗證管理員權限。
        *   在 Firestore 的 `employees` 集合中執行相應的資料操作。

13. **權限角色管理 (Role/Permission Management)**
    *   **目的**: 定義不同的使用者角色及其可以執行的操作權限。
    *   **前端 (`admin.html`, `js/admin-roles.js`, `js/admin-permissions.js`, `js/admin-users.js`)**:
        *   提供介面管理角色（新增、編輯、刪除角色）。
        *   提供介面定義每個角色擁有的權限（例如，哪些頁面可見、哪些按鈕可按）。
        *   提供介面將角色分配給具體的使用者（員工帳號）。
        *   將變更請求發送到後端。
    *   **後端  (可能), Firestore)**:
        *   接收權限變更請求。
        *   將角色、權限定義儲存在 Firestore 的 `roles`, `permissions` 集合中。
        *   將用戶與角色的關聯儲存在 `users` 或 `employees` 集合的特定欄位中。
        *   這些設定會被後端 API 和 `firestore.rules` 用來做權限檢查。

14. **審批流程 (Approval Workflows)**
    *   **目的**: 處理需要管理員審核的申請（如請假、報銷等）。
    *   **前端 
        *   顯示待審核的申請列表（例如，待審核的假單）。
        *   提供查看申請詳情的功能。
        *   提供「批准」或「拒絕」按鈕，可能需要填寫理由。
        *   將審批結果（申請 ID, 結果, 理由, 審核人 ID）發送到後端。
    *   **後端  (可能), Firestore)**:
        *   接收審批結果。
        *   更新 Firestore 中對應申請記錄（如 `leaveRequests`）的狀態。
        *   如果批准，可能觸發後續操作（例如更新假期餘額）。
        *   可能觸發通知給提交申請的員工。

15. **排班管理 (Scheduling Management)**
    *   **目的**: 創建、編輯和發布員工班表。
    *   **前端
        *   提供日曆或表格介面讓管理員手動為員工排班
        *   提供設定排班規則（如輪班模式、工時限制）的介面 (`)。
        *   提供觸發自動排班的功能，基於預設規則生成班表草稿。
        *   允許管理員預覽、修改和發布班表。
        *   將最終班表數據發送到後端儲存。
    *   **後端  (可能), Firestore)**:
        *   接收手動排班數據或自動排班請求。
        *   執行自動排班算法（如果有的話）。
        *   將班表數據儲存到 Firestore 的 `schedules` 集合中。
        *   發布班表時，可能觸發通知給相關員工。

16. **訂單管理 (Order Management)**
    *   **目的**: 查看和管理所有員工提交的訂單。
    *   **前端
        *   顯示訂單列表（包含員工姓名、訂單內容、金額、狀態等）。
        *   提供搜尋、篩選訂單的功能。
        *   允許管理員查看訂單詳情、修改訂單狀態（例如 '處理中', '已完成', '已取消'）。
        *   將狀態變更請求發送到後端。
    *   **後端 , Firestore)**:
        *   接收訂單狀態變更請求。
        *   更新 Firestore 中 `orders` 集合對應記錄的狀態。
        *   可能觸發相關通知（例如通知廚房或員工）。

---

這涵蓋了主要功能的邏輯分解。其他管理員功能如庫存、銷售、評估、公告、通知、公投、培訓、回饋、參數設定等的邏輯，也遵循類似的模式：前端提供 UI 進行操作配置，後端 Cloud Functions 接收請求、執行業務邏輯並更新 Firestore 中的數據。





好的，這是一項關鍵工作，能讓概念轉化為可執行的藍圖。我將針對您先前指出的邏輯不清晰項目，規劃出更詳細的**邏輯架構**或**偽代碼 (Pseudocode)** 描述。

請注意，這些是**建議的邏輯框架**，實際執行時可能需要根據更細節的業務需求進行調整。

---

**1. 推薦註冊 - 激活條件追蹤邏輯 (4.2)**

* **觸發時機：** 新租戶完成註冊流程後，記錄推薦碼使用情況；或當租戶上架商品、完成訂單時檢查。
* **涉及資料：** `ReferralUsages` (記錄誰用了誰的碼，狀態), `Tenants` (租戶資訊), `Products` (商品), `Orders` (訂單), `ReferralRules` (超級管理員設定的規則)
* **邏輯架構 (Cloud Function - `onTenantActivity`)：**
    1.  `FUNCTION onTenantActivity(tenantId, activityType, data)`:
    2.  `Workspace ReferralUsage WHERE inviteeTenantId = tenantId AND status = 'pending'`
    3.  IF `ReferralUsage` not found OR status != 'pending', `RETURN` (無效或已激活)
    4.  `Workspace ReferralRule WHERE ruleId = ReferralUsage.ruleId` (獲取當前激活規則)
    5.  `SWITCH activityType`:
        * `CASE 'signup'`:
            * IF `ReferralRule.activationCondition == 'signup_complete'`, `ACTIVATE_REFERRAL(ReferralUsage)`
        * `CASE 'product_uploaded'`:
            * IF `ReferralRule.activationCondition == 'N_products'`:
                * `COUNT products WHERE tenantId = tenantId`
                * IF `count >= ReferralRule.threshold`, `ACTIVATE_REFERRAL(ReferralUsage)`
        * `CASE 'order_completed'`:
            * IF `ReferralRule.activationCondition == 'M_customer_orders'`:
                * `Workspace distinct customerId FROM Orders WHERE tenantId = tenantId AND status = 'completed'` (需要高效查詢，可能需額外計數器)
                * `distinctCustomerCount = result.length`
                * IF `distinctCustomerCount >= ReferralRule.threshold`, `ACTIVATE_REFERRAL(ReferralUsage)`
    6.  `FUNCTION ACTIVATE_REFERRAL(usageRecord)`:
        * `UPDATE usageRecord SET status = 'activated', activatedAt = NOW()`
        * `TRIGGER RewardDistribution(usageRecord.inviterTenantId, usageRecord.ruleId)` // 觸發獎勵發放邏輯 (另一個 Function)

---

**2. 線下點餐 - 資源限制檢查邏輯 (4.4)**

* **觸發時機：** 員工嘗試執行可能受限的操作時（如：送出訂單、新增員工）。
* **涉及資料：** `Tenants` (含 planType, customLimits), `TenantUsageStats` (追蹤用量), `PlanDefinitions` (各方案限制)
* **邏輯架構 (Cloud Function - `checkTenantLimit`)：**
    1.  `FUNCTION checkTenantLimit(tenantId, actionType)`:
    2.  `Workspace Tenant data WHERE tenantId = tenantId`
    3.  `Workspace PlanDefinition WHERE planType = Tenant.planType`
    4.  `limit = Tenant.customLimits[actionType] OR PlanDefinition.limits[actionType]` // 檢查是否有客製化限制，否則用方案預設
    5.  IF `limit == null` OR `limit == 'unlimited'`, `RETURN { allowed: true }` // 無限制或未定義
    6.  `Workspace TenantUsageStats WHERE tenantId = tenantId` (可能需即時計算或定期更新)
    7.  `currentUsage = TenantUsageStats[actionType]` // 例如: stats.monthlyOrders, stats.activeEmployees
    8.  IF `currentUsage < limit`:
        * `RETURN { allowed: true }`
    9.  ELSE:
        * `RETURN { allowed: false, message: "已達方案限制 (${actionType})" }`

---

**3 & 4. 會員系統 - 點數計算/兌換 & 自動化活動邏輯**

* **點數計算 (訂單完成觸發)：**
    * `FUNCTION calculatePoints(orderId)`:
        1.  `Workspace Order WHERE orderId = orderId`
        2.  `Workspace TenantPointRule WHERE tenantId = Order.tenantId` (規則：消費 N 元得 1 點，或百分比)
        3.  `pointsEarned = CALCULATE points based on Order.totalAmount and TenantPointRule`
        4.  `UPDATE Customer data SET points = points + pointsEarned WHERE customerId = Order.customerId`
        5.  `RECORD PointTransaction(customerId, orderId, pointsEarned, 'earn')`
* **點數兌換 (API 端點)：**
    * `FUNCTION redeemPoints(customerId, itemId)`:
        1.  `Workspace Customer data WHERE customerId = customerId`
        2.  `Workspace RedeemableItem WHERE itemId = itemId AND tenantId = Customer.tenantId`
        3.  IF `Customer.points >= RedeemableItem.pointsRequired`:
            * `UPDATE Customer data SET points = points - RedeemableItem.pointsRequired`
            * `RECORD PointTransaction(customerId, itemId, RedeemableItem.pointsRequired, 'redeem')`
            * `GRANT item/coupon to customer`
            * `RETURN { success: true }`
        4.  ELSE:
            * `RETURN { success: false, message: "點數不足" }`
* **自動化活動 (Cloud Scheduler + Function - e.g., `dailyAutomatedCampaigns`)：**
    * `FUNCTION dailyAutomatedCampaigns()`:
        1.  `today = GET_CURRENT_DATE()`
        2.  // 生日禮
        3.  `Workspace Customers WHERE birthDateMonthDay == today.MonthDay AND tenantId = 'specific_tenant'` (或遍歷所有租戶)
        4.  `Workspace BirthdayCampaignRule WHERE tenantId = 'specific_tenant'`
        5.  `FOR EACH customer in results`:
            * `IF rule.active AND customer not received birthday gift this year`: // 需記錄發送狀態
                * `GRANT BirthdayCoupon/Points to customer`
                * `MARK customer as received birthday gift this year`
        6.  // 指定日期發券
        7.  `Workspace DateBasedCampaignRule WHERE activationDate == today AND tenantId = 'specific_tenant'`
        8.  `IF rule.active`:
            * `FIND target customers based on rule.criteria` (e.g., all members, specific tags)
            * `FOR EACH target_customer`:
                * `GRANT CampaignCoupon to target_customer` // 需處理大量發送效能

---

**5. 庫存管理 - 庫存差異計算與報告生成邏輯**

* **觸發時機：** 盤點流程結束後。
* **涉及資料：** `InventoryItems` (理論庫存), `Stocktakes` (盤點記錄), `StocktakeItems` (盤點數量)
* **邏輯架構 (Cloud Function - `generateStocktakeReport`)：**
    1.  `FUNCTION generateStocktakeReport(stocktakeId)`:
    2.  `Workspace Stocktake record WHERE id = stocktakeId`
    3.  `Workspace StocktakeItems WHERE stocktakeId = stocktakeId`
    4.  `report = { stocktakeId, date, storeId, items: [] }`
    5.  `totalDifferenceValue = 0`
    6.  `FOR EACH item in StocktakeItems`:
        * `Workspace InventoryItem WHERE id = item.itemId AND storeId = Stocktake.storeId`
        * `theoreticalQty = InventoryItem.stockQty` // 盤點開始時的理論庫存 (可能需要快照)
        * `actualQty = item.countedQty`
        * `differenceQty = actualQty - theoreticalQty`
        * `differenceValue = differenceQty * InventoryItem.costPrice` // 需有成本價欄位
        * `report.items.push({ itemId, itemName: InventoryItem.name, theoreticalQty, actualQty, differenceQty, differenceValue })`
        * `totalDifferenceValue += differenceValue`
        7.  `report.summary = { totalItems: report.items.length, totalDifferenceValue }`
    8.  `SAVE report to StocktakeReports collection`
    9.  `RETURN report`

---

**6. 進階報表 - 後端獲取分析數據的邏輯**

* **範例：計算特定時段熱銷商品排行 (API 端點)**
    * `FUNCTION getTopSellingProducts(storeId, startDate, endDate)`:
        1.  `Workspace Orders WHERE storeId = storeId AND createdAt >= startDate AND createdAt <= endDate AND status = 'completed'`
        2.  `productSales = {}` // 使用 Map 或 Object 累計
        3.  `FOR EACH order in Orders`:
            * `FOR EACH item in order.items`:
                * `productId = item.productId`
                * `IF productSales[productId] exists`:
                    * `productSales[productId].quantity += item.quantity`
                    * `productSales[productId].totalRevenue += item.quantity * item.price`
                * ELSE:
                    * `productSales[productId] = { name: item.name, quantity: item.quantity, totalRevenue: item.quantity * item.price }`
        4.  `Convert productSales Map to Array`
        5.  `SORT Array by quantity DESC` (或 totalRevenue DESC)
        6.  `RETURN top N results` (e.g., top 10)

* **範例：計算客單價 (Average Order Value)**
    * `FUNCTION getAOV(storeId, date)`:
        1.  `Workspace Orders WHERE storeId = storeId AND date(createdAt) == date AND status = 'completed'`
        2.  IF `Orders.length == 0`, `RETURN 0`
        3.  `totalRevenue = SUM(order.totalAmount for order in Orders)`
        4.  `aov = totalRevenue / Orders.length`
        5.  `RETURN aov`

---

**7. 排班管理 - 自動排班演算法 (概念性步驟)**

* **目標：** 在滿足約束條件下，為指定時段生成人力成本最低或滿意度最高的班表。
* **輸入：**
    * `Store ID`, `Date Range`
    * `Staffing Requirements`: `{ timeSlot: "09-12", requiredRoles: { "櫃台": 1, "廚房": 2 } }`
    * `Employee List`: `[{ id, name, roles: ["櫃台", "廚房"], availability: ["Mon", "Tue"], maxHours: 40, preferences: [...] }]`
    * `Leave Records`
    * `Labor Laws`: Max consecutive hours, min rest time, max weekly hours.
* **核心邏輯 (可能使用約束滿足求解器或啟發式算法)：**
    1.  **初始化：** 建立空的班表時間格。
    2.  **過濾：** 排除休假、不符合資格的員工。
    3.  **約束傳播/初步分配：**
        * 對於每個必須滿足的時段/角色，找出唯一能滿足的員工並優先分配。
        * 更新員工剩餘可用工時。
    4.  **迭代/搜索：**
        * 選擇一個未分配的時段/角色需求。
        * 找出所有符合資格（角色、可用時間、未超時）的候選員工。
        * 根據**評分函數**（考慮偏好、公平性、成本等）選擇最佳員工進行分配。
        * 如果找不到人，可能需要回溯或標記為無法滿足。
    5.  **驗證：** 檢查最終班表是否滿足所有硬性約束（法規、人力需求）。
    6.  **輸出：** 生成 `Shifts` 記錄 (狀態為 `draft`)。
* **注意：** 這是高度複雜的問題，通常建議使用現有排班庫或服務，或簡化規則（例如基於模板、輪替）。

---

**8 & 11 (部分). 薪資/排班 - 假期/出勤扣款與薪資計算**

* **`calculatePayroll` (Cloud Function - 月底觸發)：**
    1.  `FUNCTION calculatePayroll(employeeId, monthYear)`: // e.g., "2024-05"
    2.  `Workspace Employee WHERE employeeId = employeeId`
    3.  `Workspace PayrollConfig FOR tenantId = Employee.tenantId` (含時薪/月薪制, 加班倍率, 遲到早退扣款規則, 全勤獎金規則)
    4.  `Workspace AttendanceRecords WHERE employeeId = employeeId AND month(timestamp) = monthYear`
    5.  `Workspace Approved LeaveRequests WHERE employeeId = employeeId AND date falls within monthYear`
    6.  `Workspace BonusRecords WHERE employeeId = employeeId AND appliesToMonth = monthYear`
    7.  `// 計算工時與出勤`
    8.  `totalHours = 0, regularHours = 0, overtimeHours = 0, leaveHours = 0, lateCount = 0, earlyLeaveCount = 0`
    9.  `PROCESS AttendanceRecords and Shifts to calculate hours, late/early counts`
    10. `PROCESS LeaveRequests to calculate leaveHours by type`
    11. `// 計算薪資組成`
    12. `basePay = CALCULATE base pay (月薪制 or regularHours * 時薪)`
    13. `overtimePay = overtimeHours * 時薪 * PayrollConfig.overtimeMultiplier`
    14. `lateDeduction = lateCount * PayrollConfig.lateDeductionAmount` // 或更複雜規則
    15. `earlyLeaveDeduction = earlyLeaveCount * PayrollConfig.earlyLeaveDeductionAmount`
    16. `leaveDeduction = CALCULATE based on leaveHours and leave type rules (e.g., 事假扣全薪, 病假半薪)`
    17. `fullAttendanceBonus = CHECK if qualified based on PayrollConfig and attendance data`
    18. `otherBonuses = SUM(BonusRecords.amount)`
    19. `// 其他代扣 (勞健保等 - 需要外部輸入或配置)`
    20. `insuranceDeduction = GET_INSURANCE_DEDUCTION(basePay)` // 需規則
    21. `finalSalary = basePay + overtimePay + fullAttendanceBonus + otherBonuses - lateDeduction - earlyLeaveDeduction - leaveDeduction - insuranceDeduction`
    22. `SAVE Payroll record with detailed breakdown`

---

**10 & 12. 薪資/績效 - 指標影響與考核邏輯**

* **績效指標影響獎金/薪資 (示例規則)：**
    * **規則來源：** `PerformanceBonusRules` (由租戶配置)
    * **示例1 (銷售額掛鉤)：**
        * `IF monthlySales >= targetSales * 1.2 THEN bonus += baseSalary * 0.1`
        * `ELSE IF monthlySales >= targetSales THEN bonus += baseSalary * 0.05`
    * **示例2 (顧客評價掛鉤)：**
        * `averageRating = CALCULATE average rating for employee this month`
        * `IF averageRating >= 4.8 THEN bonus += 500`
        * `ELSE IF averageRating < 4.0 THEN deduction += 200`
    * **整合:** `calculatePayroll` Function 中加入讀取規則、計算指標、應用獎懲的步驟。
* **晉升/降級觸發 (示例規則)：**
    * **觸發時機:** 定期評估週期結束後 (e.g., 每季/半年)
    * **`evaluatePromotionDemotion(employeeId)`:**
        1.  `Workspace past N evaluation scores/ranks for employeeId`
        2.  `Workspace PromotionDemotionRules FOR tenantId`
        3.  `// 晉升條件`
        4.  `IF averageRank == 'S' for past N periods AND meets TenureRequirement`:
            * `TRIGGER PromotionVote(employeeId)` OR `MARK as eligible for promotion review`
        5.  `// 降級條件`
        6.  `IF averageRank == 'C' for past M periods`:
            * `TRIGGER DemotionReview(employeeId)` OR `MARK for performance improvement plan`
        7.  *投票邏輯需另行定義 (誰投票、通過門檻)*

---

**13. 顧客評價 - LINE Bot 互動流程 & Webhook**

* **發送時機：** 訂單狀態變為 `completed` 後 N 分鐘 (透過 Cloud Tasks 延遲觸發)。
* **Bot 流程 (範例 - 使用 LINE Flex Message)：**
    1.  推送消息: "感謝您光臨[店名]！請對本次消費體驗評分 (1-5星)" + 星星按鈕。
    2.  用戶點擊星星 -> 觸發 Postback Action，將 `orderId` 和 `rating` 送回 Webhook。
    3.  Webhook 收到評分後，回覆: "謝謝您的評分！願意分享更多建議嗎？(選填)" + 文字輸入提示 或 快速回覆按鈕 (e.g., "餐點好吃", "服務很好", "環境乾淨")。
    4.  用戶輸入文字或點擊按鈕 -> 再次送回 Webhook。
* **Webhook (`lineWebhook` Cloud Function)：**
    1.  `VERIFY LINE Signature`
    2.  `PARSE request body events`
    3.  `FOR EACH event in events`:
        * `IF event.type == 'postback'`:
            * `data = PARSE event.postback.data` (包含 orderId, rating)
            * `SAVE rating to Feedback collection WHERE orderId = data.orderId` (或更新記錄)
            * `REPLY with comment request message`
        * `IF event.type == 'message' AND event.message.type == 'text'`:
            * // 需要判斷此消息是否是對應評價的回覆 (e.g., 根據 userId 和時間戳關聯)
            * `FIND relevant Feedback record`
            * `UPDATE Feedback record SET comment = event.message.text`
            * `REPLY with thank you message`

---

**15. 系統管理 - 參數設定衝突解決**

* **讀取邏輯 (範例 - 獲取某分店的打卡半徑)：**
    * `FUNCTION getSetting(key, storeId, tenantId)`:
        1.  `Workspace Store WHERE id = storeId`
        2.  IF `Store.settings[key]` exists AND `Store.settings[key] != 'inherit'`, `RETURN Store.settings[key]`
        3.  `Workspace Tenant WHERE id = tenantId`
        4.  IF `Tenant.settings[key]` exists AND `Tenant.settings[key] != 'inherit'`, `RETURN Tenant.settings[key]`
        5.  `Workspace GlobalSettings`
        6.  IF `GlobalSettings[key]` exists, `RETURN GlobalSettings[key]`
        7.  `RETURN DefaultConfig[key]` // 返回程式碼中的預設值

* **儲存/更新邏輯：** 前端 UI 應明確區分是在修改 全局、租戶 還是 分店 設定，並將請求發送到對應的後端 API，後端只更新指定層級的文件。

---

**16. 系統管理 - 操作日誌記錄規則**

* **通用日誌結構：**
    ```json
    {
      "timestamp": "Timestamp",
      "userId": "操作者UID", // 或 system
      "userIp": "來源IP", // (盡力獲取)
      "action": "執行的動作 (e.g., LOGIN, UPDATE_ORDER_STATUS, CREATE_EMPLOYEE)",
      "targetType": "操作對象類型 (e.g., ORDER, EMPLOYEE, SETTING)",
      "targetId": "操作對象ID",
      "tenantId": "相關租戶ID", // (若適用)
      "storeId": "相關分店ID", // (若適用)
      "details": { // 可選，依動作不同
        "fieldChanges": [ { "field": "status", "oldValue": "pending", "newValue": "preparing" } ], // for updates
        "parameters": { "employeeName": "王小明", "role": "staff" }, // for creates
        "reason": "管理員調整" // (若適用)
      }
    }
    ```
* **觸發點：** 在執行**關鍵**或**敏感**操作的 Cloud Function **成功執行後**，異步寫入 `AuditLogs` 集合。
* **需要記錄的動作 (示例)：**
    * 登入/登出
    * 權限變更 (角色分配、權限修改)
    * 員工資料 CUD
    * 訂單狀態修改 (尤其是取消、完成)
    * 菜單價格修改
    * 薪資發放/調整
    * 重要系統參數修改
    * 租戶啟用/停用

---


---

**1. 完整的 Firestore 安全規則 (`firestore.rules`) 範例**

**核心原則：**
* 預設拒絕所有存取。
* 基於 `request.auth.uid` 驗證使用者身份。
* 利用 `get()` 或 `exists()` 函數讀取用戶的角色/租戶資訊 (通常儲存在 `users` 或 `employees` 集合)。
* **強制執行租戶隔離 (Tenant Isolation)**：大多數規則都應檢查請求者是否屬於文件所屬的租戶 (`tenantId`) 或分店 (`storeId`)。
* 區分不同角色的權限 (Super Admin, Tenant Admin, Staff, Customer)。

**範例規則 (草稿 - 需要根據最終資料模型調整)：**

```javascript
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // 函數：檢查使用者是否為超級管理員
    function isSuperAdmin() {
      // 假設超級管理員的 UID 列表儲存在特定文檔或其 custom claims 中
      // return request.auth.uid in ['SUPER_ADMIN_UID_1', 'SUPER_ADMIN_UID_2'];
      return get(/databases/$(database)/documents/admins/$(request.auth.uid)).data.isSuperAdmin == true;
    }

    // 函數：獲取使用者的租戶 ID 和角色
    function getUserInfo(userId) {
      return get(/databases/$(database)/documents/employees/$(userId)).data;
      // 或者 users 集合，視最終設計而定
    }

    // 函數：檢查使用者是否為指定租戶的管理員
    function isTenantAdmin(tenantId) {
      let userInfo = getUserInfo(request.auth.uid);
      return request.auth != null && userInfo.tenantId == tenantId && (userInfo.role == 'TenantAdmin' || userInfo.role == 'TenantOwner');
    }

    // 函數：檢查使用者是否為指定租戶的員工 (含管理員)
    function isTenantStaff(tenantId) {
      let userInfo = getUserInfo(request.auth.uid);
      return request.auth != null && userInfo.tenantId == tenantId && (userInfo.role == 'TenantAdmin' || userInfo.role == 'TenantOwner' || userInfo.role == 'StoreManager' || userInfo.role == 'Staff');
    }

    // 函數：檢查使用者是否為指定分店的員工 (含管理員)
    function isStoreStaff(storeId) {
      let userInfo = getUserInfo(request.auth.uid);
      // 假設 storeId 直接存在 userInfo 或需要透過 storeId 查詢 tenantId 再驗證
      // let storeInfo = get(/databases/$(database)/documents/stores/$(storeId)).data;
      return request.auth != null && userInfo.assignedStores.hasAny([storeId]) && isTenantStaff(userInfo.tenantId); // 假設 assignedStores 是 array
    }

    // === 規則應用 ===

    // 租戶資料表 (Tenants)
    match /tenants/{tenantId} {
      // 超級管理員可以讀寫所有租戶資料
      allow read, write: if isSuperAdmin();
      // 租戶管理員可以讀取自己租戶的資料
      allow get: if isTenantAdmin(tenantId);
      // 一般不允許直接創建/刪除，由後端 Function 處理
      allow create, delete: if false;
      // 允許租戶管理員更新特定欄位 (透過後端 Function 更安全)
      allow update: if isTenantAdmin(tenantId) && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['name', 'contactInfo', 'publicProfile']); // 限制可更新欄位
    }

    // 分店資料表 (Stores)
    match /stores/{storeId} {
      // 超級管理員可讀寫
      allow read, write: if isSuperAdmin();
      // 該租戶的員工可以讀取其所屬分店資料
      allow get: if isTenantStaff(resource.data.tenantId);
      // 租戶管理員可以更新其租戶下的分店資料
      allow update: if isTenantAdmin(resource.data.tenantId);
      // 創建/刪除通常由後端 Function 處理
      allow create, delete: if isTenantAdmin(request.resource.data.tenantId); // 允許租戶管理員新增/刪除分店
    }

    // 員工資料表 (Employees)
    match /employees/{userId} {
      // 本人可以讀取自己的資料
      allow get: if request.auth.uid == userId;
      // 該租戶的管理員可以讀取該租戶下所有員工資料
      allow list: if isTenantAdmin(getUserInfo(request.auth.uid).tenantId); // 讀取列表
      allow get: if isTenantAdmin(resource.data.tenantId); // 讀取單筆
      // 租戶管理員可以更新員工資料 (通常是角色、狀態等)
      allow update: if isTenantAdmin(resource.data.tenantId);
      // 本人可以更新部分欄位 (如聯絡方式)
      allow update: if request.auth.uid == userId && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['phone', 'emergencyContact']);
      // 只有管理員能創建/刪除 (或透過邀請流程)
      allow create: if isTenantAdmin(request.resource.data.tenantId);
      allow delete: if isTenantAdmin(resource.data.tenantId);
    }

    // 訂單資料表 (Orders)
    match /orders/{orderId} {
      // 顧客：可以創建訂單 (需驗證請求內容)；可以讀取自己的訂單
      allow create: if request.auth != null; // 任何人可創建，但後端 Function 需驗證
      allow get: if request.auth != null && (getUserInfo(request.auth.uid) != null && getUserInfo(request.auth.uid).tenantId == resource.data.tenantId || resource.data.customerId == request.auth.uid) ; // 顧客或同租戶員工可讀
      // 員工：可以讀取其所屬分店的訂單；可以更新訂單狀態
      allow list: if isStoreStaff(request.query.storeId); // 假設查詢時會帶 storeId
      allow get: if isStoreStaff(resource.data.storeId);
      allow update: if isStoreStaff(resource.data.storeId) && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'assignedStaffId', 'completionTime']); // 限制可更新欄位
      // 管理員：可以讀寫其租戶下的所有訂單 (但修改應謹慎)
      allow read, update: if isTenantAdmin(resource.data.tenantId);
      // 一般不允許直接刪除訂單
      allow delete: if false; // 或 isTenantAdmin(resource.data.tenantId)
    }

    // 其他集合 (如 Menus, Settings, AttendanceRecords, Payrolls 等) 需依此類推
    // 例如：菜單 (Menus)
    match /menus/{menuId} {
      allow read: if true; // 假設菜單公開可讀
      allow write: if isTenantAdmin(resource.data.tenantId); // 只有租戶管理員可寫
    }

    // 全局設定 (假設單一文檔)
    match /configs/globalSettings {
      allow read: if request.auth != null; // 登入用戶可讀
      allow write: if isSuperAdmin(); // 只有超管可寫
    }

    // 租戶設定
    match /settings/{tenantId} {
       allow read: if isTenantStaff(tenantId); // 租戶員工可讀
       allow write: if isTenantAdmin(tenantId); // 租戶管理員可寫
    }

  }
}
```
**重要提醒：** 這只是範例草稿，實際規則需要根據最終確定的資料模型、使用者角色、具體權限需求來編寫，並且**務必使用 Firebase Emulator Suite 進行完整測試**。

---

**2. 具體的端對端 (End-to-End) 測試案例**

以下列出幾個關鍵流程的 E2E 測試案例：

* **案例 1：顧客線上點餐 (LINE Pay 付款) 到取餐**
    1.  **前提：** 店家 (租戶) 已設定好菜單、啟用 LINE Pay。顧客已登入會員 (LINE Login)。
    2.  **步驟：**
        * (顧客) 進入線上點餐 PWA。
        * (顧客) 瀏覽菜單，將「脆皮雞排」\*1、「紅茶」\*1 加入購物車。
        * (顧客) 前往結帳，選擇「LINE Pay」。
        * (系統) 跳轉至 LINE Pay 付款頁面。
        * (顧客) 在 LINE Pay 中確認付款。
        * (系統) 接收 LINE Pay 付款成功回調，建立 Firestore `orders` 文件 (狀態 `pending` 或 `paid`)，觸發後端 Function。
        * (後端 Function) 驗證付款，更新訂單狀態為 `preparing`，（若有設定）推送新訂單通知給店家 PWA 或 KDS。
        * (店家員工) 在員工端 PWA/KDS 看到新訂單，點擊「開始製作」。
        * (系統) 更新訂單狀態為 `in_progress`。
        * (店家員工) 完成製作，點擊「完成訂單」。
        * (系統) 更新訂單狀態為 `completed`，產生取餐號碼。
        * (系統) （若有設定）透過 LINE Notify 發送取餐通知給顧客。
        * (顧客) 收到通知，前往取餐。
        * (店家員工) 核對取餐號碼，交付餐點，（可選）在系統標記為「已取餐」。
        * (系統) （延遲任務）發送顧客評價邀請 (LINE Bot)。
    3.  **預期結果：** 訂單成功建立並付款，狀態流轉正確，店家與顧客皆收到正確通知，最終訂單完成。Firestore 訂單記錄完整。
    4.  **涉及系統/模組：** 前端 PWA (顧客/員工)、Firestore、Cloud Functions、LINE Login、LINE Pay API、LINE Notify API。

* **案例 2：員工 GPS 打卡與薪資計算**
    1.  **前提：** 員工已綁定 LINE，排班表已設定，薪資規則已設定。
    2.  **步驟：**
        * (員工) 上班時間到達分店附近，開啟員工端 PWA。
        * (員工) 點擊「上班打卡」。
        * (系統) PWA 獲取 GPS 位置，發送打卡請求至後端。
        * (後端 Function) 驗證 GPS 位置是否在分店範圍內，驗證是否在允許打卡時間內，寫入 `attendanceRecords`。
        * (員工) 下班時間點擊「下班打卡」，重複 GPS 驗證與記錄流程。
        * (系統 - 月底排程) Cloud Function 觸發 `calculatePayroll`。
        * (後端 Function) 讀取該員工本月所有 `attendanceRecords`、`leaveRequests`、`bonusRecords` 及薪資規則。
        * (後端 Function) 計算出勤時數、遲到早退次數、加班時數、請假扣款、獎金總額。
        * (後端 Function) 根據公式計算最終薪資，寫入 `payrolls` 文件。
        * (員工) 在 PWA 中查詢本月薪資單。
    3.  **預期結果：** 打卡記錄成功寫入，月底薪資計算正確，員工能查看到包含出勤、獎金、扣款明細的薪資單。
    4.  **涉及系統/模組：** 前端 PWA (員工)、Firestore、Cloud Functions、GPS 定位、Cloud Scheduler。

* **案例 3：租戶管理員設定菜單與促銷活動**
    1.  **前提：** 租戶管理員已登入後台。
    2.  **步驟：**
        * (管理員) 進入「菜單管理」頁面。
        * (管理員) 新增一項商品「特製炸雞翅」，設定價格、描述、圖片、分類。
        * (管理員) 將「紅茶」標記為「今日停售」。
        * (系統) 更新 Firestore `menus` 或 `products` 集合。
        * (管理員) 進入「行銷活動」頁面。
        * (管理員) 建立一個新活動「平日午間套餐」，設定活動時間、適用商品組合、優惠價格。
        * (系統) 更新 Firestore `campaigns` 或相關集合。
        * (顧客) 進入該店線上點餐 PWA。
        * (顧客) 應能看到「特製炸雞翅」，看不到「紅茶」，並能點選「平日午間套餐」。
    3.  **預期結果：** 菜單和活動設定成功更新，並即時（或經過短暫延遲後）反映在顧客點餐介面。
    4.  **涉及系統/模組：** 前端 PWA (管理後台/顧客)、Firestore、Cloud Functions (可能用於驗證或觸發更新)。

---

**3. PWA 離線資料同步策略**

**目標：** 在網路不穩定或離線時，保障核心操作（點餐、打卡）的可用性，並在網路恢復時可靠地同步資料。

**策略：**

1.  **離線快取資料 (Cache First / Stale-While-Revalidate):**
    * **使用技術：** Service Worker + Cache API。
    * **快取內容：**
        * **靜態資源：** PWA 的 HTML, CSS, JavaScript, 圖標等。 (由 Service Worker 自動處理)
        * **應用程式資料 (讀取)：**
            * **菜單資料 (`menus`)：** 啟動時或定期更新時獲取，存入 IndexedDB 或 Cache Storage。離線時從快取讀取。
            * **店家基本設定 (`stores`, `settings`)：** 如營業時間、基本參數等。同上處理。
            * **員工基本資料/權限 (`employees` - 自身)：** 登入時獲取，存入 IndexedDB。
    * **更新策略：** 優先從快取提供，同時背景請求新資料 (Stale-While-Revalidate)。若請求成功則更新快取，下次載入時使用新資料。若請求失敗則繼續使用舊快取。菜單等核心資料可考慮設置較短的快取有效期或提供手動刷新機制。

2.  **離線操作處理 (Queueing):**
    * **使用技術：** IndexedDB + Service Worker (Background Sync API - 若瀏覽器支援，否則手動隊列)。
    * **處理流程：**
        * **偵測網路狀態：** 使用 `navigator.onLine`。
        * **執行操作 (e.g., 點餐、打卡)：**
            * **若在線：** 正常發送 API 請求至後端 Cloud Function。
            * **若離線：**
                * 將操作數據（包含時間戳、唯一 ID、操作類型、數據內容）儲存到 **IndexedDB 的「待同步隊列」(syncQueue)**。
                * **重要：** 必須包含足夠資訊以便後端重現操作（例如，點餐要包含完整訂單內容，打卡要包含 GPS 座標和精確時間戳）。
                * **前端狀態更新：** UI 上可以先顯示「已暫存」或類似狀態，讓使用者知道操作已被記錄。對於訂單，可以先在本地列表中顯示。
    * **同步機制：**
        * **觸發時機：**
            * 網路恢復 (`online` 事件觸發)。
            * PWA 啟動時檢查隊列。
            * (若使用 Background Sync API) 瀏覽器會在網路恢復時自動觸發 Service Worker 的 `sync` 事件。
        * **執行同步：**
            * 讀取 IndexedDB `syncQueue` 中的待辦事項。
            * **依序**將隊列中的操作數據發送到對應的後端 API。
            * **成功處理：** 後端 API 成功回應後，從 IndexedDB `syncQueue` 中移除該筆記錄。
            * **失敗處理：**
                * **暫時性錯誤 (e.g., 5xx)：** 保留記錄，稍後重試（可實現指數退避策略）。
                * **永久性錯誤 (e.g., 4xx - 資料驗證失敗)：** 標記為失敗，從隊列移除，並在 UI 上提示使用者該操作失敗，可能需要手動處理（例如，提示訂單建立失敗）。

3.  **資料衝突處理：**
    * **原則：** 盡量以**伺服器端為權威 (Server Authoritative)**。
    * **讀取衝突：** 離線時讀取的是快取資料，可能過時。在同步或重新連線後，應優先獲取伺服器最新數據更新本地快取和 UI。
    * **寫入衝突 (較少見於此模型，因操作多為新增)：**
        * **點餐/打卡：** 主要是新增記錄，衝突較少。若後端有業務規則阻止（如重複打卡），API 應返回錯誤，前端按失敗處理。
        * **狀態更新 (若允許離線修改)：** 例如離線修改訂單備註。同步時，後端 API 應檢查文件的 `updatedAt` 時間戳或版本號。
            * **Last-Write-Wins (簡單)：** 直接覆蓋。
            * **基於時間戳/版本號：** 若客戶端版本舊於伺服器，則拒絕更新或嘗試合併（合併邏輯通常複雜，不建議輕易使用）。API 返回衝突錯誤，前端提示用戶。
    * **庫存：** 即時庫存管理在離線模式下極易衝突，這也是文件將其排除在範圍外的原因。若未來要實現，需設計更複雜的預留/核銷機制。

---

**4. 狀態管理機制（前端 PWA）**

**考量：** 由於未使用特定前端框架 (Vue, React)，需要一個輕量且易於整合的方案。

**建議方案：模組化的全域狀態物件 + 事件監聽/回調**

1.  **核心狀態物件 (`appState.js`)：**
    * 建立一個 JavaScript 物件或模組，用於存放共享的應用程式狀態。
    * **範例結構：**
        ```javascript
        const appState = {
          isOnline: navigator.onLine,
          currentUser: null, // { uid, name, role, tenantId, storeId, permissions: [] }
          currentStore: null, // { id, name, menuVersion, settings: {} }
          menu: [], // 菜單資料
          cart: { // 購物車 (點餐模組用)
            items: [],
            total: 0
          },
          syncQueueCount: 0, // 待同步項目數量
          // ... 其他需要的狀態
        };
        ```

2.  **狀態更新函數：**
    * 提供明確的函數來更新 `appState` 中的數據，而不是直接修改。
    * **範例：**
        ```javascript
        function setCurrentUser(userData) {
          appState.currentUser = userData;
          notifyStateChange('currentUser', userData); // 觸發事件
        }

        function updateOnlineStatus(isOnline) {
           appState.isOnline = isOnline;
           notifyStateChange('isOnline', isOnline);
        }

        function addItemToCart(item) {
          // ... 更新 appState.cart 邏輯 ...
          notifyStateChange('cart', appState.cart);
        }
        ```

3.  **狀態變更通知 (事件機制)：**
    * 當狀態更新時，需要通知相關的 UI 元件進行刷新。
    * **選項 A (自訂事件)：** 使用 `document.dispatchEvent` 和 `document.addEventListener`。
        ```javascript
        // 在 appState.js 中
        function notifyStateChange(stateName, newValue) {
          const event = new CustomEvent('appStateChanged', { detail: { stateName, newValue } });
          document.dispatchEvent(event);
        }

        // 在需要監聽的 UI 模組 JS 中 (e.g., header.js)
        document.addEventListener('appStateChanged', (event) => {
          const { stateName, newValue } = event.detail;
          if (stateName === 'currentUser') {
            updateHeaderUI(newValue); // 更新顯示用戶名稱
          } else if (stateName === 'isOnline') {
            updateOnlineIndicator(newValue); // 更新網路狀態圖標
          }
        });
        ```
    * **選項 B (回調函數)：** 維護一個訂閱者列表，狀態變更時調用註冊的回調。較為直接但管理可能稍複雜。
    * **選項 C (輕量級狀態庫)：** 若項目規模增大，可考慮引入如 Nano Stores, Zustand (需適配 Vanilla JS) 等極簡狀態管理器，它們通常內建了訂閱通知機制。

4.  **狀態初始化 (`init.js`)：**
    * PWA 啟動時，檢查本地儲存 (e.g., `localStorage` 檢查是否有登入 token)，嘗試恢復用戶狀態。
    * 監聽網路狀態變化 (`window.addEventListener('online', ...)` / `offline`) 並更新 `appState.isOnline`。
    * 獲取初始必要的資料（如店家設定、菜單）並存入 `appState`。

**優點：** 簡單、無框架依賴、易於理解。
**缺點：** 項目複雜時，事件管理可能變得混亂，需要良好組織。

---

**5. 詳細的設定檔管理方案**

**目標：** 實現全局、租戶、分店三層級的設定管理，支援繼承與覆蓋，並解決衝突。

**儲存結構 (Firestore)：**

* **`configs/globalSettings` (單一文件):**
    * 存放全局預設值和不可被租戶覆蓋的平台級設定。
    * `{ defaultPrinterTimeout: 15, platformFeeRate: 0.02, featureFlags: { newReporting: true }, ... }`
* **`tenants/{tenantId}` (租戶文件內嵌或子集合):**
    * 選項 A (內嵌): `tenants/{tenantId}` 文件中增加 `settings` map 欄位。
    * 選項 B (子集合): `tenants/{tenantId}/settings/config` (單一文件)。
    * 存放該租戶的特定設定，用於覆蓋全局設定。
    * `{ printerTimeout: 10, allowCustomDiscounts: true, loyaltyPointRate: 100, menuTheme: 'dark', ... }`
    * **特殊值:** 可以約定 `null` 或特定字串 (e.g., `"inherit"`) 表示繼承上層設定。
* **`stores/{storeId}` (分店文件內嵌或子集合):**
    * 同上，選項 A (內嵌 `settings`) 或選項 B (子集合 `stores/{storeId}/settings/config`)。
    * 存放該分店的特定設定，覆蓋租戶和全局設定。
    * `{ printerTimeout: 5, gpsFenceRadius: 50, defaultOrderType: 'takeout', posQuickButtons: [ ... ], ... }`
    * 同樣支援 `null` 或 `"inherit"`。

**讀取機制 (後端 Function - `getSetting`):**

這是先前定義的邏輯，再次強調其層級查詢順序：
`Store Specific -> Tenant Specific -> Global -> Hardcoded Default`

```javascript
// Cloud Function (假設在 Node.js 環境)
async function getSetting(key, storeId, tenantId) {
  const db = getFirestore(); // 初始化 Firestore

  // 1. 嘗試讀取分店設定
  if (storeId) {
    const storeRef = db.collection('stores').doc(storeId); // 或 settings 子集合路徑
    const storeSnap = await storeRef.get();
    if (storeSnap.exists && storeSnap.data().settings && storeSnap.data().settings[key] !== undefined && storeSnap.data().settings[key] !== 'inherit') {
      return storeSnap.data().settings[key];
    }
    // 如果 storeId 有了，通常 tenantId 也能從 storeSnap.data() 中獲取，避免重複查詢
    if (!tenantId && storeSnap.exists) {
       tenantId = storeSnap.data().tenantId;
    }
  }

  // 2. 嘗試讀取租戶設定
  if (tenantId) {
    const tenantRef = db.collection('tenants').doc(tenantId); // 或 settings 子集合路徑
    const tenantSnap = await tenantRef.get();
    if (tenantSnap.exists && tenantSnap.data().settings && tenantSnap.data().settings[key] !== undefined && tenantSnap.data().settings[key] !== 'inherit') {
      return tenantSnap.data().settings[key];
    }
  }

  // 3. 嘗試讀取全局設定
  const globalRef = db.collection('configs').doc('globalSettings');
  const globalSnap = await globalRef.get();
  if (globalSnap.exists && globalSnap.data()[key] !== undefined) {
    return globalSnap.data()[key];
  }

  // 4. 返回硬編碼的預設值 (或 null/undefined 表示無此設定)
  const defaultConfigs = { /* ... 定義預設值 ... */ };
  return defaultConfigs[key] !== undefined ? defaultConfigs[key] : null;
}
```
**前端應用：** 前端 PWA 在啟動時或需要時，透過呼叫一個後端 API (e.g., `GET /api/settings?storeId=xxx`) 來批量獲取當前情境下生效的所有設定，而不是頻繁調用 `getSetting`。後端 API 內部使用 `getSetting` 邏輯來組裝最終生效的設定集。

**寫入/管理機制：**

* **UI 區分：**
    * 超級管理後台：提供介面編輯 `configs/globalSettings` 文件。
    * 租戶管理後台：提供介面編輯 `tenants/{tenantId}` 的 `settings`。應能選擇「使用預設」或「自訂值」。
    * 分店管理後台（若允許）：提供介面編輯 `stores/{storeId}` 的 `settings`。同樣能選擇繼承或自訂。
* **後端 API：** 提供不同的 API 端點用於更新不同層級的設定，並在後端強制權限檢查 (如 `updateGlobalSetting`, `updateTenantSetting`, `updateStoreSetting`)。

**衝突解決：** 上述讀取機制的查詢順序 (`Store -> Tenant -> Global -> Default`) 本身就定義了衝突解決策略——**下層的具體設定會覆蓋上層的設定**。使用 `inherit` 或 `null` 值可以顯式地回退到繼承上層。

---

這些詳細的規劃應該能為 AI 或開發團隊提供更具體、可操作的實現方向。





好的，這份報告書已經相當完整。針對您希望進一步完善的幾個部分，我將根據專案的具體需求，規劃出更詳細的邏輯架構和內容建議：

-----

**1. 完整的 API 詳細規格文件 (結構與範例)**

一份好的 API 文件應包含每個端點的清晰說明。建議為每個 API 端點建立以下結構：

  * **1. 功能名稱 (Function Name):** 清晰描述 API 的用途 (e.g., 建立新訂單)。
  * **2. 端點 URL (Endpoint URL):** 相對路徑 (e.g., `/api/order/create`)。
  * **3. HTTP 方法 (Method):** `GET`, `POST`, `PUT`, `DELETE` 等。
  * **4. 描述 (Description):** 詳細說明此 API 的功能、目的與使用情境。
  * **5. 身份驗證/授權 (Authentication/Authorization):**
      * 是否需要登入？ (`是`/`否`)
      * 所需最低角色/權限級別 (e.g., `顧客`, `員工`, `分店管理員`, `租戶管理員`, `超級管理員`)。
  * **6. 請求參數 (Request Parameters - URL Params/Query String):**
      * 列表說明 URL 路徑參數或查詢字串參數（名稱、類型、是否必需、描述、範例）。
  * **7. 請求主體 (Request Body):**
      * **格式 (Format):** 通常是 `application/json`。
      * **欄位說明 (Schema):**
        | 欄位名稱    | 類型      | 是否必需 | 描述/驗證規則                 | 範例                      |
        | :---------- | :-------- | :------- | :---------------------------- | :------------------------ |
        | `storeId`   | `string`  | 是       | 訂單所屬分店 ID               | `"store-uuid-123"`        |
        | `items`     | `array`   | 是       | 訂購商品列表 (不可為空)       | `[{"menuId": "...", ...}]` |
        | `customerId`| `string`  | 否       | 顧客 ID (若為會員訂單)        | `"customer-uuid-456"`     |
        | `note`      | `string`  | 否       | 訂單備註 (最多 100 字)        | `"少冰"`                  |
        | `totalAmount`| `number` | 是       | 前端計算的總金額 (後端需再次驗證) | `160`                     |
        | ...         | ...       | ...      | ...                           | ...                       |
  * **8. 成功回應 (Success Response):**
      * **HTTP 狀態碼:** e.g., `200 OK`, `201 Created`。
      * **回應主體 (Response Body Schema):**
        | 欄位名稱  | 類型     | 描述             | 範例                      |
        | :-------- | :------- | :--------------- | :------------------------ |
        | `orderId` | `string` | 新建立的訂單 ID    | `"order-20240601-001"`    |
        | `status`  | `string` | 訂單初始狀態     | `"pending"`               |
        | ...       | ...      | ...              | ...                       |
  * **9. 錯誤回應 (Error Responses):**
      * 列出可能的錯誤情況及其回應。
          * **HTTP 狀態碼:** e.g., `400 Bad Request`, `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `500 Internal Server Error`。
          * **回應主體範例 (依先前定義的格式):**
            ```json
            // 範例：驗證失敗 (400)
            { "error": { "code": "INVALID_ARGUMENT", "message": "購物車項目不得為空" } }
            // 範例：權限不足 (403)
            { "error": { "code": "PERMISSION_DENIED", "message": "您無權在此分店下單" } }
            ```
  * **10. 請求/回應範例 (Examples):** 提供完整的 Request 和 Response JSON 範例。

**範例：套用結構到「建立新訂單」API**

  * **1. 功能名稱:** 建立新訂單
  * **2. 端點 URL:** `/api/order/create`
  * **3. HTTP 方法:** `POST`
  * **4. 描述:** 顧客或員工透過 PWA 提交新的訂單資料。後端將驗證資料、建立訂單記錄並返回訂單 ID。
  * **5. 身份驗證/授權:**
      * 需要登入: 是 (顧客或員工)
      * 所需角色: `顧客` 或 `員工` (及以上)
  * **6. 請求參數:** 無
  * **7. 請求主體:**
      * 格式: `application/json`
      * Schema: (如上表所示，包含 `storeId`, `items`, `customerId`?, `note`?, `totalAmount`, `paymentMethod` 等)
  * **8. 成功回應:**
      * 狀態碼: `201 Created`
      * Schema: (如上表所示，包含 `orderId`, `status`)
  * **9. 錯誤回應:**
      * `400 Bad Request`: `{ "error": { "code": "INVALID_ARGUMENT", "message": "請求格式錯誤或缺少必要欄位 (如 items)" } }`
      * `401 Unauthorized`: `{ "error": { "code": "UNAUTHENTICATED", "message": "用戶未登入" } }`
      * `403 Forbidden`: `{ "error": { "code": "PERMISSION_DENIED", "message": "無權在此分店操作" } }`
      * `500 Internal Server Error`: `{ "error": { "code": "INTERNAL_ERROR", "message": "伺服器內部錯誤" } }`
  * **10. 請求/回應範例:** (提供完整 JSON)

-----

**2. 補充次要資料表的詳細定義**

延續先前 `employees`, `orders` 的格式，補充幾個範例：

**📄 `AuditLogs`（操作日誌表）**

| 欄位名稱     | 類型       | 是否必需 | 描述/驗證規則                                  | 範例                             |
| :----------- | :--------- | :------- | :--------------------------------------------- | :------------------------------- |
| `logId`      | `string`   | 是       | 唯一日誌 ID (UUID 或 Firestore 自動產生)        | `"log-uuid-abc"`                 |
| `timestamp`  | `timestamp`| 是       | 操作發生的時間 (伺服器時間)                     | `Timestamp.now()`                |
| `userId`     | `string`   | 是       | 執行操作的使用者 Firebase UID (或 'system')   | `"user-uid-xyz"`                 |
| `userIp`     | `string`   | 否       | 操作者來源 IP (盡力獲取)                       | `"123.45.67.89"`                 |
| `action`     | `string`   | 是       | 執行的動作 (e.g., `UPDATE_ORDER_STATUS`)     | `"UPDATE_ORDER_STATUS"`          |
| `targetType` | `string`   | 是       | 操作對象類型 (e.g., `ORDER`, `EMPLOYEE`)      | `"ORDER"`                        |
| `targetId`   | `string`   | 是       | 操作對象的 ID                                  | `"order-20240601-001"`           |
| `tenantId`   | `string`   | 否       | 相關的租戶 ID                                  | `"tenant-uuid-123"`              |
| `storeId`    | `string`   | 否       | 相關的分店 ID                                  | `"store-uuid-456"`               |
| `details`    | `map`      | 否       | 包含操作細節的物件                             | `{"field": "status", "old": "pending", "new": "preparing"}` |

**📄 `LeaveRequests`（請假申請表）**

| 欄位名稱        | 類型       | 是否必需 | 描述/驗證規則                               | 範例                      |
| :-------------- | :--------- | :------- | :------------------------------------------ | :------------------------ |
| `requestId`     | `string`   | 是       | 唯一申請 ID (UUID)                          | `"leave-uuid-def"`        |
| `employeeId`    | `string`   | 是       | 申請人 Firebase UID                       | `"user-uid-abc"`          |
| `tenantId`      | `string`   | 是       | 租戶 ID                                     | `"tenant-uuid-123"`       |
| `storeId`       | `string`   | 是       | 申請時所屬分店 ID                         | `"store-uuid-456"`        |
| `leaveType`     | `string`   | 是       | 假別 (e.g., `SICK`, `PERSONAL`, `ANNUAL`)   | `"PERSONAL"`              |
| `startDate`     | `string`   | 是       | 請假開始日期 (YYYY-MM-DD)                   | `"2024-06-10"`            |
| `endDate`       | `string`   | 是       | 請假結束日期 (YYYY-MM-DD)                   | `"2024-06-11"`            |
| `reason`        | `string`   | 是       | 事由 (最多 200 字)                          | `"家中有事"`                |
| `status`        | `string`   | 是       | 狀態 (`PENDING`, `APPROVED`, `REJECTED`)    | `"PENDING"`               |
| `approvedBy`    | `string`   | 否       | 批准人 UID                                  | `"manager-uid-789"`       |
| `approvedAt`    | `timestamp`| 否       | 批准時間                                    | `Timestamp(...)`          |
| `rejectionReason`| `string`   | 否       | 駁回事由                                    | `"人力不足"`                |
| `createdAt`     | `timestamp`| 是       | 申請建立時間                                | `Timestamp.now()`         |

**📄 `Roles`（角色定義表 - 可能較少變動，也可考慮硬編碼或放在設定檔）**

| 欄位名稱       | 類型           | 是否必需 | 描述/驗證規則                   | 範例                                 |
| :------------- | :------------- | :------- | :------------------------------ | :----------------------------------- |
| `roleId`       | `string`       | 是       | 角色唯一標識 (e.g., `staff`)    | `"staff"`                            |
| `roleName`     | `string`       | 是       | 角色顯示名稱 (e.g., `分店員工`) | `"分店員工"`                         |
| `level`        | `number`       | 是       | 權限等級 (用於簡單比較)         | `10`                                 |
| `permissions`  | `array<string>`| 是       | 擁有的權限標識列表              | `["CLOCK_IN_OUT", "CREATE_ORDER"]` |
| `description`  | `string`       | 否       | 角色描述                        | `"負責前台點餐與結帳"`                 |

-----

**3. 更細緻的錯誤處理情境**

| 情境 (Scenario)                 | 觸發點/偵測方式                          | 後端回應 (範例)                                      | 前端 PWA 處理建議                                                                                                |
| :------------------------------ | :--------------------------------------- | :--------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------- |
| **LINE Pay 付款超時/失敗** | 1. 前端輪詢 LINE Pay API 確認狀態超時\<br\>2. 後端接收 LINE Pay Webhook 通知失敗 | API `GET /api/payment/status/{orderId}` 回應:\<br\>`{ "status": "failed", "reason": "TIMEOUT" }` | 1. 在 PWA 結帳頁面顯示「付款失敗或超時，請重新嘗試或選擇其他付款方式」。\<br\>2. 提供「重新付款」或「返回購物車」按鈕。 \<br\>3. 後端應確保訂單狀態未被錯誤更新為 `paid`。 |
| **離線點餐同步衝突 (庫存不足)** | 網路恢復後，前端發送離線訂單到 `/api/order/create`，後端檢查庫存發現不足。 | `400 Bad Request`\<br\>`{ "error": { "code": "INSUFFICIENT_STOCK", "message": "商品 [商品名] 庫存不足", "itemId": "..." } }` | 1. 從 IndexedDB `syncQueue` 移除該失敗訂單。\<br\>2. 在 PWA 中顯著提示使用者「訂單 [訂單號] 因 [商品名] 庫存不足而失敗，請重新下單。」\<br\>3. 將失敗訂單移至「失敗列表」供使用者查看/刪除。 |
| **離線打卡同步衝突 (重複打卡)** | 網路恢復後，前端發送離線打卡記錄到 `/api/attendance/clock`，後端發現該員工同類型打卡已存在。 | `409 Conflict`\<br\>`{ "error": { "code": "DUPLICATE_CLOCK_IN", "message": "今日已有上班打卡記錄" } }` | 1. 從 IndexedDB `syncQueue` 移除該失敗打卡記錄。\<br\>2. (可選) 在 PWA 中短暫提示「打卡記錄同步失敗：重複打卡」。通常此類錯誤可忽略，以伺服器記錄為準。 |
| **員工 GPS 定位失敗/未授權** | 前端 `navigator.geolocation.getCurrentPosition` 失敗或返回權限錯誤。 | (前端錯誤，不涉及後端 API)                             | 1. 在 PWA 打卡介面顯示明確錯誤訊息：「無法取得定位資訊，請檢查定位服務是否開啟並授權瀏覽器使用。」\<br\>2. 暫時禁用打卡按鈕，或點擊時再次提示錯誤。\<br\>3. (可選) 提供「回報問題」或「嘗試重新定位」按鈕。 |
| **呼叫外部 API 超時 (e.g., 雲端列印)** | 後端 Function 呼叫租戶設定的印表機 API (`POST /tenant-printer/print`) 時，請求超時。 | API `/api/order/create` (或觸發列印的 API) 可能成功建立訂單，但在列印步驟失敗。後端應記錄此失敗。 | 1. 訂單流程應能繼續，不能因為列印失敗而卡住。\<br\>2. 後端應有重試機制 (e.g., Cloud Tasks 重試)。\<br\>3. 若重試多次仍失敗，應透過系統通知 (e.g., Telegram) 告知管理員「分店 [分店名] 訂單 [訂單號] 雲端列印失敗」。\<br\>4. 前端 PWA 正常顯示訂單即可，不一定需要告知終端員工列印失敗（除非業務要求）。 |

-----

**4. 視覺化圖表建議**

  * **序列圖 (Sequence Diagram): 顧客線上點餐 (LINE Pay 付款)**

      * **參與者:** `顧客 PWA`, `後端 API Gateway/Functions`, `Firestore DB`, `LINE Login/LIFF`, `LINE Pay API`, `LINE Notify API`, `店家 PWA/KDS`
      * **流程:**
        1.  `顧客 PWA` --(瀏覽/加購物車)--\> `顧客 PWA` (本地狀態)
        2.  `顧客 PWA` --(請求結帳)--\> `後端 API`
        3.  `後端 API` --(驗證購物車/價格)--\> `Firestore DB`
        4.  `後端 API` --(建立 LINE Pay 交易請求)--\> `LINE Pay API`
        5.  `LINE Pay API` --(返回付款 URL)--\> `後端 API`
        6.  `後端 API` --(返回付款 URL)--\> `顧客 PWA`
        7.  `顧客 PWA` --(跳轉至)--\> `LINE Pay 付款頁`
        8.  (顧客在 LINE Pay 操作...)
        9.  `LINE Pay API` --(付款成功 Webhook)--\> `後端 API` (或前端輪詢/Redirect)
        10. `後端 API` --(驗證付款狀態)--\> `LINE Pay API`
        11. `後端 API` --(寫入訂單 `status: paid`)--\> `Firestore DB`
        12. `後端 API` --(觸發通知)--\> `店家 PWA/KDS` (透過 FCM 或 Firestore Listener)
        13. `後端 API` --(觸發延遲任務 for 通知/評價)--\> `Cloud Tasks` (假設)
        14. `Cloud Tasks` --(時間到，觸發 Function)--\> `後端 API`
        15. `後端 API` --(發送取餐通知)--\> `LINE Notify API`
        16. `LINE Notify API` --(通知)--\> `顧客 LINE`

  * **狀態機圖 (State Machine Diagram): Order Status**

      * **狀態 (States):**
          * `Draft` (草稿 - 僅限 POS 暫存)
          * `PendingPayment` (待付款 - 線上訂單已提交但未付款)
          * `Paid` (已付款/待處理 - 現場現金結帳或線上付款完成)
          * `Preparing` (製作中)
          * `ReadyForPickup` (可取餐)
          * `Completed` (已完成/已取餐)
          * `Cancelled` (已取消)
      * **轉換 (Transitions):**
          * `POS 暫存` --[儲存]--\> `Draft`
          * `Draft` --[送單]--\> `Paid` (若現金) / `PendingPayment` (若線上)
          * `顧客提交線上訂單` --\> `PendingPayment`
          * `PendingPayment` --[LINE Pay 付款成功]--\> `Paid`
          * `PendingPayment` --[付款失敗/超時/取消]--\> `Cancelled`
          * `Paid` --[店家接單/開始製作]--\> `Preparing`
          * `Preparing` --[製作完成]--\> `ReadyForPickup`
          * `ReadyForPickup` --[顧客取餐/員工確認]--\> `Completed`
          * `Paid`/`Preparing`/`ReadyForPickup` --[店家/顧客取消(依規則)]--\> `Cancelled`

-----

**5. 專案術語表 (Glossary)**

| 術語 (Term)             | 定義 (Definition)                                                                 |
| :---------------------- | :-------------------------------------------------------------------------------- |
| **租戶 (Tenant)** | 指使用此 SaaS 服務的獨立店家或品牌，擁有自己的資料和設定。                               |
| **夥伴 (Partner)** | 對店家員工的稱呼，系統內的使用者，具有不同職級與權限。                               |
| **超級管理員 (Super Admin)** | SaaS 服務的平台最高管理員，負責管理所有租戶、全局設定與平台營運。                   |
| **租戶管理員 (Tenant Admin)** | 店家或品牌的主要管理人，負責管理其租戶下的分店、員工、菜單、設定等。相當於「店長」或更高層級。 |
| **分店管理員 (Store Manager)** | (若有區分) 單一分店的日常營運負責人，權限低於租戶管理員。                          |
| **PWA (Progressive Web App)** | 漸進式網頁應用程式，提供類似原生 App 的體驗（如離線使用、安裝到主畫面），但透過瀏覽器存取。 |
| **GPS 圍欄 (GPS Fence)** | 為分店設定的地理範圍，用於限制員工打卡的有效區域。                                   |
| **雲端出單 (Cloud Print)** | 將列印任務透過網路 API 發送到租戶指定的遠端印表機伺服器，而非直接連接本地印表機。       |
| **多租戶 (Multi-Tenant)** | 一套軟體實例同時服務多個獨立客戶（租戶）的架構，需確保各租戶資料隔離與安全。           |
| **LIFF (LINE Frontend Framework)** | LINE 提供的網頁應用程式框架，可在 LINE App 內開啟網頁並取得用戶資訊或調用 LINE 功能。 |

-----

透過補充這些部分的邏輯架構和內容範例，應能讓開發文件更加完善，減少開發過程中的溝通成本和潛在誤解。


## 🔍 專案需求缺失分析與補完邏輯架構

本文件針對「吃雞排找不早」全系統進行需求落差分析與缺失補全邏輯設計，以利系統開發完整、維運穩定與擴充彈性。

---

### ✅ 現有核心模組整理

1. **員工端模組**：打卡、排班、薪資、獎金、能力評分、成就制度。
2. **管理端模組**：營業額登記、獎金設定、異常事件回報、跨店數據管理。
3. **顧客互動模組**：LINE活動、抽獎、投票、成就回饋、LINE Pay付款、優惠券發放。
4. **自動化模組**：Firebase + Cloud Function + LINE / Telegram 通知整合。
5. **分店多據點管理**：單一登入控管、分店切換、地理範圍管控（radius、定位等）。

---

### ❗ 尚未完整補齊的模組與設計缺失

#### 🔧 A. 資料格式與驗證規則缺失

**目標**：明確定義每個模組的 JSON 結構、欄位型別、驗證規則。

**缺失模組**：
- 顧客回饋紀錄表
- 成就累積紀錄（顧客與員工）
- LINE活動與優惠券發放紀錄
- 多分店的營業額分帳與抽成

**補完邏輯結構範例**：
```json
{
  "achievement_record": {
    "uid": "string",             // 對應 LINE 或 Firebase UID
    "type": "employee | customer",
    "achievement_id": "string", // 對應成就設定表
    "progress": 3,
    "completed": true,
    "timestamp": "ISO8601"
  }
}
```

#### 📋 B. 權限與角色表 (RBAC)

**角色分類**：老闆、總店長、副店長、組長、一般員工、顧客、AI 系統

**設計邏輯**：
- 以角色對應 CRUD 權限與能見欄位
- 可切換店別僅限總店長以上角色

**補完結構**：
```json
{
  "role_permissions": {
    "manager": ["view_all_sales", "edit_bonus", "access_multi_store"],
    "leader": ["view_team_score", "report_incident"],
    "employee": ["clock_in", "view_own_score"],
    "customer": ["submit_feedback", "claim_coupon"]
  }
}
```

#### 🧭 C. UI / UX 畫面流程邏輯圖（建議產出）

**需補區段**：
- 顧客參與活動流程（LINE → 活動頁 → 回饋 →成就）
- 店長營收登記 + 店長獎金預估流程
- 外送平台訂單流入流程（Uber / Panda）

**建議工具**：Figma / Whimsical 流程圖整合 Firebase 路徑

#### 🔁 D. 備份 / 錯誤監控與資料安全

**建議實作項目**：
- 每日 Cloud Function 備份 Firestore → Google Cloud Storage
- 異常錯誤紀錄推送 Telegram + 寫入 error_logs 集合

**備份結構建議**：
```json
{
  "backup_config": {
    "target_collections": ["sales", "bonus", "feedbacks"],
    "schedule": "daily@02:00",
    "retention_days": 30,
    "destination": "gs://backup-buzzao"
  }
}
```

#### 📊 E. 營運指標與儀表板系統

**需規劃項目**：
- 每月最佳員工排名
- 分店營業額排行
- 顧客回饋數統計
- 活動參與率分析

**數據來源**：整合 Firestore collection（orders、votes、feedback）進行定期聚合分析

---
## 🔍 專案需求缺失分析與補完邏輯架構

本文件針對「吃雞排找不早」全系統進行需求落差分析與缺失補全邏輯設計，以利系統開發完整、維運穩定與擴充彈性。

---

### ✅ 現有核心模組整理

1. **員工端模組**：打卡、排班、薪資、獎金、能力評分、成就制度。
2. **管理端模組**：營業額登記、獎金設定、異常事件回報、跨店數據管理。
3. **顧客互動模組**：LINE活動、抽獎、投票、成就回饋、LINE Pay付款、優惠券發放。
4. **自動化模組**：Firebase + Cloud Function + LINE / Telegram 通知整合。
5. **分店多據點管理**：單一登入控管、分店切換、地理範圍管控（radius、定位等）。

---

### ❗ 尚未完整補齊的模組與設計缺失

#### 🔧 A. 資料格式與驗證規則缺失

```json
// 成就紀錄
{
  "achievement_record": {
    "uid": "string",
    "type": "employee | customer",
    "achievement_id": "string",
    "progress": 3,
    "completed": true,
    "timestamp": "ISO8601"
  }
}

// LINE 活動紀錄與優惠券紀錄
{
  "coupon_issue": {
    "uid": "string",
    "campaign_id": "string",
    "coupon_type": "discount | free_item",
    "value": 50,
    "used": false,
    "expires_at": "ISO8601"
  }
}

// 顧客回饋紀錄
{
  "feedback": {
    "order_id": "string",
    "uid": "string",
    "store_id": "string",
    "rating": 4,
    "comment": "string",
    "target_employee": "uid",
    "created_at": "ISO8601"
  }
}
```

#### 📋 B. 權限與角色表 (RBAC)

```json
{
  "role_permissions": {
    "owner": ["all"],
    "manager": ["view_all_sales", "edit_bonus", "access_multi_store"],
    "leader": ["view_team_score", "report_incident"],
    "employee": ["clock_in", "view_own_score"],
    "customer": ["submit_feedback", "claim_coupon"]
  }
}
```

---

### 🧭 流程邏輯圖與 API 呼叫點（建議製圖工具：Figma / Whimsical）

#### 1. 顧客參與活動流程
- **LINE OA → LIFF 掃描活動連結**
- → 顯示活動頁面（API: `/campaigns/:id`）
- → 點擊參加（API: `POST /campaigns/:id/join`）
- → 成功後發券（API: `POST /coupons/issue`）
- → 導向成就更新（API: `PATCH /achievement_progress`）

#### 2. 店長獎金預估流程
- 銷售頁面（API: `GET /sales/today`）
- → 下拉選獎金類型（API: `GET /bonus-types`）
- → 即時計算顯示（本地運算）
- → 回傳預估紀錄（API: `POST /bonus/estimates`）

#### 3. 訂單串接外送平台
- 後台設定平台 API key（Uber/Panda）
- → Cloud Function 呼叫外部 webhook
- → 存入 `/orders` 集合
- → 顯示於顧客看板與廚房備餐面板

---

### 📦 擴充模組詳細邏輯架構

#### ✅ 顧客取餐進度看板
- **資料來源**：orders 集合 + 狀態欄位（"pending", "preparing", "ready", "picked"）
- **畫面區分**：現場、外送、預約（source: local, delivery, preorder）
- **狀態顯示邏輯**：
  - 已完成 → 綠色 / Ready to Pick
  - 製作中 → 黃色 / Preparing
  - 未處理 → 紅色 / Pending
- **API**：
```json
GET /orders/today?store_id=xxx
PATCH /orders/:id/status
```

#### ✅ 成就商店
- **功能**：依照點數解鎖獎勵，並可立即兌換（員工與顧客共用）
- **資料表**：`achievement_store`, `user_points`, `redeem_history`
- **流程邏輯**：
  - 查詢可兌換商品（API: `GET /achievement-store`）
  - 點數足夠可兌換（API: `POST /redeem`）
  - 自動紀錄兌換紀錄與成就加分

#### ✅ 跨店任務系統
- **功能**：以任務 ID 管理一組挑戰目標，可設定多分店通用
- **資料表**：`tasks`, `task_progress`, `task_rewards`
- **邏輯**：
  - 任務完成條件可為：總銷售、服務次數、客訴為零等
  - 每次更新任務進度（API: `PATCH /task-progress/:uid`）
  - 完成後可得點數或成就（API: `POST /task-reward`）

#### ✅ 預約訂餐模組
- **功能**：顧客透過 Web/LINE LIFF 預訂取餐時間與商品
- **資料表**：`preorders`, `menus`, `store_schedule`
- **流程邏輯**：
  - 顯示可預約時段（API: `GET /stores/:id/schedule`）
  - 建立預約（API: `POST /preorders`）
  - 通知廚房（Webhook or Firestore Trigger）

---
## 🔍 專案需求缺失分析與補完邏輯架構

本文件針對「吃雞排找不早」全系統進行需求落差分析與缺失補全邏輯設計，以利系統開發完整、維運穩定與擴充彈性。

---

### ✅ 現有核心模組整理

1. **員工端模組**：打卡、排班、薪資、獎金、能力評分、成就制度。
2. **管理端模組**：營業額登記、獎金設定、異常事件回報、跨店數據管理。
3. **顧客互動模組**：LINE活動、抽獎、投票、成就回饋、LINE Pay付款、優惠券發放。
4. **自動化模組**：Firebase + Cloud Function + LINE / Telegram 通知整合。
5. **分店多據點管理**：單一登入控管、分店切換、地理範圍管控（radius、定位等）。

---

### ❗ 尚未完整補齊的模組與設計缺失

#### 🔧 A. 資料格式與驗證規則缺失

```json
// 成就紀錄
{
  "achievement_record": {
    "uid": "string",
    "type": "employee | customer",
    "achievement_id": "string",
    "progress": 3,
    "completed": true,
    "timestamp": "ISO8601"
  }
}

// LINE 活動紀錄與優惠券紀錄
{
  "coupon_issue": {
    "uid": "string",
    "campaign_id": "string",
    "coupon_type": "discount | free_item",
    "value": 50,
    "used": false,
    "expires_at": "ISO8601"
  }
}

// 顧客回饋紀錄
{
  "feedback": {
    "order_id": "string",
    "uid": "string",
    "store_id": "string",
    "rating": 4,
    "comment": "string",
    "target_employee": "uid",
    "created_at": "ISO8601"
  }
}

// 成就商店商品
{
  "achievement_store": {
    "id": "string",
    "title": "string",
    "points_required": 200,
    "stock": 10,
    "type": "item | voucher | coupon",
    "enabled": true,
    "created_at": "ISO8601"
  }
}

// 使用者點數與兌換紀錄
{
  "user_points": {
    "uid": "string",
    "points": 540,
    "updated_at": "ISO8601"
  },
  "redeem_history": {
    "uid": "string",
    "store_item_id": "string",
    "points_used": 200,
    "status": "pending | completed",
    "timestamp": "ISO8601"
  }
}

// 任務進度與任務清單
{
  "tasks": {
    "id": "string",
    "title": "string",
    "type": "sales | feedback | shifts",
    "target": 30,
    "store_scope": ["忠孝", "龍安"],
    "reward_points": 100,
    "active": true
  },
  "task_progress": {
    "uid": "string",
    "task_id": "string",
    "progress": 12,
    "completed": false,
    "last_updated": "ISO8601"
  }
}

// 預約訂單資料
{
  "preorders": {
    "id": "string",
    "uid": "string",
    "store_id": "string",
    "menu_items": [
      { "item_id": "xxx", "qty": 2 }
    ],
    "pickup_time": "ISO8601",
    "status": "scheduled | preparing | ready | picked",
    "created_at": "ISO8601"
  }
}
```

#### 📋 B. 權限與角色表 (RBAC)

```json
{
  "role_permissions": {
    "owner": ["all"],
    "manager": ["view_all_sales", "edit_bonus", "access_multi_store"],
    "leader": ["view_team_score", "report_incident"],
    "employee": ["clock_in", "view_own_score"],
    "customer": ["submit_feedback", "claim_coupon"]
  }
}
```

---

### 🧭 流程邏輯圖與 API 呼叫點（建議製圖工具：Figma / Whimsical）

#### 1. 顧客參與活動流程
- **LINE OA → LIFF 掃描活動連結**
- → 顯示活動頁面（API: `/campaigns/:id`）
- → 點擊參加（API: `POST /campaigns/:id/join`）
- → 成功後發券（API: `POST /coupons/issue`）
- → 導向成就更新（API: `PATCH /achievement_progress`）

#### 2. 店長獎金預估流程
- 銷售頁面（API: `GET /sales/today`）
- → 下拉選獎金類型（API: `GET /bonus-types`）
- → 即時計算顯示（本地運算）
- → 回傳預估紀錄（API: `POST /bonus/estimates`）

#### 3. 訂單串接外送平台
- 後台設定平台 API key（Uber/Panda）
- → Cloud Function 呼叫外部 webhook
- → 存入 `/orders` 集合
- → 顯示於顧客看板與廚房備餐面板

---

### 📦 擴充模組詳細邏輯架構

#### ✅ 顧客取餐進度看板
- **資料來源**：orders 集合 + 狀態欄位（"pending", "preparing", "ready", "picked"）
- **畫面區分**：現場、外送、預約（source: local, delivery, preorder）
- **狀態顯示邏輯**：
  - 已完成 → 綠色 / Ready to Pick
  - 製作中 → 黃色 / Preparing
  - 未處理 → 紅色 / Pending
- **API**：
```json
GET /orders/today?store_id=xxx
PATCH /orders/:id/status
```

#### ✅ 成就商店
- **功能**：依照點數解鎖獎勵，並可立即兌換（員工與顧客共用）
- **資料表**：`achievement_store`, `user_points`, `redeem_history`
- **流程邏輯**：
  - 查詢可兌換商品（API: `GET /achievement-store`）
  - 點數足夠可兌換（API: `POST /redeem`）
  - 自動紀錄兌換紀錄與成就加分

#### ✅ 跨店任務系統
- **功能**：以任務 ID 管理一組挑戰目標，可設定多分店通用
- **資料表**：`tasks`, `task_progress`, `task_rewards`
- **邏輯**：
  - 任務完成條件可為：總銷售、服務次數、客訴為零等
  - 每次更新任務進度（API: `PATCH /task-progress/:uid`）
  - 完成後可得點數或成就（API: `POST /task-reward`）

#### ✅ 預約訂餐模組
- **功能**：顧客透過 Web/LINE LIFF 預訂取餐時間與商品
- **資料表**：`preorders`, `menus`, `store_schedule`
- **流程邏輯**：
  - 顯示可預約時段（API: `GET /stores/:id/schedule`）
  - 建立預約（API: `POST /preorders`）
  - 通知廚房（Webhook or Firestore Trigger）

---
## 🔍 專案需求缺失分析與補完邏輯架構

本文件針對「吃雞排找不早」全系統進行需求落差分析與缺失補全邏輯設計，以利系統開發完整、維運穩定與擴充彈性。

---

### ✅ 現有核心模組整理

1. **員工端模組**：打卡、排班、薪資、獎金、能力評分、成就制度。
2. **管理端模組**：營業額登記、獎金設定、異常事件回報、跨店數據管理。
3. **顧客互動模組**：LINE活動、抽獎、投票、成就回饋、LINE Pay付款、優惠券發放。
4. **自動化模組**：Firebase + Cloud Function + LINE / Telegram 通知整合。
5. **分店多據點管理**：單一登入控管、分店切換、地理範圍管控（radius、定位等）。

---

（略）

---

### ☁️ Firebase Cloud Functions 範例與部署方式

#### 📥 createPreorder - 建立預約訂單
```ts
exports.createPreorder = functions.https.onCall(async (data, context) => {
  const { uid, store_id, menu_items, pickup_time } = data;
  const ref = admin.firestore().collection('preorders').doc();
  await ref.set({
    id: ref.id,
    uid,
    store_id,
    menu_items,
    pickup_time,
    status: 'scheduled',
    created_at: admin.firestore.Timestamp.now()
  });
  return { success: true, preorder_id: ref.id };
});
```

#### 🏆 redeemAchievementReward - 成就獎勵兌換
```ts
exports.redeemAchievementReward = functions.https.onCall(async (data, context) => {
  const { uid, store_item_id } = data;
  const itemRef = await admin.firestore().collection('achievement_store').doc(store_item_id).get();
  const userRef = admin.firestore().collection('user_points').doc(uid);
  const userSnap = await userRef.get();
  if (!itemRef.exists || !userSnap.exists) throw new functions.https.HttpsError('not-found', '資料不存在');

  const pointsRequired = itemRef.data().points_required;
  const currentPoints = userSnap.data().points;
  if (currentPoints < pointsRequired) throw new functions.https.HttpsError('failed-precondition', '點數不足');

  await userRef.update({ points: currentPoints - pointsRequired });
  await admin.firestore().collection('redeem_history').add({
    uid,
    store_item_id,
    points_used: pointsRequired,
    status: 'completed',
    timestamp: admin.firestore.Timestamp.now()
  });
  return { success: true };
});
```

#### 🎯 updateTaskProgress - 任務進度更新
```ts
exports.updateTaskProgress = functions.firestore
  .document('orders/{orderId}')
  .onCreate(async (snap, context) => {
    const order = snap.data();
    const userId = order.uid;
    const taskRef = admin.firestore().collection('tasks').where('type', '==', 'sales').where('active', '==', true);
    const taskSnap = await taskRef.get();

    const batch = admin.firestore().batch();
    taskSnap.forEach(task => {
      const progressRef = admin.firestore().collection('task_progress').doc(`${userId}_${task.id}`);
      batch.set(progressRef, {
        uid: userId,
        task_id: task.id,
        progress: admin.firestore.FieldValue.increment(1),
        last_updated: admin.firestore.Timestamp.now()
      }, { merge: true });
    });
    await batch.commit();
  });
```

---

### 🔐 Firestore Security Rules 建議搭配
```ts
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    match /user_points/{uid} {
      allow read, update: if request.auth.uid == uid;
    }

    match /preorders/{id} {
      allow create: if request.auth.uid != null;
      allow read, update: if resource.data.uid == request.auth.uid;
    }

    match /achievement_store/{id} {
      allow read: if true;
    }

    match /redeem_history/{docId} {
      allow read: if request.auth.uid == resource.data.uid;
    }

    match /task_progress/{docId} {
      allow read, write: if request.auth.uid == resource.data.uid;
    }
  }
}
```

---

### 🧪 Firebase 部署指令範例
```bash
# 初始化 Function 並部署
firebase deploy --only functions

# 同步 Security Rules
firebase deploy --only firestore:rules

# 完整部署所有內容
firebase deploy --only functions,firestore,hosting
```

如需進一步模組化與管理大型專案，可導入 monorepo 或多環境部署架構（如 `dev`、`prod`）。

（原內容略）

---

### 📊 報表模組與營運指標追蹤設計

本模組用於管理端查看每日／每週／每月的分店營運與人員績效狀況，提供可視化指標、排行榜、趨勢分析。

#### 🔹 資料集合
- `report_snapshots`：每日報表快照資料
- `kpi_definitions`：營運關鍵指標設定
- `employee_scores`：員工表現評分記錄

#### 🔹 KPI 指標類型（範例）
| 指標代碼 | 名稱 | 資料來源 | 備註 |
|-----------|------|-----------|------|
| total_sales | 營業總額 | orders | 金額累加 |
| total_orders | 總訂單數 | orders | 以訂單編號統計 |
| avg_order_value | 平均客單價 | orders | 總金額 / 總筆數 |
| feedback_rate | 顧客回饋率 | feedback | 有填回饋的訂單 / 總訂單 |
| positive_feedback | 好評數量 | feedback | rating >= 4 |
| top_employee | 本月最佳員工 | feedback + voting | 綜合指名次數與得票率 |

#### 🔹 JSON 結構設計
```json
{
  "report_snapshots": {
    "store_id": "string",
    "date": "2025-04-30",
    "total_sales": 12000,
    "total_orders": 95,
    "avg_order_value": 126.3,
    "positive_feedback": 82,
    "feedback_rate": 0.86,
    "top_employee": {
      "uid": "EMP123",
      "name": "小明",
      "score": 98
    }
  }
}
```

#### 🔹 API 與 Cloud Function 建議設計
- `GET /reports/daily?store_id=忠孝`
- `GET /reports/monthly?from=2025-04-01&to=2025-04-30`
- `POST /generate-daily-report` → 自動彙整每日報表並寫入 snapshot

#### 🔹 Cloud Function 範例：每日報表統計
```ts
exports.generateDailyReport = functions.pubsub.schedule('every day 02:00').onRun(async () => {
  const stores = ["忠孝", "龍安", "龍崗"];
  for (const store_id of stores) {
    const ordersSnap = await db.collection('orders').where('store_id', '==', store_id).get();
    const feedbackSnap = await db.collection('feedback').where('store_id', '==', store_id).get();

    const totalSales = ordersSnap.docs.reduce((sum, doc) => sum + doc.data().total, 0);
    const totalOrders = ordersSnap.size;
    const avgOrderValue = totalOrders > 0 ? totalSales / totalOrders : 0;

    const feedbackCount = feedbackSnap.size;
    const positiveCount = feedbackSnap.docs.filter(doc => doc.data().rating >= 4).length;

    await db.collection('report_snapshots').add({
      store_id,
      date: new Date().toISOString().substring(0, 10),
      total_sales: totalSales,
      total_orders: totalOrders,
      avg_order_value: avgOrderValue,
      feedback_rate: feedbackCount / totalOrders,
      positive_feedback: positiveCount
    });
  }
});
```

---
好的，各位開發夥伴：

這是一份基於現有專案資料，由我以技術專案開發經理的角色為大家規劃整理的專案技術開發報告書。本報告旨在提供專案的全貌、核心架構、模組細節、技術標準、安全性考量、部署建議與已知風險，以便各位能清晰理解專案需求，並依據建議的開發流程順序推進工作。請務必仔細閱讀，確保所有關鍵資訊被理解與遵循。

本專案的核心目標是為「吃雞排找不早」打造一套集 POS 點餐與後台管理於一體，並具備高度彈性與擴展性的智慧餐飲解決方案，最終願景是成為店家的「經營大腦」與成長夥伴。系統採用多租戶 (Multi-Tenant) SaaS 架構，基於 Firebase 無伺服器平台構建。

為了讓專案能夠穩健推進並符合業務優先級，我們的建議開發流程順序將依照以下階段進行：

1.  **員工管理系統 (包含核心身份驗證與權限)**
2.  **線上點餐系統 (顧客端)**
3.  **會員管理系統**
4.  **現場 POS 點餐系統 (員工端)**

這樣的順序安排是基於先建立內部運營基礎（員工管理），再開放外部服務（線上點餐），接著強化顧客關係（會員），最後完善現場營運工具（POS），逐步累積使用者與業務流程。

以下是根據提供的來源資料，為各位開發夥伴詳細整理的專案技術開發報告書：

---

**「吃雞排找不早」POS 與後台管理系統 - 專案技術開發報告書**

**日期：** 2024 年 05 月 31 日

**文件版本：** V1.1 (基於 V1.0 補充詳細開發流程與整合需求)

**來源文件依據：** 本報告書整合編寫自多份專案規劃與技術文件，包含對系統核心理念、技術架構、各功能模組的詳細描述、安全性考量、部署維運建議、已知問題與風險，以及未來的擴展規劃。

---

**1. 專案概述 (Project Overview)**

**1.1. 專案核心理念與目標**

本專案的核心理念是打造一套全方位、高度客製化的智慧餐飲解決方案，不僅處理訂單，更能驅動成長、增加營收、優化顧客關係、降低營運成本。目標是成為店家的「經營大腦」與成長夥伴。

系統設計採用多租戶 (Multi-Tenant) SaaS 架構，為眾多獨立店家（租戶）提供服務。核心策略是提供媲美高階付費系統的功能，但以免費註冊使用吸引用戶基礎，再透過增值服務獲利。系統需具備高度靈活性與擴展性，並確保租戶擁有高度自主設定權。即使無專用硬體，也能流暢使用.

具體目標包括：提升營運效率（自動化日常流程）、實現數據整合透明（集中管理數據提供決策支援）、強化內部管理（標準化員工、流程、庫存、溝通）、改善內部溝通、支援行動操作 (PWA)、建立激勵機制、優化人力資源。

**1.2. 專案範圍 (In Scope)**

主要功能模組包括：
*   超級管理後台 (Super Admin)
*   租戶後台 (店家管理後台)
*   線上點餐 & 會員中心 & 租戶探索平台
*   線下點餐模組 (員工端 - PWA)
*   身份認證、職位與權限管理
*   GPS 定位打卡系統
*   庫存管理系統 (月度盤點與內部叫貨)
*   排班與請假系統
*   銷售回報系統
*   薪資與獎金系統
*   績效考核、提升與降級系統
*   顧客評價系統
*   內部溝通系統 (公告、知識庫、投票)
*   系統管理功能 (審核、參數設定、日誌、基本分析)
*   取餐編號管理模組
*   硬體周邊整合模組 (雲端出單模式)
*   推薦註冊與自動獎勵機制
*   廣告投放與管理系統
*   租戶探索平台
*   系統安全框架

請注意，完整的即時進銷存管理、完整的顧客關係管理系統 (CRM)、完整的線下 POS 硬體整合 (專注 PWA/雲端出單)、全面的財務會計系統整合、原生行動 App 開發、詳細的高階數據分析儀表板等目前為範圍外 (Out of Scope)。

**1.3. 目標使用者**

系統服務於四類主要使用者：
*   服務商/超級管理員 (Super Admin): 最高權限，管理所有租戶、全局設定等.
*   租戶管理員 (店家管理員)/分店經理: 管理所屬店家員工、菜單、訂單等.
*   分店員工/夥伴: 處理日常點餐、打卡、排班、查看薪資等.
*   顧客: 線上點餐、會員管理、提交評價.

**1.4. 文件目的**

本報告旨在明確定義系統架構、技術選型、開發標準、安全要求、部署維運策略及已知風險，作為開發團隊的共同依循準則. 特別著重提供細節與注意事項，使新的開發團隊能夠順利接手專案.

---

**2. 技術架構 (Architectural Design)**

系統採用基於 Firebase 的無伺服器 (Serverless) 和多租戶 (Multi-Tenant) SaaS 架構.

**2.1. 宏觀架構**

*   **前端 (PWA):** 部署於 Firebase Hosting，使用標準 HTML/CSS/JavaScript (未指定框架). 透過 Firebase Client SDK 與後端溝通.
*   **後端 (Firebase Functions):** 使用 Node.js 20 LTS，部署於 Cloud Functions V2. 處理業務邏輯、第三方整合、排程與背景任務.
*   **資料庫 (Firestore):** NoSQL 文件型資料庫. 儲存所有結構化數據. 採用共享資料庫、共享 Schema，並透過**強制 TenantID 或 StoreID 過濾**實現多租戶資料隔離.
*   **身份驗證 (Authentication):** 主要整合 LINE Login，透過 Cloud Function 換取 Firebase 自定義 Token. 員工可能採用其他方式 (待定義).
*   **訊息推送 (Cloud Messaging):** 用於即時通知 PWA 或透過 Cloud Functions 觸發 LINE/Telegram 通知.
*   **外部整合:** 外送平台 (Uber Eats, Foodpanda - API/Webhook)、金流 (LINE Pay API)、通知 (LINE Notify, Telegram Bot API)、LINE Login (LIFF SDK)、LINE Messaging API (可能用於評價).

**2.2. 前端架構 (PWA)**

*   技術棧：HTML/CSS/JavaScript，無特定框架.
*   核心：Service Worker (離線快取/安裝)、Manifest file.
*   Firebase 整合：必須使用 Firebase Client SDK v9.x.x Compat 版本 (建議 v9.22.2 短期統一)，長期規劃 v9+ 模組化 SDK v11.6.1+.
*   UI/UX：需高度直觀、可配置、響應式. **關鍵風險：缺乏 UI/UX 設計稿**.

**2.3. 後端架構 (Firebase Functions)**

*   技術棧：Node.js 20 LTS, Cloud Functions V2.
*   觸發器：HTTPS (API)、Authentication (用戶初始化)、Pub/Sub & Scheduler (定時/批次).
*   部署：建議 asia-east1 (彰化) 或 asia-northeast1 (東京) 區域降低延遲. 組織功能相關函數.
*   冷啟動：記憶體 >= 256MB, 可設定最小實例數.

**2.4. 資料庫設計 (Firestore)**

*   類型：NoSQL Document DB.
*   原則：共享資料庫、共享 Schema. **所有租戶/分店數據必須強制包含 TenantID 或 StoreID 並過濾**. 需定義複合索引 (`firestore.indexes.json`).
*   限制：不支援複雜 Join/聚合，查詢筆數/大小限制 (1MB)，單文件寫入頻率限制. 需透過結構優化、批次處理克服.

**2.5. 外部整合 (Integrations)**

必須整合外送平台 (Uber Eats, Foodpanda)、金流 (LINE Pay)、通知 (LINE Notify, Telegram Bot)、LINE Login/LIFF. 注意第三方依賴、配額限制、延遲.

---

**3. 技術標準與規範 (Technical Standards & Specifications)**

為確保專案一致性、可維護性與穩定性，需嚴格遵循以下標準：

**3.1. 版本控制與依賴管理**

*   SDK 版本統一：Firebase Client SDK (v9.22.2 Compat 短期，v11.6.1+ Modular 長期)、LIFF SDK (2.21.4+). Admin SDK (v13.x+). Functions V2 SDK.
*   Node.js：20 LTS.
*   NPM：強制使用並提交 `package-lock.json`.
*   Firebase CLI：最新穩定版 (v12+).

**3.2. 編碼風格與文件**

*   風格：一致的 JavaScript 函數命名/宣告. 建議 ESLint + Prettier.
*   文件：JSDoc 註解、技術規格書、API 規格、安全規則、索引定義需及時更新. **API 詳細規格文件缺失為關鍵待辦事項**.

**3.3. 開發實踐**

*   集中初始化：Firebase/LIFF 初始化邏輯集中管理，用 Promise/async/await 確保初始化完成，**嚴禁 setTimeout 輪詢**.
*   **模組化開發 (Cloud Functions):** 強烈建議將 Cloud Functions 的邏輯按功能或觸發器類型拆分到不同的檔案或模組中，**避免將所有函數邏輯集中在單一的 `index.js` (或其他主檔案) 中**。採用清晰的目錄結構組織函數程式碼，以提高可讀性、可維護性與可測試性。
*   安全性：實施深度防禦、最小權限、安全左移. 強制 HTTPS. **Firestore 安全規則 (`firestore.rules`) 是極高優先度**. **Cloud Functions 內部必須再次驗證權限**. 對輸入進行嚴格驗證清理防注入. 輸出數據適當編碼防 XSS. **禁止硬編碼敏感資訊**. 敏感資訊加密存儲或用 Secret Manager. **詳細操作日誌記錄是核心待實現邏輯**.
*   錯誤處理：定義統一的 API 錯誤回傳格式.

---

**4. 多分店資訊整合與點餐入口 (Multi-Store Integration & Ordering Entry Points)**

本系統設計基於多租戶/多分店架構，這是所有模組的基礎.

*   **資料隔離**: 所有與店家相關的數據 (菜單、訂單、員工、排班、庫存、設定等) 都必須包含 `tenantId` 或 `storeId` 欄位，並在讀寫時透過 Firestore 安全規則與後端 Function 邏輯強制過濾，確保資料安全與隔離.
*   **分店設定**: 租戶管理員可以在後台設定各分店的詳細資訊，包括名稱、地址、經緯度 (用於打卡圍欄)、營業時間、聯絡方式、雲端印表機設定、支付方式、線上訂餐開關、排班/薪資參數等. 這些設定應分層管理 (全局 > 租戶 > 分店).
*   **員工跨店**: 系統支援員工跨分店任職. 員工登入後需選擇當前工作分店進行操作，其打卡、訂單、庫存等操作記錄將關聯至該分店.

**點餐入口**：顧客和員工可透過不同入口進入系統進行點餐或相關操作.

1.  **租戶探索平台 (Tenant Discovery Platform)**:
    *   **功能**: 面向終端消費者，展示平台上的店家，為租戶導流.
    *   **整合**: 顯示店家詳細公開資訊、菜單預覽、活動、營業時間、聯繫方式. 提供「線上點餐連結」導向特定店家的線上點餐 PWA. 支援基於地理位置、關鍵字等的搜尋與篩選.
    *   **資料來源**: 整合所有選擇發布公開資訊的租戶/分店資料.
2.  **店家專屬線上點餐 PWA**:
    *   **功能**: 顧客透過掃描店家提供的 QR Code 或點擊連結，直接進入特定分店的線上點餐頁面.
    *   **整合**: 此 PWA 與會員中心綁定. 載入該分店的菜單、進行中的活動、設定的點餐規則. 處理顧客的瀏覽、選餐、加入購物車、結帳流程.
3.  **員工端現場 POS 點餐模組 (PWA)**:
    *   **功能**: 員工在現場透過 PWA 進行點餐、結帳、出單等操作.
    *   **整合**: 員工登入後選擇工作分店，系統載入該分店的菜單、點餐設定、排班等資訊. 介面針對觸控優化，支援離線操作緩存訂單草稿，網路恢復後同步. 支援雲端出單或螢幕顯示叫號.

這些入口都必須確保正確載入或操作的是**當前租戶/分店**的數據，這依賴於嚴格的 `TenantID`/`StoreID` 過濾邏輯.

---

**5. 開發流程架構順序與模組細節 (Development Flow & Module Details)**

我們將依據建議的順序，詳述各階段的核心模組及其要點。

**階段 1: 員工管理系統 (基礎)**

此階段目標是建立系統的內部基礎，確保員工數據、權限、考勤與基礎薪資管理的可用性。

*   **5.1.1. 身份認證、職位與權限管理 (Partner Management & Auth)**:
    *   **核心**: 建立 6 級職等體系. 管理員設定各職等權限範圍. 前後端雙重實施權限控制 (Firestore Rules + Function 內部驗證).
    *   **驗證**: 整合 LINE Login 驗證夥伴身份. 初次登入需管理員審核綁定帳號.
    *   **功能**: 夥伴基本資料管理. 夥伴招募與審核流程. 支援跨店分派夥伴.
    *   **API 要點**: `/api/auth/employee-login` (LINE Token 換 Firebase Token). `/api/admin/employees/` (管理員工資料), `/api/admin/roles/` (管理職位權限).
    *   **數據**: `users` 或 `employees` 集合 (含 `uid`, `role`, `storeId` 等).
*   **5.1.2. 打卡考勤模組 (Clock-in)**:
    *   **核心**: GPS 定位打卡，需在分店地理圍欄內. 記錄時間戳、位置. 自動判定狀態 (準時/遲到/早退/加班/缺勤).
    *   **功能**: 跨店打卡支援. 漏打卡補登申請審核. 打卡提醒.
    *   **API 要點**: `/api/attendance/clock` (打卡請求). `/api/attendance/reports/{employeeId}/{month}` (個人考勤報告). `/api/admin/attendance/{storeId}/{date}` (管理端考勤報表). `/api/admin/attendance/makeup` (補登申請審核).
    *   **數據**: `attendanceRecords` 集合 (含 `type`, `timestamp`, `location`, `storeId`, `employeeId`, `status`).
    *   **驗證**: 需後端驗證 GPS 座標是否在圍欄內 (`storeId` 關聯 `stores` 集合的 `latitude`/`longitude`/`radius`).
*   **5.1.3. 排班與請假系統 (Scheduling & Leave)**:
    *   **核心**: 提供班表排定 (手動/自動). 班表發布與通知. 請假申請與審批流程. 禁休日期管理. 調班/代班支援.
    *   **自動化**: 自動排班演算法為**關鍵待辦事項**. 請假餘額扣減邏輯需明確.
    *   **API 要點**: `/api/admin/schedules/{storeId}/{month}` (管理班表). `/api/schedules/employee/{employeeId}/{month}` (查看個人班表). `/api/leave/request` (請假申請). `/api/admin/leave/{storeId}/approve` (請假審批).
    *   **數據**: `schedules`, `leaveRequests`, `blackoutDates` 集合.
*   **5.1.4. 薪資與獎金系統 (Payroll & Bonus)**:
    *   **核心**: 根據出勤、績效、獎金自動計算薪資. 提供管理員審核修正. 夥伴可查看明細.
    *   **獎金**: 自訂多維度績效指標. 配置可配置化獎金任務與自動計入. **獎金評估邏輯為核心待實現**.
    *   **自動化**: 每月自動觸發薪資計算 (Cloud Function).
    *   **API 要點**: `/api/payroll/employee/{employeeId}` (查詢個人薪資). `/api/admin/payroll/{storeId}/{month}` (管理端薪資報表). `/api/admin/bonus-tasks/{storeId}` (管理獎金任務). `/api/admin/payroll/{storeId}/{month}/approve` (薪資審核).
    *   **數據**: `payrolls`, `bonusTasks`, `bonusRecords`, `performanceMetrics` 集合.
*   **5.1.5. 績效考核、提升與降級 (Performance)**:
    *   **核心**: 提供公平評估與職位調整機制. 支援自動觸發投票 (實習轉正). 支援全員投票、老闆指派/投票降級流程. 結果記錄並更新夥伴職位.
    *   **功能**: 夥伴參與績效評審與投票. 管理員後台操作流程管理. **核心後端邏輯待實現**.
    *   **API 要點**: `/api/admin/performance/{storeId}/evaluations` (管理評估). `/api/admin/performance/{storeId}/promotions` (管理晉升/降級). `/api/performance/employee/{employeeId}` (個人績效查看). `/api/votes/submit` (提交投票).
    *   **數據**: `evaluations`, `promotions`, `demotions`, `votes` 集合.
*   **5.1.6. 內部溝通系統 (Internal Comms)**:
    *   **功能**: 公告發布/管理、知識庫 (含測驗)、投票系統.
    *   **API 要點**: `/api/announcements/{storeId}` (查看公告). `/api/knowledgebase/{storeId}` (查看知識庫). `/api/admin/announcements/{storeId}` (發布公告). `/api/admin/knowledgebase/{storeId}` (管理知識庫).

**階段 2: 線上點餐系統 (顧客端)**

此階段目標是讓外部顧客能夠透過線上管道瀏覽菜單、點餐、付款、追蹤訂單。

*   **5.2.1. 線上點餐模組 (顧客端)**:
    *   **核心**: 顧客透過 PWA 瀏覽菜單、選餐、加入購物車、結帳. 支援 LINE Pay 付款. 訂單狀態追蹤與顯示.
    *   **功能**: 餐點選項自訂 (加料/去冰等). 售完餐點自動標記.
    *   **API 要點**: `/api/menus/{storeId}` (載入菜單). `/api/order/create` (建立新訂單). `/api/payment/linepay/request` (建立 LINE Pay 交易). `/api/payment/linepay/confirm` (確認付款). `/api/order/status/{orderId}` (查詢訂單狀態).
    *   **數據**: `menus`, `products`, `orders`, `payments` 集合.
    *   **流程**: 顧客選餐 -> 建立訂單請求 (含商品、總金額、付款方式) -> 後端驗證建立訂單記錄 (狀態 pending) -> 若 LINE Pay，呼叫 LINE Pay API -> 導向 LINE Pay -> 顧客完成付款 -> LINE Pay 回調通知後端 -> 後端驗證並更新訂單狀態.
    *   **狀態機**: 定義完整的訂單狀態流轉 (Draft, PendingPayment, Paid, Preparing, ReadyForPickup, Completed, Cancelled).
*   **5.2.2. 取餐編號管理模組 (Pickup Number)**:
    *   **核心**: 產生並顯示訂單取餐號碼. 清晰展示訂單狀態. **支援無實體螢幕的運作模式** (透過 LINE 通知顧客).
    *   **API 要點**: `/api/pickup/call` (叫號/發送通知).
    *   **數據**: `orders` 集合 (含 `pickupNumber`, `status`).
*   **5.2.3. 外送平台串接 (Delivery Integration)**:
    *   **核心**: 從外送平台 (Uber Eats, Foodpanda) 匯入訂單. 夥伴在系統中處理外送訂單. 支援取消/拒單並同步平台.
    *   **整合**: 透過 API 或 Webhook 模擬. 租戶後台設定 API 憑證.
    *   **API 要點**: `/api/webhook/ubereats/order`, `/api/webhook/foodpanda/order` (接收訂單 Webhook). `/api/ubereats/update`, `/api/foodpanda/update` (更新平台狀態).
    *   **數據**: `orders` 集合 (標示來源 source: delivery).
*   **5.2.4. 顧客評價機制 (Customer Feedback)**:
    *   **核心**: 收集顧客對服務/產品的反饋. LINE Bot 問卷方式. 評價匿名儲存關聯訂單夥伴. 外部評價匯入.
    *   **功能**: 員工端展示評價. 影響夥伴績效. 申訴機制. **LINE Bot 互動流程及 webhook 邏輯待實現**.
    *   **API 要點**: `/api/webhook/line/feedback` (接收 LINE Bot 回饋). `/api/admin/feedback/{storeId}` (管理評價).
    *   **數據**: `feedbacks` 集合 (含 `storeId`, `orderId`, `uid`, `rating`, `comment` 等).

**階段 3: 會員管理系統**

此階段在線上點餐基礎上，強化顧客關係與忠誠度功能。

*   **5.3.1. 會員系統模組**:
    *   **核心**: 建立忠誠度，收集數據. 會員綁定與登入 (LINE - **租戶獨立 Channel**). 點數計算與兌換 (租戶可設定規則). 訂單追蹤與歷史查詢. 會員分眾標籤管理.
    *   **活動**: 優惠券/兌換券系統 (租戶可定義). 自動化活動設定 (生日禮、發放活動券等). 這些由後端任務定時觸發. 成就系統 (顧客與員工共用). 成就商店兌換獎勵.
    *   **API 要點**: `/api/member/profile` (需驗證 Tenant). `/api/member/points` (需驗證 Tenant). `/api/member/orders` (需驗證 Tenant). `/api/member/coupons` (需驗證 Tenant). `/api/redeem` (需驗證 Tenant). `/api/achievement-store` (需驗證 Tenant). `/api/achievement-progress/{uid}` (需驗證 Tenant).
    *   **數據**: `users` 或 `customers` 集合 (含 `points`, `memberTags`, `tenantId`). `pointRules` (含 `tenantId`), `coupons` (含 `tenantId`), `campaigns` (含 `tenantId`), `achievement_store` (含 `tenantId`), `achievement_record` (含 `tenantId`), `redeem_history` (含 `tenantId`), `user_points` (含 `tenantId`) 集合.
    *   **隱私**: 注意數據隱私與法規遵循.

*   **5.3.2. 顧客推薦獎勵機制 (Customer Referral Program - 新增)**:
    *   **核心**: 激勵現有顧客推薦新顧客，擴大**租戶**的客戶基礎。**此機制在租戶內部運作**。
    *   **運作流程**:
        1.  **生成推薦碼**: 已註冊顧客可在**該租戶**的會員中心生成個人專屬推薦碼。推薦碼需確保在**租戶內唯一**。
        2.  **新顧客使用**: 新顧客在首次註冊**該租戶**會員或首次在**該租戶**下單結帳時輸入推薦碼。
        3.  **驗證與綁定**: 後端驗證推薦碼在**該租戶內**的有效性，記錄推薦關係 (`tenantId`, `referrerUid`, `refereeUid`, `status: pending`)。
        4.  **激活條件**: 新顧客 (Referee) 成功完成在**該租戶下**的第一筆訂單 (狀態變為 `Completed` 或類似終態)。
        5.  **獎勵觸發**: 後端監聽訂單狀態變化或定時檢查，當 Referee 在**該租戶**的首單完成時，觸發獎勵發放。
        6.  **獎勵執行**:
            *   向推薦人 (Referrer) 發放一張**該租戶**的優惠券。
            *   向新顧客 (Referee) 發放一張**該租戶**的優惠券。
            *   更新推薦關係狀態 (`status: completed`)。
    *   **API 要點**:
        *   `/api/referral/my-code` (GET): 獲取當前登入顧客在**當前租戶**的推薦碼。
        *   `/api/referral/apply` (POST): 新顧客提交推薦碼進行**租戶內**綁定 (請求需含 `tenantId`)。
        *   `/api/tenant-admin/referral/rules` (GET/POST): **租戶管理員**管理其推薦活動規則 (請求需含 `tenantId`)。
        *   (後端內部邏輯): 監聽訂單完成事件 (需檢查 `tenantId`)，觸發獎勵發放函數。
    *   **數據模型概念**:
        *   `customers`: 增加 `referralCode` 欄位 (或獨立集合 `customerReferralCodes` 含 `tenantId`, `uid`, `code`)。
        *   `referrals`: 記錄推薦關係 (含 `tenantId`, `referrerUid`, `refereeUid`, `codeUsed`, `status`, `createdAt`, `completedAt`).
        *   `coupons`: 見下一節。

*   **5.3.3. 優惠券結構規劃 (Coupon Structure - 新增)**:
    *   **核心**: 定義靈活的優惠券系統，支持推薦獎勵及租戶自訂的行銷活動。
    *   **數據模型 (`coupons` 集合)**:
        *   `couponId`: (string) 唯一 ID。
        *   `tenantId`: (string) **必須，所屬租戶 ID**。
        *   `userId`: (string) 所屬用戶 UID。
        *   `code`: (string, optional) 優惠券代碼。
        *   `title`: (string) 優惠券標題。
        *   `description`: (string) 描述。
        *   `type`: (string enum) 類型 (e.g., `PERCENTAGE`, `FIXED_AMOUNT`)。
        *   `discountValue`: (number) 折扣值。
        *   `minOrderAmount`: (number, optional) 最低訂單金額要求。
        *   `applicableStoreIds`: (array of strings, optional) 適用分店 ID 列表 (**必須屬於該 tenantId**)。
        *   `applicableProductIds`: (array of strings, optional) 適用商品 ID 列表 (**需驗證商品屬於該 tenantId**)。
        *   `validFrom`: (Timestamp) 生效日期。
        *   `validUntil`: (Timestamp) 失效日期。
        *   `status`: (string enum) 狀態 (`active`, `used`, `expired`)。
        *   `source`: (string enum, optional) 來源 (`REFERRAL_REFERRER`, `REFERRAL_REFEREE`, `CAMPAIGN`, `MANUAL`, etc.)。
        *   `createdAt`: (Timestamp)。
        *   `usedAt`: (Timestamp, optional)。
        *   `usedOrderId`: (string, optional)。
    *   **優惠券模板 (`couponTemplates` 集合, Optional):** 可考慮建立模板 (可全局或租戶自訂，需含 `tenantId` 區分)。租戶管理員設定推薦獎勵時選擇或創建模板。
    *   **發放邏輯 (推薦獎勵)**: 當推薦激活條件滿足時，後端 Cloud Function 根據**該租戶**設定的推薦獎勵優惠券模板，為 `referrerUid` 和 `refereeUid` 在 `coupons` 集合中各創建一條記錄 (含 `tenantId`)。
    *   **使用邏輯**:
        1.  顧客在**某租戶**結帳時，前端 API (`/api/member/coupons?status=active&tenantId=...`) 獲取可用優惠券。
        2.  顧客選擇優惠券。
        3.  前端提交 `couponId`。
        4.  後端驗證 `couponId` 的有效性 (含 `tenantId` 匹配)。
        5.  驗證通過，計算折扣。
        6.  訂單完成後，更新 `coupon` 狀態。

*   **5.3.4. 推薦註冊與自動獎勵機制 (Tenant Referral - 原 5.3.2)**:
    *   **核心**: 激勵推廣**平台本身**，降低**新租戶**獲客成本. 推薦碼生成、驗證綁定關係. 激活條件追蹤 (可配置). 獎勵觸發與執行 (自動提升**租戶**資源/解鎖功能/延長服務期).
    *   **API 要點**: `/api/referral/register-tenant` (新租戶註冊使用推薦碼). `/api/superadmin/referral/rules` (Super Admin 管理推薦規則).
    *   **數據**: `ReferralCodes` (for tenants), `ReferralUsages` (for tenants), `ReferralRules` (for tenants) 集合.

**階段 4: 現場 POS 點餐系統 (員工端)**

此階段完善門市現場營運工具，利用 PWA 特性提升效率。

*   **5.4.1. 線下點餐模組 (員工端 - PWA)**:
    *   **核心**: 提升效率，減少錯誤. 利用 PWA 離線操作. 介面直觀可配置 (大按鈕、觸控優化). 支援離線模式下的點餐、暫存訂單. 網路恢復後自動同步離線數據.
    *   **功能**: 開單與選桌. 點餐操作 (含備註、套餐替換). 訂單管理 (暫存、送單、劃單、修改/取消 - 需權限+Log). 結帳 (含混合支付、折扣/招待 - 需權限+Log、發票、觸發評分). 現金抽屜管理與班別結算. 訓練模式. 資源限制檢查. 出單 (雲端列印或螢幕顯示). **高度自訂性是賣點**.
    *   **API 要點**: 重用 `/api/order/create` (員工端下單). `/api/order/update/{orderId}/status` (更新狀態). `/api/order/{orderId}` (查詢訂單詳情). `/api/shift/closeout/{storeId}` (班別結算). `/api/cashdrawer/{storeId}` (現金抽屜管理).
    *   **數據**: `orders` 集合 (source: local). `shifts`, `cashDrawerLogs` 集合.
    *   **PWA 特性**: Service Worker 實現離線快取菜單/設定/草稿訂單. IndexedDB 儲存待同步離線操作隊列. Background Sync API 或手動機制進行後台同步. 資料衝突處理策略. 狀態管理機制.
*   **5.4.2. 硬體周邊整合模組 (雲端出單模式)**:
    *   **核心**: 將列印任務發送至租戶指定的雲端印表機伺服器. **即使無印表機也能運作** (透過 KDS/PWA 介面顯示，電子憑證等).
    *   **功能**: 租戶後台配置雲端印表機 API URL/Key/模板. POS 後端格式化數據並調用指定 API. 響應處理與錯誤重試.
    *   **API 要點**: `/api/print/order/{orderId}` (觸發列印).
    *   **數據**: `stores` 集合 (含打印機配置).
*   **5.4.3. 庫存管理 (Inventory Management)**:
    *   **核心**: 基本庫存追蹤，月度盤點與內部叫貨流程. 按 TenantID 隔離數據.
    *   **功能**: 月度盤點流程管理、線上填報、生成報告. 內部叫貨流程管理、填寫叫貨單、物流審核、記錄歷史. 租戶可選啟用原料級或成品庫存管理.
    *   **範圍外**: 不含完整的即時進銷存管理或成本計算.
    *   **API 要點**: `/api/inventory/monthly-count/{storeId}/{month}` (月度盤點). `/api/inventory/order-request/{storeId}` (內部叫貨). `/api/admin/inventory/{storeId}/report` (庫存報告).
    *   **數據**: `inventoryItems`, `monthlyCounts`, `internalOrderRequests` 集合.
*   **5.4.4. 銷售回報系統 (Sales Report)**:
    *   **核心**: 為未完全導入 POS 或需人工校正情境提供回報機制. 分店每日提交標準化銷售數據表單. 支援自定義欄位.
    *   **API 要點**: `/api/sales/report/{storeId}/{date}` (提交銷售回報). `/api/admin/sales/{storeId}/{date}` (管理端檢視).
    *   **數據**: `salesReports` 集合.

**6. 系統管理與監控**

此部分功能支援整個系統的運維和管理。

*   **核心**: 提供管理員配置、監控、審核的集中入口.
*   **功能**: 審核中心 (集中處理請假、補卡、獎金、晉升/降級等). 參數設定 (全局、租戶、分店層級參數管理). **必須解決參數配置來源衝突問題**. 系統監控 (操作日誌、錯誤日誌、即時通知). **詳細操作日誌記錄是核心待實現邏輯**. 基本分析數據檢視 (與薪資/績效相關). 手動輸入外部平台評價. 廣告投放與管理系統. 租戶管理 (Super Admin 新增/編輯/停用租戶).
*   **API 要點**: `/api/admin/approval/pending/{storeId}` (待審核列表). `/api/admin/settings` (參數管理). `/api/admin/logs` (查看日誌). `/api/admin/analytics/{storeId}` (基本分析). `/api/admin/ads` (廣告管理). `/api/superadmin/tenants` (租戶管理).
*   **數據**: `settings`, `system_config`, `auditLogs`, `errorLogs` 集合.

---

**7. 系統安全框架 (System Security Framework)**

安全性是 SaaS 服務的基石，必須達到企業級安全標準.

*   **原則**: 深度防禦、最小權限、安全左移.
*   **措施**: 強密碼、MFA (管理員可選). 安全 Session/JWT. **Firestore 安全規則 (Firestore Rules) 極高優先度，需提供具體範例和測試計劃**. 所有 Cloud Functions 內部**必須再次驗證權限**. **強制 TenantID/StoreID 過濾**. 敏感資訊加密存儲或 Secret Manager. 傳輸加密 (HTTPS). 定期數據備份加密. 基礎設施安全加固、弱點掃描. App Check 防濫用. HTTP 函數入口加頻率限制/DDoS 防護. 依賴庫安全掃描更新. **詳細操作日誌 (Audit Log) 記錄**. 開發安全 (安全設計、Code Review、**禁止硬編碼敏感資訊**、嚴格輸入驗證清理、輸出適當編碼防 XSS).
*   **風險與對策**: 安全漏洞攻擊、Firestore 規則錯誤、DDoS. 對策：定期掃描滲透測試、驗證規則、啟用 App Check、頻率限制、應變流程. XSS 防護不足：全面覆蓋輸入驗證和輸出編碼.

---

**8. 部署與維運建議 (Deployment & Operations Recommendations)**

確保系統順利上線並長期穩定運行。

*   **部署平台**: 前端 Firebase Hosting, 後端 Cloud Functions V2 (asia-east1 / asia-northeast1).
*   **環境管理**: **必須** 區分開發 (Dev) 和生產 (Prod)，建議獨立 Firebase 專案. 可考慮 Staging.
*   **部署流程**: 手動 CLI，**建議建立 CI/CD Pipeline** 自動化測試部署.
*   **版本升級**: 語意化版本管理. 資料庫結構升級需遷移腳本或兼容讀取.
*   **監控日誌**: Firebase 控制台、Cloud Logging 監控狀態/錯誤/性能. 定期檢視操作/錯誤日誌. 設定安全事件告警 (Telegram).
*   **效能優化**: Firestore 索引. 快取機制. Functions 並行執行、最低實例數、提升記憶體.
*   **測試策略**: 單元測試 (模擬器)、整合測試、端對端測試 (關鍵流程 E2E 案例需細化). **安全性測試 (Firestore Rules 驗證)** **高優先度**. 使用者驗收測試 (UAT)、訓練模式.
*   **資料庫備份恢復**: Firestore 定期備份機制 (Cloud Storage 或導出). 資料保留策略. 恢復測試計劃.
*   **容錯備援**: 針對單點故障設計方案.

---

**9. 風險與挑戰 (Risks & Challenges)**

開發與維運過程中需特別關注的風險：

*   **基礎設施限制**: Firestore 寫入/查詢頻率與複雜查詢效能限制. Node.js 單執行緒在 CPU 密集任務下的瓶頸.
    *   **對策**: 優化資料結構/索引、複雜計算轉批次處理、使用 Cloud Tasks/Cloud Run.
*   **第三方服務依賴**: 外送/金流/通知平台 API 配額限制、穩定性、延遲.
    *   **對策**: 請求緩存、錯誤重試、過載保護.
*   **開發與管理**: **缺乏 UI/UX 設計稿是關鍵風險**. **核心後端邏輯大量缺失或待完善** (自動排班、請假扣減、獎金計算、操作日誌、審批流程等). **缺失 API 詳細規格文件**. **缺失 Firestore 安全規則範例與測試計劃**. **Firestore 複合索引未定義**. **系統參數配置來源衝突與保存邏輯未解決**.
    *   **對策**: **優先解決上述關鍵待辦事項**. 盡快取得設計稿. 強化測試.
*   **安全性**: 安全漏洞與攻擊 (JWT 劫持、規則錯誤、DDoS). XSS 防護不足. 資料衝突處理 (尤其離線模式).
    *   **對策**: 定期安全掃描/滲透測試、驗證規則、App Check、頻率限制. 全面輸入驗證/輸出編碼.
*   **PWA 離線同步**: 離線操作的可靠性、同步衝突處理.
    *   **對策**: 嚴謹設計離線隊列與同步邏輯，基於時間戳/版本號或後端權威處理衝突.

---

**10. 優化與擴展規劃 (Optimization & Expansion Plan)**

*   **短期優化**: 優先解決上述關鍵待辦與風險. 優化現有功能 (介面自訂性、效能). 強化安全防護 (XSS、敏感資訊、後端權限).
*   **未來擴展**: Kiosk 自助點餐. 進階數據分析與 BI. 會員儲值/電子錢包. 更多外部平台串接 (支付、政府發票、社群). 多語言/海外展店支持. SaaS 平台化 (加強超管、租戶自助、數據隔離、計費模組). 排隊叫號系統. 顧客取餐進度看板. 跨店任務系統. 預約訂餐模組.
*   **技術演進**: 採用 Cloud Functions V2 新功能. 考慮 Serverless Containers (Cloud Run). 持續更新 SDK/依賴.

---

**11. 總結與後續步驟 (Conclusion & Next Steps)**

本報告基於現有資料，詳細闡述了專案的核心概念、技術架構、功能模組、安全性要求、部署維運建議、已知風險與未來規劃. 旨在提供足夠的廣度和深度，使新的開發團隊能夠快速全面了解專案並接手.

為了讓新團隊能夠順暢接手並完成剩餘部分，以下文件和工作是**最高優先級的待辦事項**，請各位開發夥伴務必優先處理：

1.  **完成 API 詳細規格文件：** 針對所有後端 Cloud Functions API，詳細記錄用途、方法、URL、輸入參數、成功/錯誤回應格式範例等.
2.  **定義並測試 Firestore 安全規則：** 編寫完整的 `firestore.rules` 文件，提供說明與測試範例，確保所有 Collection 讀寫權限得到嚴格控制. 必須使用 Emulator Suite 進行徹底測試.
3.  **定義 Firestore 複合索引：** 根據預期查詢模式，在 `firestore.indexes.json` 中定義所有必要的複合索引.
4.  **補齊缺失的核心後端邏輯：** 優先實現標記為「關鍵」或「核心修正重點」的 Cloud Functions，特別是薪資計算、獎金評估、請假扣減、操作日誌記錄、審批流程、分析數據獲取、LINE Bot 評價處理、自動排班演算法等. **開發過程中務必遵循模組化原則，避免將邏輯集中在單一檔案。**
5.  **解決系統參數配置的衝突與保存邏輯問題：** 確保參數設定有唯一可靠的入口和保存機制.
6.  **落實全面的安全性措施：** 特別是輸入驗證、輸出編碼 (XSS)、敏感資訊管理、後端權限檢查等，並進行安全性測試.
7.  **產出關鍵介面的 UI/UX 設計稿：** 即使是線框圖，也能極大幫助前端開發，減少返工.
8.  **建立 CI/CD Pipeline：** 自動化測試與部署流程.
9.  **規劃詳細的部署與維運策略：** 包含環境管理、監控告警、資料備份與恢復計劃.

完成上述事項後，專案將具備更清晰的開發方向、更穩定的架構和更可靠的基礎，為後續功能完善與擴展奠定堅實基礎.

請各位開發夥伴立即開始審閱此報告，並針對上述高優先級事項展開工作。若有任何疑問或需要進一步釐清，請隨時提出。我們將共同努力，推進專案成功！













📄 不早脆皮雞排｜獎金制度邏輯設計 v2.3（全職位＋轉盤系統＋風控優化＋完整內容）

---

## ✅ 每日店長獎金制度

### 🎯 運作原則：
- 店長每日於輸入營業額時，需手動選擇當日的「獎金類型」。
- 每日僅能套用一種獎金公式，並紀錄至獎金明細。

### 🏷️ 可選獎金類型：

| 類型 | 條件 | 計算方式 |
|------|------|-----------|
| 平日獎金 | 營收（現場+熊貓×0.65+UBER×0.65）≥13,000 | × 30% |
| 假日獎金 | 不限營收 | × 38% |
| 過年獎金 | 不限營收 | × 38% |
| 其他獎金 | 自定類型與邏輯 | 由後台設定 |
| 爆量獎金 | 營收 ≥35,000 | 固定 $1000 |
| 留言獎金 | LINE 留言數 ≥10 | 固定 $500 |
| 訂單筆數獎金 | 單日訂單 ≥120 | 固定 $800 |
| 全員出勤獎金 | 當日排班皆出勤且無遲到 | 固定 $1000 全班分配 |

---

## 🧠 店長加碼福利條件

### 🟩 公假制度
- 當月任一平台評分達 4.9，可於下月指定一天公假
- 該日不影響「全月營業獎金」資格

### 🟩 店長月度獎金
| 項目 | 條件 | 金額 |
|------|------|------|
| 全月營業獎金 | 當月無休（扣除公假） | $10,000 |
| 月營收獎金 | 每超 35 萬營收 | +$6000（可疊加） |
| 生日獎金 | 當月生日 | $6000 |
| 週日加班獎金 | 週日有打卡 | 套用假日獎金公式 |
| 評分獎金 | 外送平台 / Google 評分 ≥指定值 | 自訂級距對應金額 |

---

## 👩‍🍳 正職與組長獎金制度

### 👤 正職：
| 項目 | 條件 | 金額 |
|------|------|------|
| 加班獎金 | 月休少於8天，每少1天 | +$1500 |
| 全勤獎金 | 無遲到、請假、早退 | $500 |
| 評分高於8分 | 當月平均評分 | +$500 |
| 生日獎金 | 固定發放 | $1000 |
| 指名好評 | 每次顧客點名 | +$500 |

### 🧑‍💼 組長加碼項目：
| 額外項目 | 條件 | 金額 |
|-----------|------|------|
| 生日獎金 | 固定 | $2000 |
| 平台/Google評分 | 每 +0.1 起跳（自4.8/4.0起） | +200 / +100 |
| 升任成功 | 通過員工評分晉升組長 | 一次性 +$3000 |
| 高評分月獎金 | 評分≥8 | +$1000 |

---

## 📊 評分制度（用於升遷/獎懲）

### 📌 評分邏輯與權重
| 來源 | 權重 |
|------|------|
| 同事互評 | 40%（匿名）|
| 老闆/主管 | 30% |
| 顧客反饋（含LINE/Google）| 20% |
| 遲到/早退紀錄 | 10%（每5分鐘 -1分）|

### 📌 升遷／降級條件
| 職位變動 | 條件 |
|------------|----------|
| 新人→正職 | 滿3週，櫃檯與後勤評分平均 ≥6 |
| 正職→組長 | 滿6月並自提評分，評分 ≥8 |
| 組長→降職 | 單月分數 <6 或被點名負評 ≥3 |
| 正職→降職 | 同上，降為 $38000 薪資階級 |

### 📌 評分匿名與權限規範
- 所有評分匿名顯示
- 僅「系統總管理員」可查看評分者身份（稽核用途）

---

## 🎰 季獎金轉盤與抽獎機制

| 類型 | 規則 |
|------|------|
| 季獎金池 | 各分店「淨營收 × 5%」作為轉盤獎金池 |
| 轉盤次數 | 員工每 10 分可換 1 次（可由管理員手動加/補）|
| 年終紅包 | 可搭配轉盤強化，另計年平均分數計算比例 |

### 📌 抽獎流程與邏輯
- 中獎後從獎金池自動扣除金額
- 每筆記錄含：員工ID、獎項、金額、時間、隨機種子、抽獎來源
- 支援多類型獎項：金額／假期券／禮品／點數券
- 可設次數上限，每季結束自動重置

### 📈 排行榜模組
- 累積中獎金額榜（當月／當季）
- 單筆最大中獎紀錄
- 近期10筆中獎列表（員工、金額、時間）

---

## 🔒 系統風險控管與優化建議（正式附錄）

### 1. 📊 高頻查詢風險
- 排行榜與即時轉盤結果建立 index 並加入快取機制
- 可透過 webhook 定時刷新前端排行榜內容

### 2. ⚖️ 操作公平性
- 店長每日獎金選擇紀錄進 `bonus_selection_logs`
- 提供稽核頁供管理層檢查歷史誤選紀錄

### 3. 🎲 抽獎風控
- 每筆抽獎自動生成隨機種子與 hash
- 紀錄抽獎者 ID 與操作 IP（可稽核）

### 4. 🧩 分數作弊防範
- 採匿名評分＋職位權重機制（老鳥1.2、新人0.8）
- 自動偵測相互灌分行為（雙向滿分多次）提示稽核

### 5. 🗓️ 公假一致性
- 外送平台評分建議自動抓取快照（若無法自動則需人工備查）

### 6. 📢 即時通知機制
- 若中獎金額 ≥ $3000，自動觸發：
  - LINE Notify 員工本人
  - 通知店長群組
  - 公告至全員通知欄（附圖片特效）

---

## 🔧 管理後台操作補充

- 後台可管理：獎項類型、機率、轉盤次數上限、轉盤次數手動加值
- 所有抽獎紀錄與員工得獎歷史可查詢與稽核
- 系統內置 JSON 設定結構與獎金公式可動態調整
- 可於年度／季度報表自動統整獎金、轉盤、得獎歷史

---

📝 本文件為獎金制度、遊戲化模組、評分升遷規則與風控整體邏輯設計，建議併入《整合專案報告》尾端，供開發、管理與稽核使用。



📄 不早脆皮雞排｜獎金制度邏輯設計 v2.4（含 Firestore 資料表設計）

...

## 🗂️ Firestore 資料結構設計（獎金與評分模組）

### 1. `bonus_templates`（獎金類型設定）
```json
{
  id: "weekday_bonus",
  name: "平日獎金",
  type: "營收計算",
  enabled: true,
  sources: [
    { name: "現場", adjust: "none" },
    { name: "熊貓", adjust: "-35%" },
    { name: "UBER", adjust: "-35%" }
  ],
  threshold: 13000,
  percentage: 0.3,
  notes: "平日營收獎金，店長每日手選"
}
```

### 2. `daily_bonus_entries`（每日獎金紀錄）
```json
{
  store_id: "龍安店",
  date: "2025-05-02",
  user_id: "staff_abc",
  bonus_type: "weekday_bonus",
  raw_revenue: {
    現場: 10000,
    熊貓: 12000,
    UBER: 8000
  },
  calculated_result: 7120,
  formula_used: "(10000 + 12000*0.65 + 8000*0.65) * 0.3",
  created_at: Timestamp
}
```

### 3. `monthly_scores`（每月評分與狀態）
```json
{
  user_id: "staff_xyz",
  month: "2025-05",
  score_total: 82,
  source_breakdown: {
    coworker: 34,
    manager: 28,
    customer: 16,
    attendance: 4
  },
  evaluated: true,
  promoted: false,
  demoted: false
}
```

### 4. `bonus_draw_logs`（抽獎紀錄）
```json
{
  store_id: "內壢忠孝店",
  user_id: "staff_aaa",
  draw_time: Timestamp,
  prize: {
    name: "$3000獎金",
    value: 3000,
    type: "cash"
  },
  seed: "c3c7e9a1e...",
  ip: "192.168.0.5",
  remaining_pool: 25400
}
```

### 5. `seasonal_bonus_pool`（每季獎金池）
```json
{
  store_id: "中壢龍崗店",
  quarter: "2025-Q2",
  total_pool: 50000,
  used_pool: 17600,
  remaining: 32400,
  auto_reset_on: "2025-07-01"
}
```

### 6. `employee_votes`（匿名互評紀錄）
```json
{
  from_user_id: "staff_001",
  to_user_id: "staff_007",
  month: "2025-05",
  category: "櫃台",
  score: 8,
  anonymous: true,
  created_at: Timestamp
}
```

### 7. `bonus_selection_logs`（店長獎金選擇紀錄）
```json
{
  store_id: "龍安店",
  user_id: "manager_xyz",
  date: "2025-05-02",
  selected_type: "假日獎金",
  selected_at: Timestamp,
  verified: false
}
```

### 8. `bonus_settings`（後台轉盤與獎項設定）
```json
{
  id: "spin_default",
  season: "2025-Q2",
  max_spins_per_user: 10,
  prizes: [
    { name: "$1000獎金", value: 1000, chance: 15 },
    { name: "$3000獎金", value: 3000, chance: 5 },
    { name: "假期券1日", value: null, chance: 10 },
    { name: "未中獎", value: 0, chance: 70 }
  ]
}
```

---

📌 **備註與建議：**
- 所有集合應設索引於 `user_id + date`、`store_id + date`、`month + user_id`
- 中獎與評分應可由管理員後台進行補發或調整
- 建議加上 `is_test` 欄位標示測試資料以利排除

下一步可依此設計自動化計算 Function 或 UI 對應欄位。



📄 不早脆皮雞排｜獎金制度邏輯設計 v2.5（含 Firestore 資料表設計 + Functions + UI）

...

## 🗂️ Firestore 資料結構設計（獎金與評分模組）

...（原資料表內容略，已保留）

---

## ⚙️ Firebase Functions 自動化範本建議

### Function 1: `calculateDailyBonus`
- 觸發：Firestore trigger on `daily_bonus_entries`
- 功能：依據 `bonus_type` 自動讀取對應 `bonus_templates` 計算獎金
- 輸出：將 `calculated_result`、`formula_used` 寫入同筆 `daily_bonus_entries`

### Function 2: `evaluateMonthlyScores`
- 觸發：每月月底 (scheduled)
- 功能：
  - 匯總 employee_votes
  - 根據權重比對分數來源，寫入 `monthly_scores`
  - 判斷是否達升遷/降職條件，更新 user 狀態與 flag

### Function 3: `generateSeasonalPool`
- 觸發：每季結束自動結算（scheduled）
- 功能：計算總營收 × 5% 建立新季的 `seasonal_bonus_pool`

### Function 4: `handleBonusSpin`
- 觸發：使用者發起轉盤行為（https callable）
- 功能：
  - 驗證次數是否足夠
  - 根據 `bonus_settings` 抽出獎項（weighted random）
  - 扣除獎金池金額，寫入 `bonus_draw_logs`
  - 回傳抽獎結果與剩餘獎金

### Function 5: `notifyBigWinners`
- 觸發：抽中金額 ≥ $3000 時
- 功能：透過 LINE Notify 通知使用者、店長、群組（含圖片與動畫效果）

---

## 🧩 管理後台與員工前台介面欄位建議（UI Layout）

### 員工端 - [我的獎金]
| 元件名稱 | 說明 |
|----------|------|
| 月獎金累計條 | 顯示目前已獲得獎金總額與類型分佈圖 |
| 評分成績卡片 | 當月分數與平均、升遷進度條 |
| 可用轉盤次數 | 數字顯示 + 進入轉盤按鈕 |
| 最近中獎紀錄 | 抽獎時間、金額、項目名稱（最多10筆）|

### 店長端 - [獎金管理]
| 功能 | 元件說明 |
|------|----------|
| 每日獎金設定 | 營收填寫、選擇獎金類型下拉選單、自動顯示試算結果 |
| 每月員工獎金表 | 表格顯示所有員工當月獎金總額、分類、評分狀態、是否升降職 |
| 轉盤紀錄查詢 | 員工轉盤紀錄搜尋、篩選高額、手動補償次數按鈕 |
| 評分統計 | 顯示該月每人平均分數、投票人數、比對歷史趨勢圖 |

### 管理員端 - [獎項與機率設定]
| 功能 | 元件說明 |
|------|----------|
| 建立獎金模板 | 設定營收來源、扣除邏輯、計算百分比、門檻 |
| 編輯轉盤設定 | 設定獎項名稱、金額、機率、類型與上限轉次 |
| 評分解密模式 | 系統總管理員進入後可查每筆評分來源 ID（稽核用）|
| 活動獎勵補發 | 手動發放獎金 / 補發轉盤次數功能 |

---

📌 **後續建議：**
- 可逐步將轉盤結果與排行榜做動畫化呈現（彈跳、閃爍中獎特效）
- 管理端可實作儀表板，整合獎金發放統計、獎金池流向、異常檢查結果（如灌票警示）

此段建議可作為管理後台、Firebase Functions 開發與 UI/UX 規劃的初始範本。


員工職位階級名稱與晉升路徑
系統內職等	俗稱名稱	說明	薪資標準	晉升條件
實習生	新手蛋蛋	試用期員工，入職首月	$38,000	入職滿3週，評分通過
正職1階	正職小雞仔	通過考核的正式員工	$45,000	滿一年自動升
正職2階	雞勇者	表現優異、有潛力升組長	$48,000	可申請升組長
組長	戰鬥雞	班表管理、負責店內作業安排	$53,000 +獎金	由老闆或主管指派或申請評分通過
店長	養雞人	分店最高管理者	獨立規劃	須由老闆直接任命
老闆	雞的傳人	系統最高層管理員	-	固定職位

🔁 職等變動邏輯（評分結合）
降職條件範例：

正職若評分低於 6 或當月被顧客點名負評達 3 次 → 降回「新手蛋蛋」等級。

組長若評分低於 6 或被顧客連續負評超過門檻 → 降為「雞勇者」。

晉升條件補充：

「雞勇者」可主動申請晉升為「戰鬥雞」（組長），須滿6個月並通過所有人匿名投票評分。

📄 不早脆皮雞排｜獎金制度邏輯設計 v3.0（含擴充建議 + Firebase + UI + 優化報告）

...（保留前段內容）

---

## 🔄 擴充模組與優化建議報告（正式擴展章）

### 一、🧭 職位權限與控制強化

| 職稱 | 系統內職等 | 權限特色 |
|------|-------------|------------|
| 新手蛋蛋 | 實習期 | 僅限打卡、查詢獎金、不允許升遷申請 |
| 正職小雞仔 | 正職1階 | 開始累積分數、享受基礎獎金、允許投票 |
| 雞勇者 | 正職2階 | 可提出升組長申請、可被設定指導新人 |
| 戰鬥雞 | 組長 | 管理排班、觀看班級出勤統計、不得看評分身份 |
| 養雞人 | 店長 | 所有員工管理權限、獎金判定、補發控制 |
| 雞的傳人 | 系統總管理員 | 解密評分、全站設定、稽核與轉盤權限調整 |

> 🔒 建議每職位綁定 role 權限組，透過前台及 Firebase rules 控管行為。

---

### 二、📥 晉升申請與審核紀錄模組

| 集合：`promotion_requests` |
```json
{
  user_id: "staff_abc",
  from_title: "雞勇者",
  to_title: "戰鬥雞",
  month: "2025-06",
  apply_time: Timestamp,
  vote_result: { avg: 8.3, voters: 12 },
  approved_by: "owner_001",
  status: "approved"
}
```
- 紀錄所有升遷申請歷程、通過者與否、決策人與升遷條件是否達標。
- 可由 UI 顯示升遷進度條與「投票結果分析」視覺化。

---

### 三、🎖️ 成就模組（徽章 + 通知）

| 成就名稱 | 條件 | 顯示位置 |
|------------|--------|-------------|
| 穩定之雞 | 每日打卡滿30天 | 員工頁面 + LINE通知 |
| 中獎達人 | 轉盤中獎10次 | 頁面徽章 + 排行標示 |
| 全勤勇者 | 無請假 + 準時30天 | 評分加分 + $500 |

> 所有成就應寫入 `user_achievements` 集合，於 UI 與排行榜顯示。

---

### 四、📊 員工獎金預測工具

- 頁面元件：「若明日營收為 ______，可拿獎金？（即時試算）」
- 功能結合 `bonus_templates` 即時計算
- 提升員工每日營收參與感與「可見的報酬期待」

---

### 五、⏳ 轉盤過期機制與獎勵刺激

- 每次獲得轉盤次數，應加入欄位 `expires_at`
- 預設轉盤有效期：季末，過期即失效
- 每週獎勵任務例：
  - 本週轉盤中獎 ≥3 次 → 加碼 $1000
  - 當週無遲到 → 額外獲得1次轉盤

> 推動週期性任務由 Function `evaluateWeeklyMissions()` 自動運算

---

### 六、🤝 團隊獎金共享模組（team_bonus）

- 集合：`team_bonus_events`
```json
{
  date: "2025-06-03",
  store_id: "中壢店",
  condition: "營收 ≥ 50000",
  total_bonus: 2000,
  members: ["staff_01", "staff_02"],
  divided_per_person: 1000
}
```
- 當天所有打卡員工平均分配團隊達標獎金，提升合作參與感。

---

### 七、💬 LINE Bot 雙向查詢功能模組（Chat UX）

- 範例命令：
  - `@我今天可以拿多少獎金？`
  - `@我還差幾分升組長？`
  - `@我本季還能轉幾次盤？`
- 整合 webhook 與 LINE Bot 回覆，增加即時互動感與員工黏著度

---

### 八、📈 指標與管理報表建議強化

| 模組 | 指標 |
|------|------|
| 員工績效 | 分數標準差、近30日走勢 |
| 獎金統計 | 平均發放額、月總支出佔比 |
| 轉盤活動 | 平均中獎值、兌換率（次數/獎金池）|
| 升遷效率 | 升職通過率、平均審核天數 |

---

📌 本章內容可納入《整合專案報告》作為獎金制度的擴充路線圖（Roadmap）與開發優先順序參考。
是否要協助你標記哪些屬於 Phase 1 / Phase 2 可先開發？

📄 不早脆皮雞排｜獎金制度邏輯設計 v3.1（含擴充建議 + Firebase + UI + 優化報告 + 開發分期）

...（保留前段內容）

---

## 📌 擴充模組開發建議分期（Phase 規劃）

### ✅ Phase 1：核心功能優先實作
| 模組 | 原因 |
|-------|------|
| `promotion_requests` 升遷申請表 | 升遷評分與流程透明化基礎 |
| `user_achievements` 成就紀錄模組 | 強化激勵與紀錄功能 |
| `bonus_spin` 過期控制 + 計數功能 | 防止累積過度轉盤次數造成爆量發獎 |
| LINE Bot 問答查詢（基礎） | 提升系統即時互動與透明度 |
| 獎金預測工具元件（前台） | 提升員工自主營收目標參與度 |

### 🟨 Phase 2：進階功能與管理提升
| 模組 | 原因 |
|-------|------|
| `team_bonus_events` 團隊獎金 | 強化團體合作文化與跨班激勵 |
| `evaluateWeeklyMissions` 每週任務發獎 | 導入週期性目標與彈性激勵模式 |
| LINE Bot 整合 webhook 回覆全功能 | 包含查轉盤次數 / 升遷條件 / 評分等 |
| 成就徽章視覺化排行 + 公告牆整合 | 增加遊戲化呈現與橫向刺激性 |
| 抽獎動畫與儀表圖強化 | 用於前台 UI 美化與抽獎觀感提升 |

### 🔒 Phase 3：稽核與長期穩定性建設
| 模組 | 原因 |
|-------|------|
| 評分灌票警示（灌票偵測器） | 確保評分制度公平性長期穩定 |
| `promotion_requests` 日誌備查 + 管理員手動介入 UI | 可修正錯誤申請與人工處理流程 |
| 自動化 Firebase 日報/週報功能（可寄至 Telegram / LINE Notify） | 對內管理效率強化 |

---

📌 本分期規劃建議可配合開發週期、技術資源與人力配置安排滾動式推進。
是否需轉為甘特圖或開發任務表？或要我標示預估工期與角色（前端/後端/PM）？


📄 不早脆皮雞排｜獎金制度邏輯設計 v3.2（擴充建議 + Firebase + UI + 工期任務分工甘特圖）

...（保留前段內容）

---

## 📌 擴充模組開發建議分期（Phase 規劃）

### ✅ Phase 1：核心功能優先實作
| 模組 | 原因 | 工期估算 | 角色配置 |
|-------|------|-----------|------------|
| `promotion_requests` 升遷申請表 | 升遷評分與流程透明化基礎 | 5 天 | 前端、後端、PM |
| `user_achievements` 成就紀錄模組 | 強化激勵與紀錄功能 | 4 天 | 後端、前端 |
| `bonus_spin` 過期控制 + 計數功能 | 防止爆量發獎 | 3 天 | 後端、Firebase Functions |
| LINE Bot 問答查詢（基礎） | 提升互動與透明度 | 3 天 | Bot 開發、PM |
| 獎金預測工具元件（前台） | 增加主動參與度 | 3 天 | 前端、設計師 |

### 🟨 Phase 2：進階功能與管理提升
| 模組 | 原因 | 工期估算 | 角色配置 |
|-------|------|-----------|------------|
| `team_bonus_events` 團隊獎金 | 強化團體合作文化 | 4 天 | 後端、前端 |
| `evaluateWeeklyMissions` 每週任務獎金 | 導入週期任務制度 | 3 天 | Firebase Functions、PM |
| LINE Bot webhook 回覆整合 | 強化查詢與互動 | 4 天 | Bot 開發、後端 |
| 成就徽章排行 + 公告牆 | 遊戲化呈現 | 5 天 | 前端、設計師 |
| 抽獎動畫與儀表強化 | 抽獎體驗升級 | 3 天 | 前端動畫、UI/UX |

### 🔒 Phase 3：稽核與穩定性建設
| 模組 | 原因 | 工期估算 | 角色配置 |
|-------|------|-----------|------------|
| 評分灌票警示（灌票偵測器） | 確保制度公平 | 3 天 | 後端邏輯、PM |
| `promotion_requests` 日誌 + 管理員介入 | 補人工作業與修正流程 | 2 天 | 前端、後端 |
| Firebase 自動日報/週報系統 | 管理效率提升 | 3 天 | Firebase Functions、後端 |

---

## 📊 甘特圖時程規劃（建議 4 週 Sprint 制）

### 📅 第一週（Week 1）
- [●●●●] `promotion_requests`
- [●●●] `bonus_spin` 過期控制
- [●●] LINE Bot 初版（查詢剩餘次數）

### 📅 第二週（Week 2）
- [●●●●] `user_achievements`
- [●●] 獎金預測元件
- [●] 評分灌票警示初稿（研發階段）

### 📅 第三週（Week 3）
- [●●●●] `team_bonus_events`
- [●●●] `evaluateWeeklyMissions`
- [●●] 成就徽章 UI
- [●] Firebase 日報模組

### 📅 第四週（Week 4）
- [●●●●] LINE Bot webhook 完整版
- [●●] 抽獎動畫 + 儀表強化
- [●] 稽核手動介面補強

---

📌 本工期排程為初步評估版本，建議依實際開發規模進行任務細分與每日站立會同步調整。
如需我幫你再轉為 Asana / Trello / Jira 任務板格式，也可以幫你整批匯出。



📄 不早脆皮雞排｜獎金制度邏輯設計 v3.3（含優化建議 + 擴展模組 + 技術架構）

...（保留前段內容）

---

## 🧠 系統優化與擴充建議（v3.3 擴展章）

### 一、📦 Firestore 結構優化與新集合設計

#### ✅ 新增集合建議
| 集合名稱 | 功能說明 |
|------------|------------|
| `bonus_summary_daily` | 每日獎金發放快照（給排行榜快取用）|
| `rankings_cached` | 當日累積中獎排行、單筆最高、近10筆中獎記錄快取 |
| `line_event_templates` | 控制 LINE 通知類型（中獎通知、升遷、評分成功等）|
| `manual_bonus_injections` | 老闆私下獎金注入或補發轉盤次數記錄 |
| `bonus_compensation_requests` | 員工補償轉盤申請紀錄（店長審核）|

### 二、🛠️ Firebase Functions 強化建議

| Function 名稱 | 功能 |
|------------------|------|
| `generateBonusSnapshotDaily()` | 每日結算獎金與中獎榜單寫入快取集合 |
| `triggerLineEvent(type, user_id)` | 發送 LINE Notify，依據 `line_event_templates` 設定執行 |
| `autoSyncPlatformRatings()` | 定時同步 Uber/Panda 評分（若 API 支援）或快照記錄版本 |
| `submitBonusCompensationRequest()` | 補償轉盤申請後觸發，產生審核流程與獎金扣除模擬預覽 |

---

## 📌 邏輯架構補強與擴充模組

### A. 跨店出勤與評分歸屬處理
- 所有獎金/評分/轉盤紀錄皆需綁定 `store_id`
- 評分、升遷審核 UI 顯示「本月在X店出勤Y天」
- 評分畫面切換下拉可查不同分店評分

### B. 店長代理制度（可由老闆指定或店長當日設定）
- 新欄位：`daily_manager_override`
```json
{
  date: "2025-06-12",
  store_id: "龍崗",
  acting_manager_id: "staff_002",
  assigned_by: "養雞人",
  timestamp: Timestamp
}
```
- 前台顯示「代理店長身份執行中」，具管理權限但記錄於代理稽核

### C. LINE Bot 模組化通知管理
- Firestore 集合範例 `line_event_templates`
```json
{
  id: "notify_big_win",
  trigger: "bonus_draw_logs.value >= 3000",
  enabled: true,
  message_template: "恭喜你抽中 ${{value}} 元轉盤大獎！🎉",
  channels: ["user_dm", "store_manager", "global_announce"]
}
```

---

## 🎯 行銷與激勵擴展模組

### 1. 季末排行特別獎機制（獎金/LINE點數/假期）
| 排名類型 | 獎勵方式 |
|-----------|------------|
| 中獎總額排行第一 | 加碼 $3000 + 公開表揚 |
| 抽獎次數最多者 | 折抵轉盤費用 or 加碼一次免費抽 |

### 2. 顧客參與式抽獎（LINE留言/QR掃描）
- 顧客完成 LINE 問券後可參與抽獎（Firebase Hosting 頁面）
- 每筆由 Functions 觸發與中獎機率相對應小品項（贈品券、炸物券）

### 3. 老闆私獎帳戶（可補發未記錄獎金或激勵轉盤次數）
- UI 欄位：金額、原因、有效期、是否可轉盤、是否列入排行榜
- 欄位寫入 `manual_bonus_injections`

### 4. 員工轉盤補償提案系統
- 員工提出補發抽獎次數，由店長審核
```json
{
  user_id: "staff_123",
  reason: "當日病假未轉盤",
  proposed_spin: 1,
  status: "pending",
  approved_by: null
}
```

---

## 🧩 預警與公平性偵測建議

| 項目 | 對策建議 |
|------|-----------|
| 排行榜爆量查詢 | 引入快取快照更新，每日1次寫入 `rankings_cached` |
| 抽獎公平性爭議 | 每筆中獎需寫入 `seed`, `random_result`, `timestamp`, `ip` 作稽查用 |
| 評分灌票異常 | 增設自動比對互評分數相似度，並生成稽核列表給管理員 |
| 平台評分偽造 | 所有手動輸入需附加來源與輸入人 ID，並備份為版本歷史 |

---

📌 本章建議納入為未來「v4.0」或跨系統聯動的升級路線圖。
如需我再為以上模組生成 UI 圖、資料表 JSON 樣板或任務板任務清單，也可立即補上。

📄 不早脆皮雞排｜獎金制度邏輯設計 v3.4（擴展模組 + Firebase Functions 起手式）

...（保留前段內容）

---

## 🔧 Firebase Functions 起手式程式碼樣板

### 1. `generateBonusSnapshotDaily()`
> 每日產出排行榜與中獎紀錄快取
```ts
import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';
admin.initializeApp();

export const generateBonusSnapshotDaily = functions.pubsub.schedule('every 24 hours').onRun(async () => {
  const db = admin.firestore();
  const snapshot = await db.collection('bonus_draw_logs').where('date', '==', todayDate()).get();

  const rankings = calculateTopWinners(snapshot.docs);
  await db.collection('rankings_cached').doc(todayDate()).set({ rankings });
});
```

### 2. `triggerLineEvent(type, userId)`
> 發送 LINE 通知：依據事件種類與 templates 設定
```ts
export const triggerLineEvent = functions.firestore.document('bonus_draw_logs/{logId}').onCreate(async (snap, context) => {
  const data = snap.data();
  if (data.value >= 3000) {
    const template = await getTemplateById('notify_big_win');
    const message = template.message_template.replace('{{value}}', data.value);
    await sendLineNotify(data.user_id, message);
  }
});
```

### 3. `autoSyncPlatformRatings()`
> 手動或定時同步平台評分至 Firestore
```ts
export const autoSyncPlatformRatings = functions.pubsub.schedule('every 24 hours').onRun(async () => {
  const scores = await fetchPlatformRatings(); // 擴充用 API
  const db = admin.firestore();
  for (const storeId in scores) {
    await db.collection('platform_ratings').doc(storeId).set({ ...scores[storeId], updatedAt: Date.now() });
  }
});
```

### 4. `submitBonusCompensationRequest()`
> 員工申請補轉，產生紀錄，並由店長審核
```ts
export const submitBonusCompensationRequest = functions.https.onCall(async (data, context) => {
  const db = admin.firestore();
  const req = {
    user_id: context.auth.uid,
    reason: data.reason,
    proposed_spin: data.proposed_spin,
    status: 'pending',
    created_at: admin.firestore.Timestamp.now()
  };
  await db.collection('bonus_compensation_requests').add(req);
  return { success: true };
});
```

---

📌 以上為四大核心功能模組起手式，建議於部署前搭配對應 security rules 限制權限與稽核控制。下一步是否補上 rules 規則與 UI 元件視覺設計？



📄 不早脆皮雞排｜獎金制度邏輯設計 v3.5（擴展模組 + Functions + Firestore 安全規則）

...（保留前段內容）

---

## 🔐 Firestore Security Rules 設計草案

```ts
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // 所有登入者皆可讀取公告快取與轉盤紀錄摘要
    match /rankings_cached/{day} {
      allow read: if request.auth != null;
      allow write: if false;
    }

    // bonus_draw_logs 僅本人可讀寫（轉盤中獎紀錄）
    match /bonus_draw_logs/{log} {
      allow create: if request.auth != null && request.resource.data.user_id == request.auth.uid;
      allow read: if resource.data.user_id == request.auth.uid;
      allow update, delete: if false;
    }

    // bonus_templates（獎金邏輯）僅管理員可寫入
    match /bonus_templates/{template} {
      allow read: if request.auth != null;
      allow write: if request.auth.token.role == 'admin';
    }

    // bonus_compensation_requests
    match /bonus_compensation_requests/{requestId} {
      allow create: if request.auth != null && request.resource.data.user_id == request.auth.uid;
      allow read: if resource.data.user_id == request.auth.uid;
      allow update: if request.auth.token.role in ['manager', 'admin'];
      allow delete: if false;
    }

    // manual_bonus_injections 僅老闆／管理員可操作
    match /manual_bonus_injections/{log} {
      allow read, write: if request.auth.token.role == 'admin';
    }

    // platform_ratings 自動快照資料，只能由 Function 寫入
    match /platform_ratings/{storeId} {
      allow read: if request.auth != null;
      allow write: if request.auth.token.role == 'function';
    }

    // promotion_requests 升遷流程
    match /promotion_requests/{req} {
      allow create: if request.auth != null && request.resource.data.user_id == request.auth.uid;
      allow read: if resource.data.user_id == request.auth.uid || request.auth.token.role in ['manager', 'admin'];
      allow update: if request.auth.token.role in ['manager', 'admin'];
    }
  }
}
```

---

📌 若結合多分店權限，可進一步搭配：
- `request.auth.token.store_ids` 限制可操作店別
- `isManagerOfStore(store_id)` 自訂函式驗證身份與店別

下一步是否補上 UI 元件建議圖與操作邏輯畫面結構？


📄 不早脆皮雞排｜獎金制度邏輯設計 v3.6（員工端功能補強模組）

...（保留前段內容）

---

## 👥 員工端功能擴充模組設計（v3.6 補強）

### 1. 📌 匿名評分系統 UI
- 每月初自動彈出「本月評分任務」提醒卡片
- 分頁式評分介面，依照分店出勤自動列出需評分同事名單
- 評分面向：櫃台、油鍋、後勤、團隊合作、責任心（依職責篩選）
- 每項使用滑桿 + 顏色（紅→綠）+ emoji 對應
- 每月未完成評分者限制抽獎與成就獲得

### 2. 📈 升遷與降職流程提示
- 頁面頭銜顯示：「目前職位：雞勇者」→ 升遷後自動動畫展示「戰鬥雞」徽章
- 同時發出 LINE Notify + App 內通知：「您已升職為 組長｜戰鬥雞」
- 降職也會顯示動畫變動與提醒：「您目前已降回 正職｜小雞仔」
- 每月統計頁顯示「距離升遷目標：還差 1.2 分」

### 3. 📋 每日工作日誌功能
- 每日打卡完成後自動跳出「備註欄」：
  - 今日狀態（選擇：正常／忙碌／異常）
  - 任務回報（自由輸入備料情況或備忘）
  - 自評欄（可設定 0-5 顆雞蛋）
- 寫入 `work_logs` 集合，店長後台可統一檢視或彙整

### 4. 🏆 成就與里程碑系統（自動化）
| 成就名稱 | 條件 | 獎勵 |
|-----------|-------|------|
| 穩定出勤雞 | 連續30天準時打卡 | +1 轉盤次數 |
| 被點名王者 | 單月被顧客點名 3 次好評 | +500 元獎金 |
| 評分滿分雞 | 本月平均分數 ≥ 9 分 | +成就徽章 + 名冊展示 |
- 所有成就記錄於 `user_achievements` 集合，並於個人頁顯示解鎖進度與徽章

### 5. 📊 員工個人頁面（動態儀表板）
- 顯示區塊：
  - 當前職等頭銜（含圖示）
  - 本月薪資級距：$48,000｜雞勇者
  - 本月平均評分條（顯示來源佔比）
  - 可用轉盤次數與抽獎歷史紀錄
  - 累積獎金曲線圖（30日 / 季 / 年）
  - 我的目標（員工自設，如：每日都打卡、獲得顧客好評一次）

### 6. 🧠 技能標籤模組
- 每位員工資料內新增欄位：`skills: ['櫃台', '炸鍋']`
- 店長／管理員可於後台新增或修改技能標籤
- 員工可於前台發起「技能申請」：如想學油鍋，可送出申請由主管審核
- 訓練完成後由主管「認證」→ 標籤即刻生效
- 技能標籤可作為升遷依據與成就觸發條件之一

---

📌 此擴充模組將員工端從「被動接收資訊」強化為「主動參與成長與評價」的互動核心平台，建議搭配轉盤、排行榜、升遷通知與 LINE Bot 查詢功能共同使用。



📄 不早脆皮雞排｜獎金制度邏輯設計 v3.6（員工端功能補強模組）

...（保留前段內容）

---

## 👥 員工端功能擴充模組設計（v3.6 補強）

...（保留各模組敘述）

---

## 🧱 員工端前台畫面結構（UI + JSON 欄位設計）

### 1. 📌 評分介面元件 JSON 結構
```json
{
  "type": "rating_form",
  "target_user_id": "uid_001",
  "categories": [
    { "label": "櫃台應對", "score": 4 },
    { "label": "油鍋節奏", "score": 5 },
    { "label": "後勤配料", "score": 3 },
    { "label": "責任心", "score": 4 },
    { "label": "團隊合作", "score": 5 }
  ],
  "comment": "最近炸雞速度有提升👍"
}
```

### 2. 📈 升遷動畫 UI 元件
- 結構：彈窗 + 頭銜更換區塊 + 過場動畫
```json
{
  "type": "promotion_announce",
  "from": "雞勇者",
  "to": "戰鬥雞",
  "date": "2025-06-01",
  "animation": "badge_slide",
  "line_notify": true
}
```

### 3. 📋 工作日誌表單欄位
```json
{
  "type": "daily_log",
  "user_id": "uid_012",
  "date": "2025-06-02",
  "status": "正常",
  "notes": "今日補貨較多，備料提前完成",
  "self_score": 4
}
```

### 4. 🏆 成就狀態欄位（user_achievements）
```json
{
  "user_id": "uid_777",
  "achievement_id": "on_time_30",
  "name": "穩定出勤雞",
  "earned_at": "2025-06-02",
  "icon": "🐣",
  "reward_type": "spin",
  "reward_value": 1
}
```

### 5. 📊 員工個人頁（dashboard）JSON 結構
```json
{
  "user_id": "uid_135",
  "rank": "雞勇者",
  "salary_tier": 48000,
  "average_score": 8.5,
  "spin_available": 2,
  "total_bonus_this_month": 9500,
  "goals": ["打卡準時", "累積顧客好評"]
}
```

### 6. 🧠 技能標籤申請與管理 JSON 結構
```json
{
  "type": "skill_application",
  "user_id": "uid_999",
  "skill": "油鍋",
  "status": "pending",
  "applied_at": "2025-06-01",
  "approved_by": null
}
```

---

📌 上述為六大功能的 UI 對應欄位與前端資料結構示意，可作為實作前端元件綁定或 API 結構傳遞依據。是否需我幫你接續畫出具體畫面草圖？

📄 不早脆皮雞排｜獎金制度邏輯設計 v3.7（員工端補強 + 線上點餐模組擴充）

...（保留前段內容）

---

## 🍱 線上點餐系統邏輯擴充（v3.7 補充）

### ✅ 現行已支援模組摘要
| 模組 | 說明 |
|-------|------|
| 顧客下單流程 | 綁定 LINE 登入，動態菜單、加料、購物車、付款選項（LINE Pay / 現場付款） |
| 取餐進度通知 | 顧客可查詢訂單編號與狀態；店員更新狀態會同步 LINE Notify |
| 顧客評價系統 | 訂單結束後推送問卷，可指定員工、留下意見，寫入評分邏輯與獎金系統 |

### 🧩 可擴充模組設計

#### 1. 📊 菜單推薦模組（個人化 + 熱門）
```json
{
  "type": "menu_recommendation",
  "logic": [
    "top_selling_today",
    "customer_favorite",
    "combo_pairing"
  ],
  "display_position": "menu_top"
}
```
- 顯示「今日熱銷」、「上次有點過」、「推薦搭配」等個人化資訊
- 根據 Firebase 集合 `orders_summary_daily` 計算熱門商品

#### 2. 🎁 自訂優惠與加購區（滿額條件）
```json
{
  "type": "promotion",
  "condition": "order.total >= 150",
  "reward": {
    "type": "discount",
    "value": 30
  },
  "message": "滿 $150 送 $30 折扣券，下次用"
}
```
- 支援不同類型：折扣、送品項、加價購、累點
- 管理後台可新增促銷條件與週期時間設定

#### 3. 🛑 訂單取消與編輯保留期
```json
{
  "type": "order_control",
  "editable_time_window_sec": 60,
  "cancelable_until_status": "accepted"
}
```
- 顧客可於「60 秒內」編輯或取消訂單
- 一旦店員點選「製作中」，即視為不可編輯或取消狀態

#### 4. 📦 即時庫存同步（結合 POS）
```json
{
  "type": "menu_sync",
  "menu_item_id": "chicken_leg",
  "available": false,
  "last_updated": "2025-06-01T14:33"
}
```
- 若某商品售完，自動在點餐畫面標示「售完」並排至最下方灰色處理
- 可與後台 POS 綁定（firebase function or webhook）

#### 5. 🧑‍🍳 顧客身份導購與標籤引導
```json
{
  "type": "customer_segment",
  "tags": ["學生", "常客", "不吃辣"],
  "recommendations": ["套餐B", "甜不辣", "豆腐"]
}
```
- 根據 LINE 綁定後的身份標籤與歷史行為，顯示客製化推薦
- 管理員可手動為顧客加標籤（如團購、辦公大樓）

---

📌 此擴充模組設計將進一步提升點餐系統的個人化、效率與營收轉換率，建議結合顧客點數、抽獎、會員成就模組使用。

📄 不早脆皮雞排｜獎金制度邏輯設計 v3.7（員工端補強 + 線上點餐模組擴充）

...（保留前段內容）

---

## 🍱 線上點餐系統邏輯擴充（v3.7 補充）

### ✅ 現行已支援模組摘要
| 模組 | 說明 |
|-------|------|
| 顧客下單流程 | 綁定 LINE 登入，動態菜單、加料、購物車、付款選項（LINE Pay / 現場付款） |
| 取餐進度通知 | 顧客可查詢訂單編號與狀態；店員更新狀態會同步 LINE Notify |
| 顧客評價系統 | 訂單結束後推送問卷，可指定員工、留下意見，寫入評分邏輯與獎金系統 |

### 🧩 可擴充模組設計

...（保留 JSON 擴充區段）

---

## 🧱 顧客端畫面結構建議與資料欄位

### 1. 🛒 顧客首頁畫面（mobile-first 設計）
- 元件：分店選擇器、點餐入口、推薦菜單區、優惠橫幅
```json
{
  "store_selector": true,
  "welcome_banner": "不早脆皮雞排歡迎您",
  "recommended_items": ["top_selling_today", "customer_favorite"],
  "promotion_banner": "本日滿額贈送活動進行中"
}
```

### 2. 📋 菜單區域
- 類別切換、售完標示、加購推薦
```json
{
  "menu": [
    { "id": "chicken_leg", "name": "雞腿排", "price": 75, "available": true },
    { "id": "squid", "name": "小卷", "price": 65, "available": false }
  ],
  "recommend_combo": ["+10 元加購甜不辣"]
}
```

### 3. 🧾 購物車與結帳區
```json
{
  "items": [
    { "id": "chicken_leg", "qty": 2, "subtotal": 150 },
    { "id": "drink_1", "qty": 1, "subtotal": 25 }
  ],
  "total": 175,
  "payment_methods": ["LINE Pay", "現場付款"],
  "submit_button": "送出訂單"
}
```

### 4. ⏱️ 訂單狀態查詢與通知畫面
```json
{
  "order_number": "A128",
  "status": "製作中",
  "estimated_pickup": "18:15",
  "notify_via_line": true
}
```

### 5. 📣 評價表單觸發
- 結帳完成後自動出現表單 or 發送 LINE 評價問卷
```json
{
  "order_id": "2025-0601-1123",
  "employee_rating": true,
  "comment_field": true,
  "suggested_tags": ["速度快", "服務好", "口味佳"]
}
```

---

📌 上述資料結構可作為開發前端 UI、Firebase 綁定與 LINE Bot 流程整合的參考基礎。


📄 不早脆皮雞排｜獎金制度邏輯設計 v3.7（員工端補強 + 線上點餐模組擴充）

...（保留前段內容）

---

## 🍱 線上點餐系統邏輯擴充（v3.7 補充）

### ✅ 現行已支援模組摘要
| 模組 | 說明 |
|-------|------|
| 顧客下單流程 | 綁定 LINE 登入，動態菜單、加料、購物車、付款選項（LINE Pay / 現場付款） |
| 取餐進度通知 | 顧客可查詢訂單編號與狀態；店員更新狀態會同步 LINE Notify |
| 顧客評價系統 | 訂單結束後推送問卷，可指定員工、留下意見，寫入評分邏輯與獎金系統 |

### 🧩 可擴充模組設計
...（保留 JSON 擴充區段）

---

## 🧱 顧客端畫面結構建議與資料欄位
...（保留原結構）

---

## 🗂️ Firestore 資料表結構建議（線上點餐模組）

### 1. `orders`（顧客訂單）
```json
{
  "order_id": "20250601-0001",
  "user_id": "uid_abc",
  "store_id": "內壢忠孝",
  "items": [
    { "menu_item_id": "chicken_leg", "qty": 2, "subtotal": 150 }
  ],
  "total": 175,
  "status": "preparing", // created, preparing, ready, picked_up, canceled
  "payment_method": "LINE Pay",
  "created_at": Timestamp,
  "pickup_time": "18:15"
}
```

### 2. `menu_items`（菜單項目）
```json
{
  "menu_item_id": "chicken_leg",
  "name": "雞腿排",
  "price": 75,
  "available": true,
  "category": "炸物",
  "store_ids": ["內壢忠孝", "中壢龍崗"],
  "image_url": "...",
  "tags": ["人氣", "可加辣"]
}
```

### 3. `store_config`（分店設定）
```json
{
  "store_id": "中壢龍崗",
  "line_notify_token": "...",
  "payment_options": ["LINE Pay", "現場付款"],
  "menu_display_order": ["雞腿排", "甜不辣"]
}
```

### 4. `customer_profiles`（顧客資料）
```json
{
  "user_id": "uid_abc",
  "line_uid": "...",
  "tags": ["常客", "不吃辣"],
  "order_history": [...],
  "last_store": "中壢龍崗"
}
```

### 5. `order_feedback`（顧客評價紀錄）
```json
{
  "order_id": "20250601-0001",
  "user_id": "uid_abc",
  "store_id": "中壢龍崗",
  "rated_employees": ["staff001"],
  "score": 5,
  "tags": ["服務好", "速度快"],
  "comment": "炸物酥脆好吃",
  "created_at": Timestamp
}
```

---

📌 此資料表結構已支援「動態菜單顯示」、「顧客個人化導購」、「訂單與庫存即時互動」、「多分店支援」、「自動 LINE 通知」、「員工評價反饋」等核心點餐模組功能。

📄 不早脆皮雞排｜獎金制度邏輯設計 v3.8（員工端補強 + 線上點餐模組擴充 + LINE Bot 對話邏輯）

...（保留前段內容）

---

## 🗨️ LINE Bot 對話邏輯設計（線上點餐系統）

### ✅ 功能類型與對應範例

#### 1. 📦 查詢訂單進度
- **使用者輸入：**
  - 「我有訂單嗎」
  - 「查詢訂單進度」
- **回覆邏輯：** 查找 `orders` 中 status = preparing/ready，回傳：
  - `目前訂單 A123 正在製作中，預計取餐時間 18:20`

#### 2. 📋 查詢今日菜單
- **使用者輸入：**
  - 「今天有賣什麼」
  - 「查看菜單」
- **回覆邏輯：** 抓取 `menu_items` 中 available = true：
  - `今日提供：雞腿排（$75）、甜不辣（$45）、豆腐（$35）`

#### 3. 🛍️ 查詢優惠與活動
- **使用者輸入：**
  - 「有沒有活動」
  - 「優惠方案是什麼」
- **回覆邏輯：** 查找促銷規則集 `promotions` 中條件符合者：
  - `今日活動：滿 $150 贈送下次 $30 折價券`

#### 4. 🏪 查詢營業時間與分店資訊
- **使用者輸入：**
  - 「現在有開嗎」
  - 「中壢店開到幾點」
- **回覆邏輯：** 查詢 `store_config` 中 store_id 與時段設定：
  - `中壢龍崗店營業時間：每日 15:00 - 00:30`

#### 5. 🎁 查看目前點數或累積紀錄（需登入）
- **使用者輸入：**
  - 「我有幾點」
  - 「我上次點了什麼」
- **回覆邏輯：**
  - 查找 `customer_profiles` → 回傳點數、歷史訂單摘要：
  - `您目前累積 90 點，上次於 5/31 點了雞排 + 甜不辣`

### 📌 補充建議
- 每筆查詢應記錄至 `line_bot_logs` 供後續優化分析
- 若非會員 LINE 用戶，預設引導「點我登入會員即可使用完整功能」+ 綁定入口

---

📌 LINE Bot 設計已對應現有 Firebase 結構，可使用 LINE Messaging API 結合 webhook 自動處理並回覆文字與圖片。後續可進一步導入 Rich Menu、圖文選單或自動發送通知整合。


📄 不早脆皮雞排｜獎金制度邏輯設計 v3.9（員工端補強 + 點餐 + LINE Bot + 會員系統擴充）

...（保留前段內容）

---

## 👤 會員管理系統擴充模組設計（v3.9 補強）

### ✅ 現行已具備功能
| 模組 | 狀態 | 備註 |
|-------|--------|-------|
| LINE Login 登入與綁定 | ✅ 已完成 | 支援快速登入與會員辨識 |
| 點數與訂單歷史查詢 | ✅ 已完成 | 消費換點，並可查歷史紀錄與評價 |
| 顧客問卷與評價機制 | ✅ 已整合 | 支援 LINE 推送、員工指定、連動績效 |
| 會員標籤管理 | ✅ 後台自訂 | 如常客、不吃辣、辦公區域等 |
| 優惠券系統 | ✅ 已建構 | 支援生日券、滿額折抵券、自動發送 |

---

### 🧩 v4.0 擴充建議模組

#### 1. 🧠 會員等級制度（自動升級）
- 根據年度累積消費金額自動升等（銅→銀→金→VIP）
- 每等級享不同回饋倍率與專屬優惠券
```json
{
  "user_id": "uid_xyz",
  "member_level": "金牌會員",
  "total_order_amount": 8700,
  "benefits": ["生日券$100", "LINEPay加倍點"]
}
```

#### 2. 🎯 顧客任務與成就系統
- 任務範例：「首次推薦好友」、「連續 3 週下單」等
- 每個任務綁定獎勵點數或抽獎機會，顯示進度條與已完成徽章
```json
{
  "user_id": "uid_789",
  "task_id": "task_first_share",
  "completed": true,
  "reward_type": "points",
  "reward_value": 100
}
```

#### 3. 🏆 會員排行榜模組
- 每月前 10 名：
  - 消費金額最高
  - 點餐次數最多
  - 顧客好評最多
- 排行榜顯示於會員首頁，可搭配活動

#### 4. 🎡 會員專屬抽獎轉盤
- 顧客消費滿額或達成任務後獲得「抽獎券」
- 抽獎 UI 與員工轉盤獨立，獎品為優惠券、贈品、小雞幣等
- 管理後台可設定每期轉盤獎項與中獎機率

#### 5. 🧾 電子發票歸戶（可選擇導入）
- 若未來支援雲端發票整合，可將會員資料與載具號碼綁定
- 結帳後自動歸戶，並寫入交易紀錄以供查詢與對帳

---

📌 此會員模組擴充設計建議納入 v4.0 發展目標，結合點餐、行銷、推薦與 LINE 官方帳號自動回饋，可提升會員活躍度與顧客終身價值（CLV）。


📄 不早脆皮雞排｜獎金制度邏輯設計 v4.0（員工端補強 + 點餐 + LINE Bot + 會員系統擴充）

...（保留前段內容）

---

## 👤 會員管理系統擴充模組設計（v4.0 補強）

...（保留前述內容）

---

## 🧱 會員模組 UI 結構 + 資料欄位建議

### 1. 🧠 會員等級系統畫面元件
```json
{
  "user_id": "uid_xyz",
  "member_level": "金牌會員",
  "level_display": {
    "badge_icon": "🥇",
    "progress_bar": 72,
    "next_level": "VIP",
    "next_requirement": 1300
  },
  "benefits": ["生日券$100", "LINEPay加倍點"]
}
```
- 元件包含：等級徽章圖示、進度條（距離下一級）、目前特權列舉

### 2. 🎯 任務清單與成就徽章區塊
```json
{
  "user_id": "uid_abc",
  "active_tasks": [
    { "task": "首次下單", "progress": 1, "total": 1, "completed": true },
    { "task": "一週下三單", "progress": 2, "total": 3, "completed": false }
  ],
  "badges": [
    { "name": "任務達人", "icon": "🏆", "unlocked": true },
    { "name": "分享達人", "icon": "📣", "unlocked": false }
  ]
}
```
- UI 顯示任務條列進度 + 解鎖徽章展示列（可點擊詳細說明）

### 3. 🏆 排行榜模組資料結構
```json
{
  "type": "monthly_leaderboard",
  "ranking_criteria": "total_spending",
  "store_id": "中壢店",
  "top_users": [
    { "user_id": "uid_001", "name": "阿強", "amount": 5280 },
    { "user_id": "uid_002", "name": "小美", "amount": 4790 }
  ]
}
```
- 排行榜區塊支援切換：月／季、消費／好評／下單次數

### 4. 🎡 顧客抽獎轉盤資料設計
```json
{
  "user_id": "uid_456",
  "spins_left": 2,
  "last_spin_result": {
    "reward_type": "coupon",
    "reward_value": "炸物折價券 $20",
    "timestamp": "2025-06-02T12:33"
  },
  "rewards_history": [ ... ]
}
```
- 顯示剩餘抽次、最近中獎結果、可選兌換項目（若搭配點數）

### 5. 🧾 發票歸戶（雲端發票）欄位建議
```json
{
  "user_id": "uid_789",
  "carrier_id": "/ABCD12345",
  "auto_claim_enabled": true,
  "last_claimed_order": "2025-0601-1002"
}
```
- 支援未來連接發票平台（財政部載具 API 或 LINE PAY 消費載具代管）

---

📌 此 UI 資料結構可對應 Web 或 LINE Front-end Framework 畫面元件使用，並支援後續串接獎勵、推播、排行榜與任務獎勵整合。
📄 不早脆皮雞排｜獎金制度邏輯設計 v4.0（員工端補強 + 點餐 + LINE Bot + 會員系統擴充）

...（保留前段內容）

---

## 👤 會員管理系統擴充模組設計（v4.0 補強）

...（保留前述內容）

---

## 🧱 會員模組 UI 結構 + 資料欄位建議

...（保留原結構）

---

## 🔄 任務排程與活動自動化邏輯設計

### 1. 📆 任務刷新邏輯（每日/每週/每月）
- 每日凌晨 3:00，自動產出新任務實例寫入 `customer_tasks`：
```json
{
  "user_id": "uid_999",
  "task_id": "daily_checkin",
  "start_date": "2025-06-03",
  "expire_date": "2025-06-03T23:59",
  "status": "pending"
}
```
- 類型包含：
  - `daily_checkin`: 當日打卡獎 5 點
  - `weekly_x_orders`: 一週滿 3 單抽一次
  - `monthly_feedback`: 本月完成 1 筆顧客評價

### 2. 🧾 自動化活動腳本範本（每月會員日）
```json
{
  "event_id": "vip_bonus_day",
  "trigger_date": "2025-06-10",
  "target_segment": ["金牌會員", "VIP"],
  "action": {
    "type": "grant_coupon",
    "coupon_type": "vip_special",
    "value": 50,
    "message": "感謝您的支持！本月會員日贈您 $50 折價券"
  },
  "repeat": "monthly"
}
```
- 搭配 Firebase Functions 每月跑排程，發放 LINE Notify + 寫入 `coupon_records`

### 3. 💬 範例活動腳本（首次綁定、生日、滿額）
```json
{
  "event_type": "birthday",
  "trigger_field": "birthday",
  "action": {
    "type": "send_coupon",
    "value": 100,
    "line_notify": true
  }
}
```
- 其他常見活動條件：
  - 首次綁定會員
  - 本月累計消費滿 $1000
  - 首次填寫評價問卷

---

📌 任務排程與活動腳本可結合 Firebase Scheduled Functions 自動化運作，並配合會員等級、任務系統、抽獎券累積邏輯同步展開。

📄 不早脆皮雞排｜獎金制度邏輯設計 v4.0（員工端補強 + 點餐 + LINE Bot + 會員系統擴充）

...（保留前段內容）

---

## 👤 會員管理系統擴充模組設計（v4.0 補強）

...（保留前述內容）

---

## 🧱 會員模組 UI 結構 + 資料欄位建議

...（保留原結構）

---

## 🔄 任務排程與活動自動化邏輯設計

...（保留原結構）

---

## 🧰 後台活動任務設定介面設計（管理員專用）

### A. 任務管理後台（customer_tasks_templates）
```json
{
  "task_id": "weekly_order_challenge",
  "title": "本週下單 3 次贈抽獎券",
  "description": "在一週內完成任意 3 筆訂單即可獲得抽獎券",
  "type": "weekly",
  "repeat": true,
  "reward": {
    "type": "bonus_draw",
    "value": 1
  },
  "condition": {
    "orders_required": 3,
    "count_field": "orders_this_week"
  },
  "enabled": true
}
```
- 管理員可新增任務模板，自動套用至每位會員每週建立實例

### B. 活動腳本設定介面（event_scripts_templates）
```json
{
  "event_id": "first_binding",
  "trigger": "on_user_created",
  "filter_condition": "user.is_bound == true",
  "action": {
    "type": "grant_coupon",
    "coupon_id": "welcome_30",
    "line_notify": true
  },
  "enabled": true
}
```
- 支援複數事件類型觸發（首次登入、生日、累計滿額）
- 活動腳本可啟用/停用/編輯觸發時間與對象群組

### C. 後台操作欄位（任務與活動統一欄位建議）
| 欄位名稱 | 說明 |
|----------|------|
| 任務/活動名稱 | 顯示於前台名稱 |
| 條件描述 | 任務邏輯說明（供顧客參考） |
| 獎勵方式 | 折價券 / 點數 / 轉盤次數 / 等級升級 |
| 觸發類型 | 每日、每週、首次動作、固定日期等 |
| 有效期間 | 任務或活動的執行區間 |
| 對象群組 | 全體會員 / 銅牌以上 / 特定分店 |
| 是否啟用 | ✅ / ❌ 開關控制 |

---

📌 此管理員後台設計支援行銷活動即時建立、週期性任務安排、獎勵結構編輯與條件彈性配置，未來可搭配成效追蹤與任務完成率統計報表模組整合。


📄 不早脆皮雞排｜獎金制度邏輯設計 v4.0（員工端補強 + 點餐 + LINE Bot + 會員系統擴充）

...（保留前段內容）

---

## 👤 會員管理系統擴充模組設計（v4.0 補強）

...（保留前述內容）

---

## 🧱 會員模組 UI 結構 + 資料欄位建議

...（保留原結構）

---

## 🔄 任務排程與活動自動化邏輯設計

...（保留原結構）

---

## 🧰 後台活動任務設定介面設計（管理員專用）

...（保留原結構）

---

## 📊 活動與任務成效追蹤報表模組

### 📈 成效分析主視覺（dashboard 結構）
| 指標項目 | 說明 |
|-----------|------|
| 任務完成率 | 顯示每週任務完成比例與完成人數，依任務類型可篩選 |
| 活動參與率 | 活動開啟後實際觸發會員數量 / 可觸達總人數 |
| 折價券使用率 | 各活動發放的優惠券使用比例與金額折抵統計 |
| 轉盤啟用次數 | 每期抽獎活動中會員實際參與人次、平均中獎金額 |
| 升等與流失分析 | 升級到高等會員人數／最近 30 天未再回訪人數比對 |

### 📁 報表集合設計（firestore: `report_metrics`）
```json
{
  "report_type": "weekly_task_completion",
  "range": "2025-W23",
  "task_id": "weekly_order_challenge",
  "total_participants": 342,
  "completed_count": 289,
  "completion_rate": 84.5
}
```
- 每週自動生成，搭配 `scheduledFunctions` 更新並寫入報表專用集合
- 可依月份、活動、會員群組、分店進行篩選彙總

### 📊 視覺化圖表建議
- 完成率折線圖（可切換日／週／月）
- 使用券比例圓餅圖（依券類型分類）
- 抽獎參與雷達圖（依會員群層／等級）

📌 本報表模組建議於管理後台新增「活動成效分析」頁籤，並與活動設定頁直接連動、即時呈現該任務之目前狀態與歷史表現。

📄 不早脆皮雞排｜獎金制度邏輯設計 v4.1（員工端補強 + 點餐 + LINE Bot + 會員系統擴充 + 積分與演算法模組）

...（保留前段內容）

---

## 👤 會員管理系統擴充模組設計（v4.0 補強）

...（保留前述內容）

---

## 🧱 會員模組 UI 結構 + 資料欄位建議

...（保留原結構）

---

## 🔄 任務排程與活動自動化邏輯設計

...（保留原結構）

---

## 🧰 後台活動任務設定介面設計（管理員專用）

...（保留原結構）

---

## 📊 活動與任務成效追蹤報表模組

...（保留原結構）

---

## 🧮 跨月獎勵積分與推薦演算法模組

### 1. 🔁 積分統計與保留規則
- 為避免每月歸零浪費，積分支援跨月累積：
```json
{
  "user_id": "uid_abc",
  "points_total": 1380,
  "points_this_month": 340,
  "carry_over_policy": "expire_after_90_days"
}
```
- 可設定：
  - 有效期（如 90 天）
  - 每月最多轉入比例（如只保留 50%）

### 2. 🔍 顧客偏好分析與個人化推薦（基礎模型）
- 根據歷史訂單、點評、加點項目，自動標籤：
```json
{
  "user_id": "uid_abc",
  "tags": ["常吃雞腿排", "不吃辣", "週五常來"],
  "recommendation": ["雞腿+豆腐套餐", "週五限時折扣提醒"]
}
```
- 資料來源：`orders`, `feedback`, `visit_time_stats`
- 後續建議導入 Collaborative Filtering 模型（如 TensorFlow Lite 推論）

### 3. 💌 推薦通知整合（智慧提醒）
- 每週或每次登入時自動彈出：
  - 「上次點的雞腿炸得不錯，今晚再來一份？」
  - 「你上次沒用完的折價券剩 2 天囉！」
- 可寫入 `personal_notifications` 集合 + 推播至 LINE Notify / 前台提醒氣泡

📌 本模組將強化顧客留存與個人化互動，並可納入後續 AI 自動生成優惠推薦訊息模組。


📄 不早脆皮雞排｜獎金制度邏輯設計 v4.2（Firebase Functions 擴充版）

...（保留前段內容）

---

## 🔧 Firebase Functions 實作建議（積分與推薦模組）

### 1. `calculateMonthlyPointsCarryOver()`
> 每月 1 號自動計算跨月積分保留量
```ts
export const calculateMonthlyPointsCarryOver = functions.pubsub.schedule('0 3 1 * *').onRun(async () => {
  const db = admin.firestore();
  const users = await db.collection('customer_profiles').get();

  for (const doc of users.docs) {
    const data = doc.data();
    const carryRate = 0.5; // 僅保留 50%
    const newPoints = Math.floor((data.points_this_month || 0) * carryRate);
    await doc.ref.update({
      points_total: (data.points_total || 0) + newPoints,
      points_this_month: 0
    });
    await db.collection('points_logs').add({
      user_id: doc.id,
      action: 'carry_over',
      value: newPoints,
      timestamp: admin.firestore.Timestamp.now()
    });
  }
});
```

### 2. `generateUserTagsAndRecommendations()`
> 每週一次掃描訂單與評價記錄，自動更新個人標籤與推薦項目
```ts
export const generateUserTagsAndRecommendations = functions.pubsub.schedule('every sunday 04:00').onRun(async () => {
  const db = admin.firestore();
  const users = await db.collection('customer_profiles').get();

  for (const doc of users.docs) {
    const userId = doc.id;
    const orders = await db.collection('orders').where('user_id', '==', userId).orderBy('created_at', 'desc').limit(10).get();
    const tagSet = new Set();

    orders.forEach(o => {
      const items = o.data().items;
      if (items.find(i => i.menu_item_id === 'chicken_leg')) tagSet.add('常吃雞腿排');
      if (o.data().notes?.includes('不要辣')) tagSet.add('不吃辣');
    });

    await doc.ref.update({
      tags: Array.from(tagSet),
      recommendation: ["雞腿+豆腐套餐", "週五限時折扣提醒"] // 可結合更動態邏輯生成
    });
  }
});
```

### 3. `sendPersonalReminders()`
> 推薦與提醒發送機制（登入時或週期性）
```ts
export const sendPersonalReminders = functions.https.onCall(async (data, context) => {
  const db = admin.firestore();
  const uid = context.auth?.uid;
  if (!uid) throw new functions.https.HttpsError('unauthenticated', '請先登入');

  const profile = await db.collection('customer_profiles').doc(uid).get();
  const reminders = [];

  if (profile.data().tags?.includes('常吃雞腿排')) {
    reminders.push("今晚再來一份雞腿排套餐吧！");
  }

  const coupons = await db.collection('coupon_records').where('user_id', '==', uid).where('is_used', '==', false).get();
  if (!coupons.empty) {
    reminders.push("您還有未使用的優惠券，快來使用唷！");
  }

  await db.collection('personal_notifications').add({
    user_id: uid,
    reminders,
    timestamp: Date.now()
  });

  return { reminders };
});
```

---

📌 以上 Functions 實作支援積分延續、自動標籤、個人推薦與智慧提醒，可獨立執行或搭配排程，並可進一步對接 LINE Notify、Web 前台氣泡訊息模組。

📄 不早脆皮雞排｜獎金制度邏輯設計 v4.3（Firebase Functions + 前台互動設計）

...（保留前段內容）

---

## 🔧 Firebase Functions 實作建議（積分與推薦模組）

...（保留前述函式內容）

---

## 💬 前台互動設計（積分推薦與提醒提示）

### 1. 🔔 首頁提醒氣泡（Personal Reminder Bubble）
- 顯示條件：登入後 10 秒自動觸發，或點擊「我的狀態」
- 顯示內容：由 `personal_notifications` 撈出最近一筆提醒內容
```json
{
  "reminders": [
    "今晚再來一份雞腿排套餐吧！",
    "您還有未使用的 $20 折價券唷～"
  ]
}
```
- 元件格式：左側雞排圖示 + 氣泡提示 + 「立即點餐」按鈕（可導入菜單頁）

### 2. 🧠 個人化推薦提示條（推薦 Banner）
- 出現在會員中心首頁上方，背景為用戶標籤配色（如常點炸物 → 背景炸雞圖）
```json
{
  "banner_text": "你喜歡的組合又來了：雞腿+豆腐只要 $99！",
  "cta": "一鍵點購"
}
```
- 點擊後導向推薦商品加入購物車，並於購物車標記為「推薦組合」

### 3. 🕒 積分到期提醒條（Points Expiration Warning）
- 出現在積分頁面頂部，若有即將過期點數則顯示
```json
{
  "expire_points": 80,
  "expire_date": "2025-07-01"
}
```
- 顯示樣式：「⚠️ 您有 80 點將於 7/1 過期，快來兌換優惠吧！」+ 立即兌換按鈕

### 4. 📬 優惠券推薦整合提醒
- 在使用者無動作狀態停留超過 15 秒時，自動推送優惠券建議提醒
```json
{
  "coupon_type": "滿 200 折 50",
  "message": "別錯過！這張券還可以幫你省 50 元！",
  "cta": "套用到訂單"
}
```

---

📌 此互動設計將讓會員更直觀接收到推薦與提醒資訊，有效提升再消費轉換率與積分活化率。建議搭配 LINE OA 推播與個人成就頁面串接展現動態提醒歷史紀錄。

📄 不早脆皮雞排｜獎金制度邏輯設計 v4.4（Firebase Functions + 前台互動設計 + LINE Notify）

...（保留前段內容）

---

## 🔧 Firebase Functions 實作建議（積分與推薦模組）

...（保留前述函式內容）

---

## 💬 前台互動設計（積分推薦與提醒提示）

...（保留前述互動模組內容）

---

## 📩 LINE Notify 與圖文訊息設計（會員互動推薦）

### A. 🎯 LINE Notify 單行訊息範本
| 類型 | 範例文字 |
|------|-----------|
| 推薦提示 | 您常點的雞腿排特價囉，今晚加點豆腐只要 $99！點我下單 🍗🍢 |
| 積分即將過期 | ⚠️ 您的 80 點積分將於 7/1 過期，快來兌換優惠吧！👉 https://...
| 優惠券提醒 | 🎁 滿 $200 折 $50 的優惠券即將到期！立即套用 👉 https://...

### B. 📚 多欄圖文訊息（Flex Message）
```json
{
  "type": "flex",
  "altText": "本月推薦優惠",
  "contents": {
    "type": "bubble",
    "hero": {
      "type": "image",
      "url": "https://cdn.nobearly.com/banner/chicken_combo.jpg",
      "size": "full",
      "aspectRatio": "20:13",
      "aspectMode": "cover"
    },
    "body": {
      "type": "box",
      "layout": "vertical",
      "contents": [
        { "type": "text", "text": "你上次最愛的雞腿組合回來囉！", "weight": "bold", "size": "md" },
        { "type": "text", "text": "雞腿+豆腐只要 $99，限時兩天！", "size": "sm", "color": "#555555" }
      ]
    },
    "footer": {
      "type": "box",
      "layout": "horizontal",
      "contents": [
        {
          "type": "button",
          "style": "primary",
          "color": "#ffcc00",
          "action": {
            "type": "uri",
            "label": "立即點餐",
            "uri": "https://order.nobearly.com"
          }
        }
      ]
    }
  }
}
```

### C. 🔄 推播流程建議
- 由 `sendPersonalReminders()` Cloud Function 呼叫 `lineNotifyApi()`（內含 access token）
- 預設每日最多一次推播，避免打擾
- 特殊事件推播（生日、點數清空前日）可設定高優先權並插入圖文訊息

---

📌 LINE Notify 與 Flex Message 推播可提升資訊到達率與點擊轉換率，建議與 Firebase `personal_notifications` 結合，支援手動發送與自動排程同步整合。


📄 不早脆皮雞排｜獎金制度邏輯設計 v4.5（會員個人中心整合）

...（保留前段內容）

---

## 🧭 會員個人中心｜整體架構與整合模組建議

### 🧱 模組主畫面區塊配置建議
| 區塊 | 說明 |
|------|------|
| 🎖️ 當前等級與積分 | 顯示目前會員等級（銅/銀/金/VIP）、總積分、即將過期積分提示 |
| 🧩 我的任務 | 今日任務 / 本週任務進度條、兌獎按鈕、歷史任務徽章 |
| 💸 我的優惠券 | 未使用優惠券清單（標示到期日）、立即使用按鈕 |
| 📊 歷史紀錄 | 消費歷史、點數兌換紀錄、抽獎中獎紀錄、發票紀錄（如有） |
| 🎯 個人推薦 | 本週推薦組合、點我加購按鈕、上次最愛提醒卡片 |
| 🔔 系統通知紀錄 | 最近 7 筆個人提醒與 LINE 推播紀錄，可回顧與手動再次套用 |

### 🧬 資料結構建議（可供前端一次撈取）
```json
{
  "user_id": "uid_001",
  "member_level": "金牌會員",
  "points_total": 1360,
  "points_expiring_soon": 80,
  "tasks": [
    { "task_id": "checkin", "title": "今日打卡", "status": "complete" },
    { "task_id": "order_3x", "title": "本週下單 3 次", "status": "in_progress" }
  ],
  "coupons": [
    { "id": "C1001", "title": "$50 折價券", "expires": "2025-07-01" }
  ],
  "history": {
    "orders": [...],
    "draws": [...],
    "points_logs": [...]
  },
  "recommendations": [
    "雞腿+豆腐套餐",
    "今晚炸雞半價券還在喔！"
  ],
  "notifications": [
    "6/3：您獲得生日券 $100",
    "6/2：推薦雞腿套餐已上架"
  ]
}
```

### 🧰 UI 功能元件建議
- ✅ Tab 切換或多欄式卡片排版（適合 PWA）
- ✅ 每區塊支援點擊查看詳細（進入任務紀錄頁、優惠券兌換頁）
- ✅ 導入 LINE 掃碼後直接進入會員中心（支援 deep link 導引）

---

📌 此設計整合所有獎勵／行銷／互動邏輯至單一視圖，可作為 LINE OA、網頁會員中心與 Web App 共用框架，建議同步整合 Firebase `customer_profiles`, `tasks`, `coupons`, `recommendations`, `notifications` 等集合進行資料合併查詢。
📄 不早脆皮雞排｜獎金制度邏輯設計 v4.6（Security + 測試腳本 + UI 草圖）

...（保留前段內容）

---

## 🔐 Firestore Security Rules（會員個資與互動模組）

```ts
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // 僅本人可讀寫個人資料
    match /customer_profiles/{userId} {
      allow read, update: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null;
      allow delete: if false;
    }

    // 任務狀態讀寫
    match /tasks/{taskId} {
      allow read, write: if request.auth != null && request.auth.uid == resource.data.user_id;
    }

    // 優惠券僅本人讀取
    match /coupons/{couponId} {
      allow read: if request.auth != null && request.auth.uid == resource.data.user_id;
      allow update: if request.auth.uid == resource.data.user_id;
    }

    // 系統推薦與通知
    match /recommendations/{recId}, /notifications/{noteId} {
      allow read: if request.auth.uid == resource.data.user_id;
    }
  }
}
```

---

## 🧪 測試資料與模擬腳本（QA／教學使用）

### 📦 建立測試會員
```json
{
  "user_id": "uid_test001",
  "member_level": "銅牌會員",
  "points_total": 500,
  "points_expiring_soon": 50,
  "tags": ["週五常客", "不吃辣"]
}
```

### 🧩 模擬任務資料
```json
{
  "task_id": "weekly_order_3x",
  "user_id": "uid_test001",
  "title": "一週下單 3 次",
  "status": "in_progress",
  "progress": 2,
  "goal": 3
}
```

### 🎁 測試用優惠券
```json
{
  "coupon_id": "TEST_COUPON_50",
  "user_id": "uid_test001",
  "title": "$50 折價券",
  "expires": "2025-07-01",
  "is_used": false
}
```

---

## 🎨 畫面設計風格建議 + Figma 樣式說明

### 🌈 主題方向：
- 視覺風格：活潑卡片式介面 + 食物色調（炸雞金黃 / 豆腐米白 / 辣椒紅）
- 字體搭配：標題使用 Noto Sans Bold、內文使用微軟正黑體
- 元件風格：圓角卡片（16px）、陰影浮出、ICON 搭配 Emoji

### 🖼️ Figma 範本建議（命名層級）
- `Page: MemberCenter`
  - `Card: LevelInfo`
  - `Card: Tasks`
  - `Card: Coupons`
  - `Card: History`
  - `Popup: NotificationBubble`
  - `FlexMessage: LINE 推薦卡`

📌 可依照元件進行開發切圖、UI Flow 模擬與多裝置適配展示。

---

📌 上述項目為會員模組的安全防護、測試示例與設計語言建議，能支援開發初期的驗證流程、後期的教學展示與整體 UI 統一風格建置。
📄 不早脆皮雞排｜獎金制度邏輯設計 v4.6（Security + 測試腳本 + UI 草圖）

...（保留前段內容）

---

## 🔐 Firestore Security Rules（會員個資與互動模組）

```ts
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // 僅本人可讀寫個人資料
    match /customer_profiles/{userId} {
      allow read, update: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null;
      allow delete: if false;
    }

    // 任務狀態讀寫
    match /tasks/{taskId} {
      allow read, write: if request.auth != null && request.auth.uid == resource.data.user_id;
    }

    // 優惠券僅本人讀取
    match /coupons/{couponId} {
      allow read: if request.auth != null && request.auth.uid == resource.data.user_id;
      allow update: if request.auth.uid == resource.data.user_id;
    }

    // 系統推薦與通知
    match /recommendations/{recId}, /notifications/{noteId} {
      allow read: if request.auth.uid == resource.data.user_id;
    }
  }
}
```

---

## 🧪 測試資料與模擬腳本（QA／教學使用）

### 📦 建立測試會員
```json
{
  "user_id": "uid_test001",
  "member_level": "銅牌會員",
  "points_total": 500,
  "points_expiring_soon": 50,
  "tags": ["週五常客", "不吃辣"]
}
```

### 🧩 模擬任務資料
```json
{
  "task_id": "weekly_order_3x",
  "user_id": "uid_test001",
  "title": "一週下單 3 次",
  "status": "in_progress",
  "progress": 2,
  "goal": 3
}
```

### 🎁 測試用優惠券
```json
{
  "coupon_id": "TEST_COUPON_50",
  "user_id": "uid_test001",
  "title": "$50 折價券",
  "expires": "2025-07-01",
  "is_used": false
}
```

---

## 🎨 畫面設計風格建議 + Figma 樣式說明

### 🌈 主題方向：
- 視覺風格：活潑卡片式介面 + 食物色調（炸雞金黃 / 豆腐米白 / 辣椒紅）
- 字體搭配：標題使用 Noto Sans Bold、內文使用微軟正黑體
- 元件風格：圓角卡片（16px）、陰影浮出、ICON 搭配 Emoji

### 🖼️ Figma 範本建議（命名層級）
- `Page: MemberCenter`
  - `Card: LevelInfo`
  - `Card: Tasks`
  - `Card: Coupons`
  - `Card: History`
  - `Popup: NotificationBubble`
  - `FlexMessage: LINE 推薦卡`

📌 可依照元件進行開發切圖、UI Flow 模擬與多裝置適配展示。

---

📌 上述項目為會員模組的安全防護、測試示例與設計語言建議，能支援開發初期的驗證流程、後期的教學展示與整體 UI 統一風格建置。

📄 不早脆皮雞排｜獎金制度邏輯設計 v4.7（POS 點餐系統與菜單擴充）

...（保留前段內容）

---

## 🧩 POS 點餐系統與餐點設定擴充模組設計

### 🍱 A. 套餐邏輯與菜單結構升級

#### Firestore 結構：`menu_combos`
```json
{
  "combo_id": "combo_set_A",
  "title": "經典雞腿套餐",
  "price": 135,
  "required_groups": [
    {
      "label": "主餐",
      "required": true,
      "items": ["chicken_leg", "chicken_wing"]
    },
    {
      "label": "副餐",
      "required": false,
      "items": ["fries", "tofu"]
    },
    {
      "label": "飲料",
      "required": true,
      "items": ["drink_coke", "drink_tea"]
    }
  ]
}
```

---

### 🧂 B. 備註選單模組（標準化屬性）
#### Firestore：`menu_options`
```json
{
  "option_id": "spice_level",
  "label": "辣度",
  "values": ["不辣", "小辣", "中辣", "大辣"]
}
```
- 每筆菜單品項可綁定多個 `option_id`
- 前台點餐可彈出選擇視窗供使用者點選

---

### 📦 C. 原料庫存對接與自動停售
#### Firestore：`inventory_items`
```json
{
  "item_id": "chicken_leg",
  "name": "雞腿原料",
  "stock_qty": 48,
  "linked_menu": ["chicken_leg", "combo_set_A"]
}
```
- 每次下單即扣對應食材數量，若為 0 自動將菜單項目 `available: false`

---

### 🔄 D. 暫存訂單與快速複製前單
#### Firestore：`draft_orders`
```json
{
  "staff_id": "店員A",
  "created_at": "2025-06-04T13:01",
  "cart": [...],
  "status": "draft"
}
```
- 若 POS 關閉未送出，暫存可保留於 localStorage + Firestore 雙通道
- 支援複製上一張訂單的快捷功能（for 熟客）

---

### 💬 E. 行銷互動模組建議（加購彈窗、首購提示）
```json
{
  "trigger": "first_time_customer",
  "popup": {
    "title": "首次下單加價購 $20！",
    "items": ["tofu", "drink_tea"]
  },
  "cta": "點我加購"
}
```
- 條件包含：首次下單、金額達標、時間區段優惠等

---

### 🎛️ F. 多店菜單版本管理建議
#### Firestore：`menu_versions`, `store_menu_assignments`
```json
{
  "version_id": "menu_20250601",
  "title": "六月夏季菜單",
  "menu_items": ["chicken_leg", "fries", "combo_set_A"]
}
```
```json
{
  "store_id": "中壢龍崗店",
  "menu_version_id": "menu_20250601"
}
```
- 支援品牌統一版本／分店個別客製版本切換

---

📌 上述擴充模組可與現有 POS 點餐系統整合，提升操作效率、行銷靈活度與庫存同步準確性。如需 UI 模板與快速切換 API 設計，可另補上。
📄 不早脆皮雞排｜獎金制度邏輯設計 v4.8（POS 點餐 UI + API 設計）

...（保留前段內容）

---

## 🧩 POS 點餐系統與餐點設定擴充模組設計

...（保留既有結構）

---

## 🖼️ POS 點餐系統｜前台畫面草圖建議

### A. 套餐組合畫面元件
- 分三欄步驟式選擇（主餐 → 副餐 → 飲料）
- 每一欄為 `OptionCardGroup`：顯示圖、品名、加價文字
- 最下方 `ComboSummaryCard` 顯示已選項目與總價更新

### B. 備註與標準屬性介面
- 餐點點選後彈出 `MenuItemOptionModal`
  - 預設列出綁定的 `menu_options`（如辣度、份量）
  - 可切換為「自由輸入備註」區塊

### C. 暫存訂單 UI（POS 主介面）
- 側邊欄「草稿訂單」按鈕
- 彈出 `DraftOrderListDrawer` 顯示目前暫存訂單清單
- 每筆支援：恢復編輯、刪除、複製為新單

### D. 首購加購彈窗元件（條件觸發）
- 當顧客符合「首次下單」條件時：
  - 彈出 `FirstTimeUpsellPopup`
  - 顯示推薦炸物/飲料加購圖與「$20 加購」按鈕

---

## 🔌 API 呼叫結構設計

### 1. 新增訂單 API `/api/orders/create`
```json
POST /orders/create
{
  "user_id": "uid_001",
  "cart": [
    { "item_id": "chicken_leg", "options": { "辣度": "小辣" }, "qty": 1 }
  ],
  "combo_id": null,
  "total": 75,
  "store_id": "中壢龍崗店"
}
```
- 成功回傳：訂單編號與預估完成時間

### 2. 草稿儲存 API `/api/orders/draft`
```json
POST /orders/draft
{
  "staff_id": "店員A",
  "cart": [...],
  "created_at": "timestamp"
}
```

### 3. 套餐選項載入 `/api/menu/combo/{combo_id}`
```json
GET /menu/combo/combo_set_A
→ 回傳主餐/副餐/飲料分組選項與品項資訊
```

---

📌 上述為 POS 端 UI 元件構造建議與對應後端 API 規格範例，可直接交由前後端進行畫面與串接實作。


📄 不早脆皮雞排｜獎金制度邏輯設計 v4.8（POS 點餐 UI + API 設計）

...（保留前段內容）

---

## 🧩 POS 點餐系統與餐點設定擴充模組設計

...（保留既有結構）

---

## 🖼️ POS 點餐系統｜前台畫面草圖建議

### A. 套餐組合畫面元件
- 分三欄步驟式選擇（主餐 → 副餐 → 飲料）
- 每一欄為 `OptionCardGroup`：顯示圖、品名、加價文字
- 最下方 `ComboSummaryCard` 顯示已選項目與總價更新

### B. 備註與標準屬性介面
- 餐點點選後彈出 `MenuItemOptionModal`
  - 預設列出綁定的 `menu_options`（如辣度、份量）
  - 可切換為「自由輸入備註」區塊

### C. 暫存訂單 UI（POS 主介面）
- 側邊欄「草稿訂單」按鈕
- 彈出 `DraftOrderListDrawer` 顯示目前暫存訂單清單
- 每筆支援：恢復編輯、刪除、複製為新單

### D. 首購加購彈窗元件（條件觸發）
- 當顧客符合「首次下單」條件時：
  - 彈出 `FirstTimeUpsellPopup`
  - 顯示推薦炸物/飲料加購圖與「$20 加購」按鈕

---

## 🔌 API 呼叫結構設計

### 1. 新增訂單 API `/api/orders/create`
```json
POST /orders/create
{
  "user_id": "uid_001",
  "cart": [
    { "item_id": "chicken_leg", "options": { "辣度": "小辣" }, "qty": 1 }
  ],
  "combo_id": null,
  "total": 75,
  "store_id": "中壢龍崗店"
}
```
- 成功回傳：訂單編號與預估完成時間

### 2. 草稿儲存 API `/api/orders/draft`
```json
POST /orders/draft
{
  "staff_id": "店員A",
  "cart": [...],
  "created_at": "timestamp"
}
```

### 3. 套餐選項載入 `/api/menu/combo/{combo_id}`
```json
GET /menu/combo/combo_set_A
→ 回傳主餐/副餐/飲料分組選項與品項資訊
```

---

📌 上述為 POS 端 UI 元件構造建議與對應後端 API 規格範例，可直接交由前後端進行畫面與串接實作。

接下來可以補強以下三個關鍵流程與技術設計，來完成整套 POS 點餐系統的閉環開發架構：

---

## ✅ 建議擴充模組（POS 完整化流程）

### 1. 🔐 權限驗證與登入管理（POS 使用者）
- **模組建議：** 員工登入（POS 專屬）支援 Firebase Auth + custom claims  
- **用途：** 控管訂單建立者、暫存單關聯、打單記錄

```ts
// Firestore rules 擴充
match /draft_orders/{docId} {
  allow read, write: if request.auth != null && request.auth.token.role in ['staff', 'manager'];
}
```

---

### 2. 🧾 自動出單整合（含音訊與列印觸發）
- **功能設計：**
  - 完成下單 → `order.created` → Cloud Function 呼叫：
    - 🖨️ 熱感應出單（串熱感印機藍牙/網路印表）
    - 🔊 語音播報（如整合 LINE Things 或 MQTT 訊號）
    - 🔔 前台顯示取餐號碼牌
- **實作觸發建議：**
```ts
export const onOrderCreated = functions.firestore
  .document('orders/{orderId}')
  .onCreate(async (snap, context) => {
    const data = snap.data();
    await notifyPrinter(data);
    await notifyAudioSystem(data.order_number);
  });
```

---

### 3. 📦 出餐狀態追蹤與編號管理
- **狀態流程：**
  1. 建立訂單：`created`
  2. 製作中：`preparing`
  3. 完成：`ready`
  4. 顧客領取：`picked_up`
- **前台管理建議：**
  - 對應 `KitchenDashboard` 模組（顯示訂單進度）
  - 支援「完成」與「取消」操作按鈕
  - 每筆訂單應含 `order_number` + `store_id` + `created_at`

---

是否要我補上這三個模組的 UI 操作畫面結構 + 對應資料格式（Firestore + API）？

📄 不早脆皮雞排｜獎金制度邏輯設計 v4.9（POS 點餐流程 + 出單控制 + 權限驗證）

...（保留前段內容）

---

## 🧩 POS 點餐系統與餐點設定擴充模組設計

...（保留既有結構）

---

## 🖼️ POS 點餐系統｜前台畫面草圖建議

...（保留既有草圖模組）

---

## 🔌 API 呼叫結構設計

...（保留既有 API 結構）

---

## 🔐 POS 員工權限登入模組 + 出單/語音整合

### A. 員工登入與角色驗證
```ts
POST /auth/login
{
  "account": "staff001",
  "password": "hashed_pw"
}
→ 回傳 Firebase customToken 與 role claim（staff / manager）
```
- 權限控制建議：
```ts
match /draft_orders/{docId} {
  allow read, write: if request.auth != null && request.auth.token.role in ['staff', 'manager'];
}
```

### B. 出單與語音 API 觸發
```ts
POST /order/notify_printer
{
  "order_id": "ORD2306-1220",
  "store_id": "中壢龍崗店"
}
```
```ts
POST /order/notify_speaker
{
  "message": "A123號餐點完成，請取餐"
}
```
- 可結合 WebSocket、MQTT、LINE Things 做即時出單與語音播報

### C. 廚房出單進度畫面（Kitchen Dashboard）
- 元件：`KitchenTicketCard`
  - 顯示訂單編號、時間、品項摘要、備註
  - 按鈕：✅ 完成製作、❌ 取消訂單、🔄 更新狀態
- UI 建議：以「三欄格」為主（`製作中` / `已完成待取餐` / `已取餐`）
- Firestore 結構：
```json
{
  "order_id": "ORD2306-1220",
  "status": "preparing",
  "order_number": "A123",
  "store_id": "中壢龍崗店",
  "created_at": Timestamp
}
```

---

📌 此設計整合 POS 實體使用場景中的「打單 → 製作 → 播報 → 完成 → 領餐」全流程，並結合員工權限與多端裝置互通。

📄 不早脆皮雞排｜獎金制度邏輯設計 v5.0（POS 出單整合 + 自動列印模組）

...（保留前段內容）

---

## 🧩 POS 點餐系統與餐點設定擴充模組設計

...（保留既有結構）

---

## 🖼️ POS 點餐系統｜前台畫面草圖建議

...（保留既有草圖模組）

---

## 🔌 API 呼叫結構設計

...（保留既有 API 結構）

---

## 🔐 POS 員工權限登入模組 + 出單/語音整合

...（保留既有模組）

---

## 🖨️ 自動出單模組設計（Firebase Functions + 樣板格式）

### A. Firebase Function：訂單建立後自動列印
```ts
exports.printOnOrderCreated = functions.firestore
  .document('orders/{orderId}')
  .onCreate(async (snap) => {
    const order = snap.data();
    const printText = generatePrintText(order);
    await axios.post('http://your-printer-host/api/feieyun-print', {
      sn: order.printer_sn,
      content: printText,
      copies: 1
    });
  });
```

### B. 出單樣板格式轉換函數
```ts
function generatePrintText(order) {
  const header = `\n【不早脆皮雞排】\n訂單編號：${order.order_number}\n時間：${new Date(order.created_at._seconds * 1000).toLocaleTimeString()}`;
  const items = order.items.map(i => `\n${i.qty}x ${i.name} ${i.price * i.qty}元`).join('');
  const footer = `\n--------------------\n總計：${order.total}元\n感謝光臨！\n`;
  return header + items + footer;
}
```

### C. 出單記錄資料結構（bonus_print_logs）
```json
{
  "order_id": "ORD2306-1220",
  "store_id": "內壢忠孝",
  "printed_at": "2025-06-04T13:25",
  "printer_sn": "printer1234",
  "status": "success",
  "copies": 1,
  "content_hash": "a1b2c3d4"
}
```
- 支援失敗重印功能（可透過管理後台觸發）
- 可與 LINE Notify 搭配推播出單成功或異常警示

---

📌 此模組完成「訂單 → 自動列印 → 列印紀錄保存 → 重印控制」全流程，並支援雲端印表 API 接入與 Firebase Functions 自動執行。建議列印內容支援 QR 或店員標示備註一併呈現。

📄 不早脆皮雞排｜獎金制度邏輯設計 v5.1（出單監控 + 錯誤提示 + 重印 UI）

...（保留前段內容）

---

## 🖨️ 自動出單模組設計（Firebase Functions + 樣板格式）

...（保留既有列印流程）

---

## 📡 出單設備監控與重印功能設計

### A. 印表機狀態監控（printer_status）
```json
{
  "printer_sn": "printer1234",
  "store_id": "中壢龍崗店",
  "last_checkin": "2025-06-04T13:30",
  "online": true,
  "last_status": "ready"
}
```
- 每 60 秒由 local server ping 印表機狀態並回報
- 若超過 3 分鐘未更新 → 自動標記離線，前台出現「⚠️ 未連線」紅標

### B. 列印錯誤提示流程（錯誤碼回傳處理）
```ts
try {
  await axios.post('/api/feieyun-print', {...});
} catch (err) {
  await db.collection('bonus_print_logs').add({
    order_id: order.id,
    status: 'failed',
    error_code: err.response.data.ret,
    error_msg: err.response.data.msg || '列印失敗',
    timestamp: Date.now()
  });
  await notifyAdminLINE(`❌ 訂單 ${order.order_number} 列印失敗：${err.response.data.msg}`);
}
```
- 支援回報錯誤原因（如：餘紙不足、印表機離線）並推送給管理員

### C. 後台重印操作介面（重印控制）
- UI 模組：`PrintLogsListTable`
  - 欄位：訂單編號、狀態（成功 / 失敗）、錯誤原因、列印時間、店別、操作人
  - 按鈕：🔁 重新列印（僅限錯誤 / 管理員身份）

```json
POST /api/reprint
{
  "order_id": "ORD2306-1220",
  "reason": "補列印失敗"
}
```
- 成功後寫入新的列印記錄，並更新原始紀錄 `status: reprinted`

---

📌 此模組補足出單設備實際使用時的「狀態偵測」、「異常處理」、「重印控制」三大關鍵，並支援 LINE 通知與後台操作紀錄留存，建議搭配店員帳號與時間戳進行稽核補強。

📄 不早脆皮雞排｜獎金制度邏輯設計 v5.2（出單監控 + 錯誤提示 + 重印 UI + 前台圖示 + LINE 卡片）

...（保留前段內容）

---

## 🖨️ 自動出單模組設計（Firebase Functions + 樣板格式）

...（保留既有列印流程）

---

## 📡 出單設備監控與重印功能設計

...（保留 printer_status / print_logs 記錄邏輯）

---

## 🖼️ 前台 UI：出單紀錄與重印圖示模組

### A. 出單紀錄顯示區塊（for 管理員 / 店員）
元件：`PrintHistoryCard`
- 顯示：
  - 訂單編號、列印時間、印表機 SN
  - 狀態標籤：🟢 成功 / 🔴 失敗 / 🔁 已重印
  - [🔁 重印] 按鈕（限權限）

### B. 出單狀態氣泡（於訂單詳情內嵌）
- 顯示於每筆訂單卡下方：
  - 「🖨️ 正在列印中...」
  - 「✅ 列印完成」
  - 「❌ 列印失敗：請重印或檢查設備」

---

## 📬 LINE Notify 推播卡片設計（Flex Message）

### 1. 成功提示卡片
```json
{
  "type": "flex",
  "altText": "訂單已列印成功",
  "contents": {
    "type": "bubble",
    "body": {
      "type": "box",
      "layout": "vertical",
      "contents": [
        { "type": "text", "text": "✅ 訂單 A123 已成功列印", "weight": "bold", "size": "lg", "color": "#00AA00" },
        { "type": "text", "text": "列印時間：13:25", "size": "sm" }
      ]
    }
  }
}
```

### 2. 錯誤通知卡片
```json
{
  "type": "flex",
  "altText": "列印失敗通知",
  "contents": {
    "type": "bubble",
    "body": {
      "type": "box",
      "layout": "vertical",
      "contents": [
        { "type": "text", "text": "❌ 訂單 A123 列印失敗", "weight": "bold", "size": "lg", "color": "#FF3333" },
        { "type": "text", "text": "原因：印表機離線" },
        { "type": "button", "style": "primary", "action": { "type": "uri", "label": "重新列印", "uri": "https://admin.nobearly.com/reprint/A123" } }
      ]
    }
  }
}
```

---

📌 本模組完成管理員可視覺化查看出單狀態、手動補列印與 LINE 即時通知介面，適用於門市即時處理流程與後勤支援。

📄 不早脆皮雞排｜獎金制度邏輯設計 v5.3（出單綁定設定 + 異常統計報表模組）

...（保留前段內容）

---

## 🖨️ 自動出單模組設計（Firebase Functions + 樣板格式）

...（保留既有列印流程）

---

## 📡 出單設備監控與重印功能設計

...（保留 printer_status / print_logs 記錄邏輯）

---

## 🖼️ 前台 UI：出單紀錄與重印圖示模組

...（保留 PrintHistoryCard 設計）

---

## 📬 LINE Notify 推播卡片設計（Flex Message）

...（保留 LINE 卡片）

---

## ⚙️ 店面印表機與音響綁定設定介面（分店後台）

### A. Firestore 結構：`store_devices`
```json
{
  "store_id": "中壢龍崗店",
  "printer_sn": "SN-PR1234",
  "audio_module_id": "SPK-8899",
  "location": "櫃檯後台",
  "last_heartbeat": "2025-06-04T13:25",
  "online": true
}
```

### B. 管理後台介面
元件：`StoreDeviceBindingPanel`
- 下拉選擇印表機 SN / 音響模組 ID
- 顯示目前綁定設備狀態（🟢 正常 / 🔴 離線）
- [📎 綁定] 與 [🔄 解除綁定] 按鈕

---

## 📊 每日出單統計與異常報表模組

### A. 報表範例（Firestore：`print_daily_summary`）
```json
{
  "store_id": "中壢龍崗店",
  "date": "2025-06-04",
  "total_orders": 82,
  "printed_success": 79,
  "failed_count": 3,
  "most_common_error": "印表機離線"
}
```

### B. 報表介面建議元件
- `PrintStatsCard`（顯示總數 + 異常數）
- `PrintErrorTrendChart`（近 7 日錯誤趨勢）
- `TopFailureStoresTable`（顯示錯誤率最高的店別 + 錯誤原因）

📌 建議此報表模組結合 LINE Notify 定時推播給區域管理者，如：每日 21:00 統計昨日印表穩定性，並建議補救動作。

📄 不早脆皮雞排｜獎金制度邏輯設計 v5.4（異常推播 + 設備維護建議）

...（保留前段內容）

---

## 🖨️ 自動出單模組設計（Firebase Functions + 樣板格式）

...（保留既有列印流程）

---

## 📡 出單設備監控與重印功能設計

...（保留 printer_status / print_logs 記錄邏輯）

---

## 🖼️ 前台 UI：出單紀錄與重印圖示模組

...（保留 PrintHistoryCard 設計）

---

## 📬 LINE Notify 推播卡片設計（Flex Message）

...（保留 LINE 卡片）

---

## ⚙️ 店面印表機與音響綁定設定介面（分店後台）

...（保留 store_devices 結構與綁定操作）

---

## 📊 每日出單統計與異常報表模組

...（保留統計與報表介面）

---

## 🛎️ 出單異常 LINE 定時推播與設備維護提示

### A. 每日定時統計推播設計（自動）
> Firebase Functions `schedule('every day 21:00')`
```ts
exports.sendDailyPrinterStatus = functions.pubsub.schedule('0 21 * * *').timeZone('Asia/Taipei').onRun(async () => {
  const summaries = await db.collection('print_daily_summary').where('date', '==', today()).get();
  for (const doc of summaries.docs) {
    const data = doc.data();
    if (data.failed_count > 0) {
      await sendLineNotify(data.store_id, `⚠️ ${data.store_id} 今日列印失敗 ${data.failed_count} 筆，請檢查印表機設定或重新綁定。`);
    }
  }
});
```

### B. 推播內容設計建議
- 正常店面：🟢「今日列印皆正常，累計 82 單。」
- 異常店面：🔴「列印異常 3 次（印表機離線），請儘速處理。」

### C. 維護建議模組（可視化）
- 顯示連續異常店面清單（近 3 天）
- 為每台印表機設立「維護狀態」欄位：`last_maintenance`、`issue_notes`
- 元件：`PrinterMaintenancePanel`
  - 管理員可記錄維修結果與下次檢查提醒

📌 本模組將出單異常統計與 LINE 通報串接，強化門市與管理層設備監控反應機制，亦可進一步納入預防性維修排程與設備異常日誌。


📄 不早脆皮雞排｜獎金制度邏輯設計 v5.5（維修排程 + 自動關閉設備 + 優先級排序）

...（保留前段內容）

---

## 🖨️ 自動出單模組設計（Firebase Functions + 樣板格式）

...（保留既有列印流程）

---

## 📡 出單設備監控與重印功能設計

...（保留 printer_status / print_logs 記錄邏輯）

---

## 🖼️ 前台 UI：出單紀錄與重印圖示模組

...（保留 PrintHistoryCard 設計）

---

## 📬 LINE Notify 推播卡片設計（Flex Message）

...（保留 LINE 卡片）

---

## ⚙️ 店面印表機與音響綁定設定介面（分店後台）

...（保留 store_devices 結構與綁定操作）

---

## 📊 每日出單統計與異常報表模組

...（保留統計與報表介面）

---

## 🛎️ 出單異常 LINE 定時推播與設備維護提示

...（保留每日推播與維修面板設計）

---

## 🔁 擴充模組：異常優先處理排序 + 自動設備鎖定 + 維修排程提醒

### A. 出單異常優先級自動排序
- 每台設備每日記錄異常指數（失敗次數 / 成功次數）
- Firestore：`printer_status.priority_score`
- 排序條件：
  1. 三日內異常率高者優先
  2. 最近從未維修者優先

### B. 自動標記設備為「維修中」
```ts
if (printer.failed_streak >= 5) {
  await db.collection('store_devices').doc(printer.id).update({
    status: 'maintenance',
    auto_flagged: true
  });
  await sendLineNotify(printer.store_id, `🚫 ${printer.name} 連續 5 筆列印失敗，已自動進入維修中狀態。`);
}
```
- 前台將無法使用該設備直到解除維護標籤

### C. 預約維修排程與檢查提醒
- 為每台設備新增：`next_check_date`, `assigned_maintainer`
```json
{
  "device_id": "printer123",
  "next_check_date": "2025-06-08",
  "assigned_maintainer": "技術員小黃"
}
```
- 每日 9:00 推播今日預定檢查清單給指定技術人員

📌 本段設計讓維修與風險控管自動化、可視化，並加入「設備自動停用機制」與優先處理建議，降低店面作業中斷風險。



以下是專門為你目前的 Firebase + PWA 無伺服器專案設計的「版本更新機制」補充說明段落，可直接加在《整合專案報告》的尾端（第 10 節或附錄中）：

---

## 📦 附錄：PWA 版本更新與快取控制機制補充

為確保使用者在已安裝 PWA 的裝置中能**即時獲取新版功能與修正**，本系統新增一套與 Firebase Hosting 相容、無須用戶手動操作即可觸發的版本更新架構。

### 🔧 功能設計目標

| 目標                    | 描述                             |
| --------------------- | ------------------------------ |
| 強制版本一致性               | 所有終端皆能自動偵測並升級至最新版本             |
| 與現有 Service Worker 相容 | 不破壞現有快取邏輯與 Firebase Hosting 配置 |
| 無需使用者手動清除快取           | 系統主動提示或自動重整                    |
| 避免無窮 reload 或重複觸發     | 加入版本比對與 debounce 邏輯            |

---

### 🧩 系統結構概述

```
📁 public/
 ├── index.html
 ├── version.json ← ★新增
 ├── service-worker.js ← ★改寫
 └── main.js / app.js（版本檢查邏輯）
```

---

### 📄 1. `version.json`（由 CI 或開發階段寫入）

```json
{ "version": "1.0.3" }
```

可手動管理或於自動部署流程中自動產生（如 CI 時讀取 package.json 寫入）。

---

### 🧠 2. 版本偵測邏輯（嵌入 `main.js` 或入口點）

```js
fetch('/version.json')
  .then(res => res.json())
  .then(remote => {
    const local = localStorage.getItem('app_version');
    if (!local || remote.version !== local) {
      localStorage.setItem('app_version', remote.version);
      window.location.reload(true); // ⛔ 若須顯示提示可改為 showUpdateBanner()
    }
  })
  .catch(() => {
    console.warn('版本偵測失敗，跳過更新檢查。');
  });
```

---

### 🔁 3. `service-worker.js` 需支援立即更新

```js
self.addEventListener('install', (event) => {
  self.skipWaiting(); // 立即取代現有 SW
});

self.addEventListener('activate', (event) => {
  clients.claim(); // 讓新 SW 立刻控制所有頁面
});
```

若使用 `workbox` 或 Firebase 自動產生的 SW，需自行加入上述邏輯或將 `injectManifest` 模式改為手動。

---

### 🛠️ 4. Hosting 設定建議（firebase.json）

```json
"headers": [
  {
    "source": "/version.json",
    "headers": [{ "key": "Cache-Control", "value": "no-cache" }]
  }
]
```

確保 `version.json` 永遠為最新，不被快取。

---

### ⚠️ 相容性與無衝突驗證

| 驗證項目                      | 結果                                       |
| ------------------------- | ---------------------------------------- |
| 與 Firebase Hosting 快取邏輯衝突 | ❌ 無（獨立版本檔不使用快取）                          |
| 與現有 manifest 與 SW 運作衝突    | ❌ 無（維持現有流程，僅增強刷新）                        |
| 使用者安裝舊版本是否能自動更新           | ✅ 是（首次進入會強制比對並 reload）                   |
| 舊瀏覽器支援                    | ✅ 支援所有主流 PWA 瀏覽器（Chrome 70+, Safari 13+） |

---

### 🚨 錯誤容錯與回退策略

* 若版本偵測失敗 → 顯示警告，不影響功能運作
* 若 version.json 缺失 → 默認跳過比對
* 可選擇實作 fallback 頁提示使用者「系統已更新，請重新整理」

---

### 🧪 測試驗收建議

1. 模擬版本升級：更改 `version.json` 後部署 → 確認用戶端是否 reload。
2. 模擬 Service Worker 更新：變動 `sw.js` 並觀察是否觸發更新。
3. 離線裝置重新上線後，是否自動取得新版本。
4. 實機安裝於 Android/iOS 的 PWA 環境進行重整與版本測試。

---

### ✅ 建議後續工作

* 建立 `generate-version.js` 腳本，在部署前自動寫入 `version.json`
* 將該機制加入 Firebase CI/CD 流程（如 GitHub Actions 或 deploy script）
* 為不同端（顧客/員工/後台）建立獨立的 `version.json`（如 `/staff-version.json`）

---

是否要我幫你同時產出 `service-worker.js` 與 `main.js` 對應版本更新完整範例？

以下是完整可直接部署的範例，**相容 Firebase Hosting 與你目前的 PWA 架構**，實作「版本更新偵測 + 自動更新 + 快取控制」：

---

## 📁 檔案 1：`public/version.json`

```json
{
  "version": "1.0.3"
}
```

每次發版時請修改這個值，例如 `1.0.4`、`2.0.0` 等。

---

## 📄 檔案 2：`public/service-worker.js`

```js
const CACHE_NAME = 'pwa-cache-v1.0.3'; // 每次版本更新務必修改此名稱
const urlsToCache = [
  '/',
  '/index.html',
  '/main.js',
  '/version.json',
  '/manifest.json',
  // 其他靜態資源（如 css/js/img）
];

self.addEventListener('install', (event) => {
  self.skipWaiting(); // ⏱ 立即生效
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => cache.addAll(urlsToCache))
  );
});

self.addEventListener('activate', (event) => {
  clients.claim(); // 接管所有頁面
  event.waitUntil(
    caches.keys().then((cacheNames) =>
      Promise.all(
        cacheNames
          .filter((name) => name !== CACHE_NAME)
          .map((name) => caches.delete(name))
      )
    )
  );
});

self.addEventListener('fetch', (event) => {
  if (event.request.url.includes('/version.json')) {
    // 強制走網路取得
    return event.respondWith(fetch(event.request));
  }
  event.respondWith(
    caches.match(event.request).then((response) => response || fetch(event.request))
  );
});
```

---

## 📄 檔案 3：`public/main.js`（或入口腳本）

```js
function checkAppVersion() {
  fetch('/version.json', { cache: 'no-cache' }) // 保證抓最新
    .then((res) => res.json())
    .then((remote) => {
      const localVersion = localStorage.getItem('app_version');
      if (remote.version !== localVersion) {
        localStorage.setItem('app_version', remote.version);
        console.log('[PWA] 新版本偵測到，即將重整...');
        window.location.reload(true); // 強制更新頁面
      }
    })
    .catch(() => {
      console.warn('[PWA] 無法檢查版本，跳過更新。');
    });
}

// 呼叫版本檢查
checkAppVersion();
```

---

## 📁 Hosting 設定建議（firebase.json）

```json
{
  "hosting": {
    "public": "public",
    "ignore": ["firebase.json", "**/.*", "**/node_modules/**"],
    "headers": [
      {
        "source": "/version.json",
        "headers": [
          { "key": "Cache-Control", "value": "no-store" }
        ]
      }
    ]
  }
}
```

---

## ✅ 加入部署流程（可選）

若你使用 CI/CD，可加入以下腳本在部署前自動更新 `version.json`：

```bash
VERSION=$(cat package.json | jq -r .version)
echo "{\"version\": \"$VERSION\"}" > public/version.json
```

---

這整套架構部署後：

✅ 舊用戶進入時會自動重整
✅ Firebase Hosting 快取控制沒問題
✅ 不會和你的 PWA + Firebase 功能衝突
✅ 發新版本只要更新 `version.json` 或 `CACHE_NAME` 就行

要不要我幫你做成專用 CI script？還是你要 Figma 設計一個「版本更新提示視窗」UI？

